{"version":3,"file":"extension.js","mappings":"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","sources":["webpack://ki-autoagent-vscode/./src/agents/ArchitectAgent.ts","webpack://ki-autoagent-vscode/./src/core/MemoryManager.ts","webpack://ki-autoagent-vscode/./src/agents/CodeSmithAgent.ts","webpack://ki-autoagent-vscode/./src/core/AgentRegistry.ts","webpack://ki-autoagent-vscode/./src/utils/AnthropicService.ts","webpack://ki-autoagent-vscode/./src/agents/DocuBotAgent.ts","webpack://ki-autoagent-vscode/./src/core/VSCodeMasterDispatcher.ts","webpack://ki-autoagent-vscode/./src/types/AgentConfiguration.ts","webpack://ki-autoagent-vscode/./src/agents/OpusArbitratorAgent.ts","webpack://ki-autoagent-vscode/./src/extension.ts","webpack://ki-autoagent-vscode/./src/agents/OrchestratorAgent.ts","webpack://ki-autoagent-vscode/external node-commonjs \"child_process\"","webpack://ki-autoagent-vscode/./src/mixins/UnifiedChatMixin.ts","webpack://ki-autoagent-vscode/external commonjs \"vscode\"","webpack://ki-autoagent-vscode/external node-commonjs \"events\"","webpack://ki-autoagent-vscode/./src/core/AgentCommunicationBus.ts","webpack://ki-autoagent-vscode/./src/core/AgentConfigurationManager.ts","webpack://ki-autoagent-vscode/./src/types/Memory.ts","webpack://ki-autoagent-vscode/./src/utils/OpenAIService.ts","webpack://ki-autoagent-vscode/./src/services/ClaudeCodeService.ts","webpack://ki-autoagent-vscode/./src/agents/ResearchAgent.ts","webpack://ki-autoagent-vscode/./src/ui/ChatWidget.ts","webpack://ki-autoagent-vscode/./src/core/SharedContextManager.ts","webpack://ki-autoagent-vscode/./src/utils/WebSearchService.ts","webpack://ki-autoagent-vscode/./src/agents/ReviewerGPTAgent.ts","webpack://ki-autoagent-vscode/./src/core/WorkflowEngine.ts","webpack://ki-autoagent-vscode/./src/ui/MultiAgentChatPanel.ts","webpack://ki-autoagent-vscode/./src/agents/base/ChatAgent.ts","webpack://ki-autoagent-vscode/./src/core/ConversationContextManager.ts","webpack://ki-autoagent-vscode/external node-commonjs \"path\"","webpack://ki-autoagent-vscode/./src/agents/TradeStratAgent.ts","webpack://ki-autoagent-vscode/external node-commonjs \"fs/promises\"","webpack://ki-autoagent-vscode/webpack/bootstrap","webpack://ki-autoagent-vscode/webpack/startup"],"sourcesContent":["/**\n * ArchitectGPT - System Architecture & Design Expert\n * Powered by GPT-4o for system design and architecture planning\n */\nimport * as vscode from 'vscode';\nimport { ChatAgent } from './base/ChatAgent';\nimport { AgentConfig, TaskRequest, TaskResult, WorkflowStep } from '../types';\nimport { VSCodeMasterDispatcher } from '../core/VSCodeMasterDispatcher';\nimport { OpenAIService } from '../utils/OpenAIService';\n\nexport class ArchitectAgent extends ChatAgent {\n    private openAIService: OpenAIService;\n\n    constructor(context: vscode.ExtensionContext, dispatcher: VSCodeMasterDispatcher) {\n        const config: AgentConfig = {\n            participantId: 'ki-autoagent.architect',\n            name: 'architect',\n            fullName: 'ArchitectGPT',\n            description: 'System Architecture & Design Expert powered by GPT-5',\n            model: 'gpt-5-2025-09-12',\n            iconPath: vscode.Uri.joinPath(context.extensionUri, 'media', 'openai-icon.svg'),\n            capabilities: [\n                'System Design',\n                'Architecture Patterns',\n                'Tech Stack Planning',\n                'Scalability Analysis',\n                'Design Documentation'\n            ],\n            commands: [\n                { name: 'design', description: 'Create system architecture and design patterns', handler: 'handleDesignCommand' },\n                { name: 'analyze', description: 'Analyze existing codebase architecture', handler: 'handleAnalyzeCommand' },\n                { name: 'plan', description: 'Create development and deployment plans', handler: 'handlePlanCommand' }\n            ]\n        };\n\n        super(config, context, dispatcher);\n        this.openAIService = new OpenAIService();\n    }\n\n    protected async handleRequest(\n        request: vscode.ChatRequest,\n        context: vscode.ChatContext,\n        stream: vscode.ChatResponseStream,\n        token: vscode.CancellationToken\n    ): Promise<void> {\n        \n        if (!this.validateApiConfig()) {\n            stream.markdown('❌ OpenAI API key not configured. Please set it in VS Code settings.');\n            return;\n        }\n\n        const command = request.command;\n        const prompt = request.prompt;\n\n        this.log(`Processing ${command ? `/${command}` : 'general'} request: ${prompt.substring(0, 100)}...`);\n\n        if (command) {\n            await this.handleCommand(command, prompt, stream, token);\n        } else {\n            // General architecture request\n            await this.handleGeneralArchitectureRequest(prompt, stream, token);\n        }\n    }\n\n    protected async processWorkflowStep(\n        step: WorkflowStep,\n        request: TaskRequest,\n        previousResults: TaskResult[]\n    ): Promise<TaskResult> {\n        \n        const context = await this.getWorkspaceContext();\n        \n        let systemPrompt = '';\n        let userPrompt = '';\n\n        switch (step.id) {\n            case 'analyze':\n                systemPrompt = this.getAnalyzeSystemPrompt();\n                userPrompt = `Analyze the architecture requirements for: ${request.prompt}\\n\\nWorkspace Context:\\n${context}`;\n                break;\n                \n            case 'design':\n                systemPrompt = this.getDesignSystemPrompt();\n                userPrompt = `Create a system architecture design for: ${request.prompt}\\n\\nPrevious Analysis:\\n${this.extractPreviousContent(previousResults)}`;\n                break;\n                \n            default:\n                systemPrompt = this.getGeneralSystemPrompt();\n                userPrompt = `${request.prompt}\\n\\nContext:\\n${context}`;\n        }\n\n        try {\n            const response = await this.openAIService.chat([\n                { role: 'system', content: systemPrompt },\n                { role: 'user', content: userPrompt }\n            ]);\n\n            return {\n                status: 'success',\n                content: response,\n                metadata: { \n                    step: step.id,\n                    agent: 'architect',\n                    model: 'gpt-4o'\n                }\n            };\n\n        } catch (error) {\n            throw new Error(`Failed to process ${step.id}: ${(error as any).message}`);\n        }\n    }\n\n    // Command Handlers\n\n    private async handleDesignCommand(\n        prompt: string,\n        stream: vscode.ChatResponseStream,\n        token: vscode.CancellationToken\n    ): Promise<void> {\n        \n        stream.progress('🏗️ Analyzing requirements and creating system design...');\n        \n        const context = await this.getWorkspaceContext();\n        const systemPrompt = this.getDesignSystemPrompt();\n        const userPrompt = `Create a comprehensive system architecture design for: ${prompt}\\n\\nWorkspace Context:\\n${context}`;\n\n        try {\n            const response = await this.openAIService.chat([\n                { role: 'system', content: systemPrompt },\n                { role: 'user', content: userPrompt }\n            ]);\n\n            stream.markdown(response);\n\n            // Offer to create architecture documentation\n            this.createActionButton(\n                '📄 Create Architecture Document',\n                'ki-autoagent.createFile',\n                ['ARCHITECTURE.md', response],\n                stream\n            );\n\n            // Offer to proceed with implementation planning\n            this.createActionButton(\n                '⚡ Plan Implementation',\n                'ki-autoagent.planImplementation',\n                [prompt, response],\n                stream\n            );\n\n        } catch (error) {\n            stream.markdown(`❌ Error creating design: ${(error as any).message}`);\n        }\n    }\n\n    private async handleAnalyzeCommand(\n        prompt: string,\n        stream: vscode.ChatResponseStream,\n        token: vscode.CancellationToken\n    ): Promise<void> {\n        \n        stream.progress('🔍 Analyzing existing codebase architecture...');\n        \n        const context = await this.getWorkspaceContext();\n        \n        // Get project files for analysis\n        const workspaceFiles = await this.getProjectStructure();\n        \n        const systemPrompt = this.getAnalyzeSystemPrompt();\n        const userPrompt = `Analyze the architecture of this codebase: ${prompt}\\n\\nProject Structure:\\n${workspaceFiles}\\n\\nWorkspace Context:\\n${context}`;\n\n        try {\n            const response = await this.openAIService.chat([\n                { role: 'system', content: systemPrompt },\n                { role: 'user', content: userPrompt }\n            ]);\n\n            stream.markdown(response);\n\n            // Offer architecture improvements\n            this.createActionButton(\n                '🚀 Suggest Improvements',\n                'ki-autoagent.suggestImprovements',\n                [response],\n                stream\n            );\n\n        } catch (error) {\n            stream.markdown(`❌ Error analyzing architecture: ${(error as any).message}`);\n        }\n    }\n\n    private async handlePlanCommand(\n        prompt: string,\n        stream: vscode.ChatResponseStream,\n        token: vscode.CancellationToken\n    ): Promise<void> {\n        \n        stream.progress('📋 Creating development and deployment plans...');\n        \n        const context = await this.getWorkspaceContext();\n        const systemPrompt = this.getPlanSystemPrompt();\n        const userPrompt = `Create a detailed development and deployment plan for: ${prompt}\\n\\nWorkspace Context:\\n${context}`;\n\n        try {\n            const response = await this.openAIService.chat([\n                { role: 'system', content: systemPrompt },\n                { role: 'user', content: userPrompt }\n            ]);\n\n            stream.markdown(response);\n\n            // Offer to create project roadmap\n            this.createActionButton(\n                '🗺️ Create Roadmap',\n                'ki-autoagent.createFile',\n                ['ROADMAP.md', response],\n                stream\n            );\n\n        } catch (error) {\n            stream.markdown(`❌ Error creating plan: ${(error as any).message}`);\n        }\n    }\n\n    private async handleGeneralArchitectureRequest(\n        prompt: string,\n        stream: vscode.ChatResponseStream,\n        token: vscode.CancellationToken\n    ): Promise<void> {\n        \n        stream.progress('🤔 Processing architecture request...');\n        \n        const context = await this.getWorkspaceContext();\n        const systemPrompt = this.getGeneralSystemPrompt();\n        const userPrompt = `${prompt}\\n\\nWorkspace Context:\\n${context}`;\n\n        try {\n            const response = await this.openAIService.chat([\n                { role: 'system', content: systemPrompt },\n                { role: 'user', content: userPrompt }\n            ]);\n\n            stream.markdown(response);\n\n        } catch (error) {\n            stream.markdown(`❌ Error processing request: ${(error as any).message}`);\n        }\n    }\n\n    // System Prompts\n\n    private getGeneralSystemPrompt(): string {\n        return `You are ArchitectGPT, a senior system architect and design expert. You specialize in:\n\n- System architecture design and patterns\n- Technology stack selection and evaluation\n- Scalability and performance planning\n- Microservices and distributed systems\n- Database design and data modeling\n- API design and integration patterns\n- Security architecture\n- DevOps and deployment strategies\n\nAlways provide:\n1. Clear architectural reasoning\n2. Multiple solution options when applicable\n3. Trade-offs and considerations\n4. Implementation guidance\n5. Best practices and patterns\n\nFormat your responses with clear headings, diagrams where helpful (using mermaid syntax), and actionable recommendations.\n\n${this.getSystemContextPrompt()}`;\n    }\n\n    private getDesignSystemPrompt(): string {\n        return `You are ArchitectGPT creating a comprehensive system architecture design. Follow this structure:\n\n## System Architecture Design\n\n### 1. Requirements Analysis\n- Functional requirements\n- Non-functional requirements (performance, scalability, security)\n- Constraints and assumptions\n\n### 2. High-Level Architecture\n- System overview\n- Major components and their responsibilities\n- Data flow and interactions\n\n### 3. Technology Stack\n- Recommended technologies with rationale\n- Alternatives considered\n- Integration points\n\n### 4. Database Design\n- Data model\n- Storage strategy\n- Performance considerations\n\n### 5. API Design\n- Interface specifications\n- Authentication/authorization\n- Rate limiting and caching\n\n### 6. Security Architecture\n- Security measures\n- Authentication/authorization\n- Data protection\n\n### 7. Deployment Architecture\n- Infrastructure requirements\n- Scaling strategy\n- Monitoring and observability\n\n### 8. Implementation Roadmap\n- Development phases\n- Dependencies and milestones\n- Risk mitigation\n\nUse mermaid diagrams where appropriate to illustrate the architecture.\n\n${this.getSystemContextPrompt()}`;\n    }\n\n    private getAnalyzeSystemPrompt(): string {\n        return `You are ArchitectGPT analyzing an existing codebase architecture. Provide:\n\n## Architecture Analysis\n\n### 1. Current Architecture Overview\n- Identify architectural patterns used\n- Component structure and organization\n- Technology stack assessment\n\n### 2. Strengths\n- What's working well\n- Good design decisions\n- Proper patterns implementation\n\n### 3. Areas for Improvement\n- Architectural debt\n- Performance bottlenecks\n- Security concerns\n- Scalability limitations\n\n### 4. Recommendations\n- Prioritized improvement suggestions\n- Refactoring opportunities\n- Technology upgrades\n\n### 5. Next Steps\n- Immediate actions\n- Long-term architectural goals\n- Migration strategies\n\nBe specific and provide actionable insights based on the codebase structure.\n\n${this.getSystemContextPrompt()}`;\n    }\n\n    private getPlanSystemPrompt(): string {\n        return `You are ArchitectGPT creating development and deployment plans. Structure your response as:\n\n## Development & Deployment Plan\n\n### 1. Project Setup\n- Repository structure\n- Development environment\n- Tool and dependency setup\n\n### 2. Development Phases\n- Phase breakdown with deliverables\n- Timeline estimates\n- Resource requirements\n\n### 3. Implementation Strategy\n- Development methodology\n- Code review process\n- Testing strategy\n\n### 4. Deployment Strategy\n- Environment setup (dev, staging, prod)\n- CI/CD pipeline\n- Rollback procedures\n\n### 5. Risk Management\n- Identified risks\n- Mitigation strategies\n- Contingency plans\n\n### 6. Success Metrics\n- KPIs and measurements\n- Monitoring and alerting\n- Performance benchmarks\n\nProvide realistic timelines and clear milestones.\n\n${this.getSystemContextPrompt()}`;\n    }\n\n    // Helper Methods\n\n    private async getProjectStructure(): Promise<string> {\n        try {\n            const files = await vscode.workspace.findFiles('**/*.{py,js,ts,jsx,tsx,json,md}', '**/node_modules/**', 50);\n            return files.map(file => file.fsPath.split('/').slice(-3).join('/')).join('\\n');\n        } catch (error) {\n            return 'Unable to read project structure';\n        }\n    }\n\n    private extractPreviousContent(previousResults: TaskResult[]): string {\n        return previousResults\n            .map(result => result.content)\n            .join('\\n\\n---\\n\\n')\n            .substring(0, 2000); // Limit context size\n    }\n}","/**\n * MemoryManager - Vector-based memory system for agents\n * Provides semantic search, pattern extraction, and learning capabilities\n */\n\nimport { EventEmitter } from 'events';\nimport {\n    MemoryEntry,\n    MemoryType,\n    MemorySearchResult,\n    MemoryPattern,\n    MemoryCluster,\n    MemoryMetadata,\n    MemoryStats,\n    TaskMemory,\n    CodePattern,\n    ArchitecturePattern,\n    LearningEntry\n} from '../types/Memory';\n\nexport interface MemoryOptions {\n    maxMemories?: number;\n    similarityThreshold?: number;\n    clusteringEnabled?: boolean;\n    patternExtractionEnabled?: boolean;\n    autoForget?: boolean;\n    forgetThreshold?: number;\n}\n\nexport class MemoryManager {\n    private memories: Map<string, MemoryEntry> = new Map();\n    private embeddings: Map<string, number[]> = new Map();\n    private patterns: Map<string, MemoryPattern> = new Map();\n    private clusters: MemoryCluster[] = [];\n    private codePatterns: Map<string, CodePattern> = new Map();\n    private architecturePatterns: Map<string, ArchitecturePattern> = new Map();\n    private learningEntries: LearningEntry[] = [];\n    private eventBus: EventEmitter;\n    private options: MemoryOptions;\n    private memoryIndex: Map<MemoryType, Set<string>> = new Map();\n    private agentMemories: Map<string, Set<string>> = new Map();\n\n    constructor(options: MemoryOptions = {}) {\n        this.options = {\n            maxMemories: options.maxMemories || 10000,\n            similarityThreshold: options.similarityThreshold || 0.7,\n            clusteringEnabled: options.clusteringEnabled ?? true,\n            patternExtractionEnabled: options.patternExtractionEnabled ?? true,\n            autoForget: options.autoForget ?? true,\n            forgetThreshold: options.forgetThreshold || 0.3\n        };\n\n        this.eventBus = new EventEmitter();\n        this.initializeIndexes();\n    }\n\n    private initializeIndexes(): void {\n        Object.values(MemoryType).forEach(type => {\n            this.memoryIndex.set(type, new Set());\n        });\n    }\n\n    /**\n     * Store a new memory with automatic embedding generation\n     */\n    public async store(\n        agentId: string,\n        content: any,\n        type: MemoryType,\n        metadata: Partial<MemoryMetadata> = {}\n    ): Promise<string> {\n        const id = this.generateMemoryId();\n\n        // Generate embedding (simplified - in real implementation, use actual embedding model)\n        const embedding = await this.generateEmbedding(content);\n\n        const memory: MemoryEntry = {\n            id,\n            agentId,\n            timestamp: Date.now(),\n            content,\n            embedding,\n            type,\n            metadata: {\n                ...metadata,\n                accessCount: 0,\n                lastAccessed: Date.now(),\n                importance: metadata.importance || this.calculateImportance(content, type)\n            }\n        };\n\n        // Store memory\n        this.memories.set(id, memory);\n        this.embeddings.set(id, embedding);\n\n        // Update indexes\n        this.memoryIndex.get(type)!.add(id);\n        if (!this.agentMemories.has(agentId)) {\n            this.agentMemories.set(agentId, new Set());\n        }\n        this.agentMemories.get(agentId)!.add(id);\n\n        // Auto-forget old memories if limit exceeded\n        if (this.options.autoForget && this.memories.size > this.options.maxMemories!) {\n            await this.forgetOldMemories();\n        }\n\n        // Extract patterns if enabled\n        if (this.options.patternExtractionEnabled) {\n            await this.extractPatterns();\n        }\n\n        // Update clusters if enabled\n        if (this.options.clusteringEnabled) {\n            await this.updateClusters();\n        }\n\n        this.eventBus.emit('memory-stored', memory);\n        return id;\n    }\n\n    /**\n     * Retrieve memories by semantic similarity\n     */\n    public async search(\n        query: any,\n        options: {\n            k?: number;\n            type?: MemoryType;\n            agentId?: string;\n            minSimilarity?: number;\n        } = {}\n    ): Promise<MemorySearchResult[]> {\n        const k = options.k || 10;\n        const minSimilarity = options.minSimilarity || this.options.similarityThreshold!;\n\n        // Generate query embedding\n        const queryEmbedding = await this.generateEmbedding(query);\n\n        // Filter memories based on options\n        let candidateMemories = Array.from(this.memories.values());\n\n        if (options.type) {\n            const typeMemories = this.memoryIndex.get(options.type);\n            if (typeMemories) {\n                candidateMemories = candidateMemories.filter(m => typeMemories.has(m.id));\n            }\n        }\n\n        if (options.agentId) {\n            const agentMems = this.agentMemories.get(options.agentId);\n            if (agentMems) {\n                candidateMemories = candidateMemories.filter(m => agentMems.has(m.id));\n            }\n        }\n\n        // Calculate similarities\n        const results: MemorySearchResult[] = candidateMemories\n            .map(memory => {\n                const similarity = this.cosineSimilarity(\n                    queryEmbedding,\n                    memory.embedding || []\n                );\n                const relevance = this.calculateRelevance(memory, similarity);\n\n                // Update access count\n                memory.metadata.accessCount = (memory.metadata.accessCount || 0) + 1;\n                memory.metadata.lastAccessed = Date.now();\n\n                return {\n                    entry: memory,\n                    similarity,\n                    relevance\n                };\n            })\n            .filter(result => result.similarity >= minSimilarity)\n            .sort((a, b) => b.relevance - a.relevance)\n            .slice(0, k);\n\n        this.eventBus.emit('memory-searched', { query, results });\n        return results;\n    }\n\n    /**\n     * Get memory by ID\n     */\n    public get(id: string): MemoryEntry | undefined {\n        const memory = this.memories.get(id);\n        if (memory) {\n            memory.metadata.accessCount = (memory.metadata.accessCount || 0) + 1;\n            memory.metadata.lastAccessed = Date.now();\n        }\n        return memory;\n    }\n\n    /**\n     * Update an existing memory\n     */\n    public async update(id: string, content: any, metadata?: Partial<MemoryMetadata>): Promise<void> {\n        const memory = this.memories.get(id);\n        if (!memory) {\n            throw new Error(`Memory ${id} not found`);\n        }\n\n        memory.content = content;\n        memory.embedding = await this.generateEmbedding(content);\n        if (metadata) {\n            memory.metadata = { ...memory.metadata, ...metadata };\n        }\n\n        this.embeddings.set(id, memory.embedding);\n        this.eventBus.emit('memory-updated', memory);\n    }\n\n    /**\n     * Delete a memory\n     */\n    public delete(id: string): boolean {\n        const memory = this.memories.get(id);\n        if (!memory) return false;\n\n        // Remove from all indexes\n        this.memories.delete(id);\n        this.embeddings.delete(id);\n        this.memoryIndex.get(memory.type)?.delete(id);\n        this.agentMemories.get(memory.agentId)?.delete(id);\n\n        this.eventBus.emit('memory-deleted', memory);\n        return true;\n    }\n\n    /**\n     * Store a code pattern for reuse\n     */\n    public storeCodePattern(pattern: CodePattern): void {\n        this.codePatterns.set(pattern.id, pattern);\n        this.eventBus.emit('pattern-stored', { type: 'code', pattern });\n    }\n\n    /**\n     * Retrieve relevant code patterns\n     */\n    public async getRelevantCodePatterns(context: string, language?: string): Promise<CodePattern[]> {\n        const patterns = Array.from(this.codePatterns.values());\n\n        // Filter by language if specified\n        let relevant = language\n            ? patterns.filter(p => p.language === language)\n            : patterns;\n\n        // Sort by success rate and recency\n        relevant.sort((a, b) => {\n            const scoreA = a.successRate * (1 / (Date.now() - a.lastUsed));\n            const scoreB = b.successRate * (1 / (Date.now() - b.lastUsed));\n            return scoreB - scoreA;\n        });\n\n        return relevant.slice(0, 5);\n    }\n\n    /**\n     * Store an architecture pattern\n     */\n    public storeArchitecturePattern(pattern: ArchitecturePattern): void {\n        this.architecturePatterns.set(pattern.id, pattern);\n        this.eventBus.emit('pattern-stored', { type: 'architecture', pattern });\n    }\n\n    /**\n     * Get relevant architecture patterns\n     */\n    public getRelevantArchitecturePatterns(useCase: string): ArchitecturePattern[] {\n        return Array.from(this.architecturePatterns.values())\n            .filter(pattern =>\n                pattern.useCases.some(uc =>\n                    uc.toLowerCase().includes(useCase.toLowerCase())\n                )\n            );\n    }\n\n    /**\n     * Store a learning entry\n     */\n    public storeLearning(learning: LearningEntry): void {\n        this.learningEntries.push(learning);\n        this.eventBus.emit('learning-stored', learning);\n    }\n\n    /**\n     * Get learnings relevant to current context\n     */\n    public getRelevantLearnings(context: string, limit: number = 5): LearningEntry[] {\n        // Simple keyword matching - in production, use semantic search\n        const keywords = context.toLowerCase().split(' ');\n\n        return this.learningEntries\n            .filter(entry =>\n                keywords.some(keyword =>\n                    entry.description.toLowerCase().includes(keyword)\n                )\n            )\n            .sort((a, b) => {\n                // Prioritize high impact and recent learnings\n                const scoreA = (a.impact === 'high' ? 3 : a.impact === 'medium' ? 2 : 1) *\n                              (1 / (Date.now() - a.timestamp));\n                const scoreB = (b.impact === 'high' ? 3 : b.impact === 'medium' ? 2 : 1) *\n                              (1 / (Date.now() - b.timestamp));\n                return scoreB - scoreA;\n            })\n            .slice(0, limit);\n    }\n\n    /**\n     * Extract patterns from stored memories\n     */\n    private async extractPatterns(): Promise<void> {\n        // Group similar memories\n        const groups = this.groupSimilarMemories();\n\n        groups.forEach((group, pattern) => {\n            if (group.length >= 3) { // Need at least 3 occurrences to be a pattern\n                const patternEntry: MemoryPattern = {\n                    id: this.generateMemoryId(),\n                    pattern,\n                    frequency: group.length,\n                    examples: group.slice(0, 5),\n                    extractedAt: Date.now()\n                };\n                this.patterns.set(patternEntry.id, patternEntry);\n            }\n        });\n    }\n\n    /**\n     * Group similar memories for pattern extraction\n     */\n    private groupSimilarMemories(): Map<string, MemoryEntry[]> {\n        const groups = new Map<string, MemoryEntry[]>();\n        const processed = new Set<string>();\n\n        this.memories.forEach((memory, id) => {\n            if (processed.has(id)) return;\n\n            const similar = this.findSimilarMemories(memory, 0.8);\n            if (similar.length >= 2) {\n                const pattern = this.extractPatternSignature(memory);\n                groups.set(pattern, [memory, ...similar]);\n                similar.forEach(s => processed.add(s.id));\n            }\n        });\n\n        return groups;\n    }\n\n    /**\n     * Find memories similar to given memory\n     */\n    private findSimilarMemories(memory: MemoryEntry, threshold: number): MemoryEntry[] {\n        const similar: MemoryEntry[] = [];\n\n        this.memories.forEach((other, id) => {\n            if (id === memory.id) return;\n\n            const similarity = this.cosineSimilarity(\n                memory.embedding || [],\n                other.embedding || []\n            );\n\n            if (similarity >= threshold) {\n                similar.push(other);\n            }\n        });\n\n        return similar;\n    }\n\n    /**\n     * Update memory clusters\n     */\n    private async updateClusters(): Promise<void> {\n        // Simple k-means clustering\n        const k = Math.min(10, Math.floor(this.memories.size / 50));\n        if (k < 2) return;\n\n        // Initialize centroids\n        const centroids = this.initializeCentroids(k);\n\n        // Iterate until convergence\n        let iterations = 0;\n        let changed = true;\n\n        while (changed && iterations < 50) {\n            const newClusters: MemoryCluster[] = centroids.map(centroid => ({\n                centroid,\n                members: [],\n                coherence: 0\n            }));\n\n            // Assign memories to nearest centroid\n            this.memories.forEach(memory => {\n                if (!memory.embedding) return;\n\n                let nearestIdx = 0;\n                let maxSim = -1;\n\n                centroids.forEach((centroid, idx) => {\n                    const sim = this.cosineSimilarity(memory.embedding!, centroid);\n                    if (sim > maxSim) {\n                        maxSim = sim;\n                        nearestIdx = idx;\n                    }\n                });\n\n                newClusters[nearestIdx].members.push(memory);\n            });\n\n            // Update centroids\n            changed = false;\n            newClusters.forEach((cluster, idx) => {\n                if (cluster.members.length > 0) {\n                    const newCentroid = this.calculateCentroid(cluster.members);\n                    if (!this.vectorsEqual(centroids[idx], newCentroid)) {\n                        centroids[idx] = newCentroid;\n                        changed = true;\n                    }\n                }\n            });\n\n            this.clusters = newClusters;\n            iterations++;\n        }\n\n        // Calculate cluster coherence\n        this.clusters.forEach(cluster => {\n            cluster.coherence = this.calculateClusterCoherence(cluster);\n        });\n\n        this.eventBus.emit('clusters-updated', this.clusters);\n    }\n\n    /**\n     * Forget old, unimportant memories\n     */\n    private async forgetOldMemories(): Promise<void> {\n        const memoriesToForget: string[] = [];\n        const now = Date.now();\n        const oneWeek = 7 * 24 * 60 * 60 * 1000;\n\n        this.memories.forEach((memory, id) => {\n            // Calculate forgetting score\n            const age = now - memory.timestamp;\n            const accessFrequency = (memory.metadata.accessCount || 0) / (age / oneWeek);\n            const importance = memory.metadata.importance || 0.5;\n\n            const retentionScore = (accessFrequency * 0.4) + (importance * 0.6);\n\n            if (retentionScore < this.options.forgetThreshold!) {\n                memoriesToForget.push(id);\n            }\n        });\n\n        // Keep at least 50% of max capacity\n        const maxToForget = Math.floor(this.memories.size - (this.options.maxMemories! * 0.5));\n        memoriesToForget.slice(0, maxToForget).forEach(id => {\n            this.delete(id);\n        });\n\n        if (memoriesToForget.length > 0) {\n            this.eventBus.emit('memories-forgotten', memoriesToForget.length);\n        }\n    }\n\n    /**\n     * Generate embedding for content (simplified - use real embedding model in production)\n     */\n    private async generateEmbedding(content: any): Promise<number[]> {\n        // Simplified embedding generation\n        // In production, use OpenAI embeddings or similar\n        const text = JSON.stringify(content).toLowerCase();\n        const embedding = new Array(384).fill(0);\n\n        // Simple hash-based embedding\n        for (let i = 0; i < text.length; i++) {\n            const idx = (text.charCodeAt(i) * (i + 1)) % 384;\n            embedding[idx] += 1;\n        }\n\n        // Normalize\n        const magnitude = Math.sqrt(embedding.reduce((sum, val) => sum + val * val, 0));\n        return embedding.map(val => val / (magnitude || 1));\n    }\n\n    /**\n     * Calculate cosine similarity between two vectors\n     */\n    private cosineSimilarity(a: number[], b: number[]): number {\n        if (a.length !== b.length || a.length === 0) return 0;\n\n        let dotProduct = 0;\n        let magnitudeA = 0;\n        let magnitudeB = 0;\n\n        for (let i = 0; i < a.length; i++) {\n            dotProduct += a[i] * b[i];\n            magnitudeA += a[i] * a[i];\n            magnitudeB += b[i] * b[i];\n        }\n\n        magnitudeA = Math.sqrt(magnitudeA);\n        magnitudeB = Math.sqrt(magnitudeB);\n\n        if (magnitudeA === 0 || magnitudeB === 0) return 0;\n        return dotProduct / (magnitudeA * magnitudeB);\n    }\n\n    /**\n     * Calculate relevance score for a memory\n     */\n    private calculateRelevance(memory: MemoryEntry, similarity: number): number {\n        const recency = 1 / (1 + (Date.now() - memory.timestamp) / (24 * 60 * 60 * 1000));\n        const importance = memory.metadata.importance || 0.5;\n        const accessFrequency = Math.min(1, (memory.metadata.accessCount || 0) / 100);\n\n        return (similarity * 0.4) + (recency * 0.2) + (importance * 0.3) + (accessFrequency * 0.1);\n    }\n\n    /**\n     * Calculate importance of content\n     */\n    private calculateImportance(content: any, type: MemoryType): number {\n        // Simple heuristic - in production, use more sophisticated analysis\n        if (type === MemoryType.PROCEDURAL) return 0.8;\n        if (type === MemoryType.SEMANTIC) return 0.7;\n        if (type === MemoryType.EPISODIC) return 0.5;\n        return 0.3;\n    }\n\n    /**\n     * Extract pattern signature from memory\n     */\n    private extractPatternSignature(memory: MemoryEntry): string {\n        // Simplified pattern extraction\n        const content = JSON.stringify(memory.content);\n        return content.substring(0, 50);\n    }\n\n    /**\n     * Initialize cluster centroids\n     */\n    private initializeCentroids(k: number): number[][] {\n        const centroids: number[][] = [];\n        const memories = Array.from(this.memories.values()).filter(m => m.embedding);\n\n        for (let i = 0; i < k && i < memories.length; i++) {\n            centroids.push([...memories[i].embedding!]);\n        }\n\n        return centroids;\n    }\n\n    /**\n     * Calculate centroid of cluster members\n     */\n    private calculateCentroid(members: MemoryEntry[]): number[] {\n        if (members.length === 0 || !members[0].embedding) return [];\n\n        const dim = members[0].embedding.length;\n        const centroid = new Array(dim).fill(0);\n\n        members.forEach(member => {\n            if (member.embedding) {\n                member.embedding.forEach((val, idx) => {\n                    centroid[idx] += val;\n                });\n            }\n        });\n\n        return centroid.map(val => val / members.length);\n    }\n\n    /**\n     * Calculate cluster coherence\n     */\n    private calculateClusterCoherence(cluster: MemoryCluster): number {\n        if (cluster.members.length < 2) return 1;\n\n        let totalSimilarity = 0;\n        let comparisons = 0;\n\n        for (let i = 0; i < cluster.members.length; i++) {\n            for (let j = i + 1; j < cluster.members.length; j++) {\n                if (cluster.members[i].embedding && cluster.members[j].embedding) {\n                    totalSimilarity += this.cosineSimilarity(\n                        cluster.members[i].embedding!,\n                        cluster.members[j].embedding!\n                    );\n                    comparisons++;\n                }\n            }\n        }\n\n        return comparisons > 0 ? totalSimilarity / comparisons : 0;\n    }\n\n    /**\n     * Check if two vectors are equal\n     */\n    private vectorsEqual(a: number[], b: number[]): boolean {\n        if (a.length !== b.length) return false;\n        return a.every((val, idx) => Math.abs(val - b[idx]) < 0.001);\n    }\n\n    /**\n     * Generate unique memory ID\n     */\n    private generateMemoryId(): string {\n        return `mem_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    }\n\n    /**\n     * Get memory statistics\n     */\n    public getStats(): MemoryStats {\n        const stats: MemoryStats = {\n            totalMemories: this.memories.size,\n            byType: new Map(),\n            byAgent: new Map(),\n            averageAccessCount: 0,\n            mostAccessedMemories: [],\n            memoryGrowthRate: 0,\n            patternCount: this.patterns.size,\n            clusterCount: this.clusters.length\n        };\n\n        // Count by type\n        this.memoryIndex.forEach((ids, type) => {\n            stats.byType.set(type, ids.size);\n        });\n\n        // Count by agent\n        this.agentMemories.forEach((ids, agent) => {\n            stats.byAgent.set(agent, ids.size);\n        });\n\n        // Calculate average access count and find most accessed\n        let totalAccess = 0;\n        const memoriesByAccess = Array.from(this.memories.values())\n            .sort((a, b) => (b.metadata.accessCount || 0) - (a.metadata.accessCount || 0));\n\n        memoriesByAccess.forEach(memory => {\n            totalAccess += memory.metadata.accessCount || 0;\n        });\n\n        stats.averageAccessCount = totalAccess / (this.memories.size || 1);\n        stats.mostAccessedMemories = memoriesByAccess.slice(0, 10);\n\n        return stats;\n    }\n\n    /**\n     * Export memories for persistence\n     */\n    public export(): string {\n        const exportData = {\n            memories: Array.from(this.memories.entries()),\n            patterns: Array.from(this.patterns.entries()),\n            codePatterns: Array.from(this.codePatterns.entries()),\n            architecturePatterns: Array.from(this.architecturePatterns.entries()),\n            learningEntries: this.learningEntries,\n            timestamp: Date.now()\n        };\n\n        return JSON.stringify(exportData);\n    }\n\n    /**\n     * Import memories from persistence\n     */\n    public import(data: string): void {\n        const importData = JSON.parse(data);\n\n        // Clear existing data\n        this.memories.clear();\n        this.patterns.clear();\n        this.codePatterns.clear();\n        this.architecturePatterns.clear();\n        this.learningEntries = [];\n\n        // Import memories\n        importData.memories.forEach(([id, memory]: [string, MemoryEntry]) => {\n            this.memories.set(id, memory);\n            if (memory.embedding) {\n                this.embeddings.set(id, memory.embedding);\n            }\n        });\n\n        // Import patterns\n        importData.patterns.forEach(([id, pattern]: [string, MemoryPattern]) => {\n            this.patterns.set(id, pattern);\n        });\n\n        // Import code patterns\n        importData.codePatterns.forEach(([id, pattern]: [string, CodePattern]) => {\n            this.codePatterns.set(id, pattern);\n        });\n\n        // Import architecture patterns\n        importData.architecturePatterns.forEach(([id, pattern]: [string, ArchitecturePattern]) => {\n            this.architecturePatterns.set(id, pattern);\n        });\n\n        // Import learning entries\n        this.learningEntries = importData.learningEntries || [];\n\n        // Rebuild indexes\n        this.rebuildIndexes();\n\n        this.eventBus.emit('memories-imported', {\n            count: this.memories.size,\n            timestamp: importData.timestamp\n        });\n    }\n\n    /**\n     * Rebuild indexes after import\n     */\n    private rebuildIndexes(): void {\n        this.memoryIndex.clear();\n        this.agentMemories.clear();\n        this.initializeIndexes();\n\n        this.memories.forEach(memory => {\n            this.memoryIndex.get(memory.type)?.add(memory.id);\n\n            if (!this.agentMemories.has(memory.agentId)) {\n                this.agentMemories.set(memory.agentId, new Set());\n            }\n            this.agentMemories.get(memory.agentId)?.add(memory.id);\n        });\n    }\n}","/**\n * CodeSmithClaude - Senior Python/Web Developer\n * Powered by Claude 3.5 Sonnet for code implementation and optimization\n */\nimport * as vscode from 'vscode';\nimport { ChatAgent } from './base/ChatAgent';\nimport { AgentConfig, TaskRequest, TaskResult, WorkflowStep } from '../types';\nimport { VSCodeMasterDispatcher } from '../core/VSCodeMasterDispatcher';\nimport { AnthropicService } from '../utils/AnthropicService';\nimport { getClaudeCodeService, ClaudeCodeService } from '../services/ClaudeCodeService';\n\nexport class CodeSmithAgent extends ChatAgent {\n    private anthropicService: AnthropicService;\n    private claudeCodeService: ClaudeCodeService;\n\n    constructor(context: vscode.ExtensionContext, dispatcher: VSCodeMasterDispatcher) {\n        const config: AgentConfig = {\n            participantId: 'ki-autoagent.codesmith',\n            name: 'codesmith',\n            fullName: 'CodeSmithClaude',\n            description: 'Senior Python/Web Developer powered by Claude 4.1 Sonnet',\n            model: 'claude-4.1-sonnet-20250920',\n            iconPath: vscode.Uri.joinPath(context.extensionUri, 'media', 'claude-icon.svg'),\n            capabilities: [\n                'Python Development',\n                'Web Development',\n                'API Implementation',\n                'Testing & TDD',\n                'Code Optimization',\n                'Framework Integration'\n            ],\n            commands: [\n                { name: 'implement', description: 'Implement code based on specifications', handler: 'handleImplementCommand' },\n                { name: 'fix', description: 'Fix bugs and issues in code', handler: 'handleFixCommand' },\n                { name: 'debug', description: 'Debug and resolve issues', handler: 'handleDebugCommand' },\n                { name: 'optimize', description: 'Optimize existing code for performance', handler: 'handleOptimizeCommand' },\n                { name: 'refactor', description: 'Refactor code for better structure', handler: 'handleRefactorCommand' },\n                { name: 'modernize', description: 'Modernize legacy code', handler: 'handleModernizeCommand' },\n                { name: 'test', description: 'Generate comprehensive test suites', handler: 'handleTestCommand' }\n            ]\n        };\n\n        super(config, context, dispatcher);\n        this.anthropicService = new AnthropicService();\n        this.claudeCodeService = getClaudeCodeService();\n    }\n\n    protected async handleRequest(\n        request: vscode.ChatRequest,\n        context: vscode.ChatContext,\n        stream: vscode.ChatResponseStream,\n        token: vscode.CancellationToken\n    ): Promise<void> {\n        \n        const validationResult = await this.validateServiceConfig(stream);\n        if (!validationResult) {\n            return;\n        }\n\n        const command = request.command;\n        const prompt = request.prompt;\n\n        this.log(`Processing ${command ? `/${command}` : 'general'} request: ${prompt.substring(0, 100)}...`);\n\n        if (command) {\n            await this.handleCommand(command, prompt, stream, token);\n        } else {\n            await this.handleGeneralImplementationRequest(prompt, stream, token);\n        }\n    }\n\n    // Override executeStep to use our custom implementation\n    public async executeStep(\n        step: WorkflowStep,\n        request: TaskRequest & { onPartialResponse?: (content: string) => void },\n        previousResults: TaskResult[]\n    ): Promise<TaskResult> {\n        this.showDebug(`ExecuteStep called`, { \n            step: step.id, \n            hasStreamingCallback: !!request.onPartialResponse \n        });\n        return await this.processWorkflowStep(step, request, previousResults);\n    }\n\n    protected async processWorkflowStep(\n        step: WorkflowStep,\n        request: TaskRequest & { onPartialResponse?: (content: string) => void; globalContext?: string },\n        previousResults: TaskResult[]\n    ): Promise<TaskResult> {\n        \n        const context = await this.getWorkspaceContext();\n        \n        // Build conversation history from previous results\n        let conversationHistory = '';\n        \n        // Include global context if available\n        if (request.globalContext) {\n            conversationHistory += request.globalContext;\n        }\n        \n        // Add immediate previous results for this workflow\n        if (previousResults.length > 0) {\n            conversationHistory += '\\n\\n## Current Workflow Progress:\\n';\n            previousResults.forEach((result, index) => {\n                const agentName = result.metadata?.agent || `Agent ${index + 1}`;\n                const stepId = result.metadata?.step || 'unknown';\n                conversationHistory += `\\n### ${agentName} (${stepId}):\\n${result.content}\\n`;\n            });\n        }\n        \n        let systemPrompt = '';\n        let userPrompt = '';\n\n        switch (step.id) {\n            case 'implement':\n                systemPrompt = this.getImplementationSystemPrompt();\n                userPrompt = `Implement the following: ${request.prompt}\\n\\nWorkspace Context:\\n${context}${conversationHistory}`;\n                break;\n                \n            case 'test':\n                systemPrompt = this.getTestingSystemPrompt();\n                userPrompt = `Create comprehensive tests for: ${request.prompt}\\n\\nPrevious Implementation:\\n${this.extractPreviousContent(previousResults)}`;\n                break;\n                \n            case 'optimize':\n                systemPrompt = this.getOptimizationSystemPrompt();\n                userPrompt = `Optimize this implementation: ${request.prompt}\\n\\nContext:\\n${context}${conversationHistory}`;\n                break;\n                \n            default:\n                systemPrompt = this.getGeneralSystemPrompt();\n                userPrompt = `${request.prompt}\\n\\nContext:\\n${context}${conversationHistory}`;\n        }\n\n        try {\n            // Pass streaming callback if provided\n            const claudeService = await this.getClaudeService(request.onPartialResponse);\n            const response = await claudeService.chat([\n                { role: 'system', content: systemPrompt },\n                { role: 'user', content: userPrompt }\n            ]);\n\n            // Extract content string from response object\n            const responseContent = typeof response === 'string' \n                ? response \n                : (response as any).content || '';\n\n            // Extract metadata from response if available\n            const responseMetadata = typeof response === 'object' && response !== null\n                ? (response as any).metadata\n                : {};\n\n            this.showDebug('Response received', {\n                contentLength: responseContent.length,\n                metadata: responseMetadata\n            });\n\n            return {\n                status: 'success',\n                content: responseContent,\n                metadata: { \n                    step: step.id,\n                    agent: 'codesmith',\n                    model: 'claude-3.5-sonnet',\n                    ...responseMetadata\n                }\n            };\n\n        } catch (error) {\n            throw new Error(`Failed to process ${step.id}: ${(error as any).message}`);\n        }\n    }\n\n    // Command Handlers\n\n    private async handleImplementCommand(\n        prompt: string,\n        stream: vscode.ChatResponseStream,\n        token: vscode.CancellationToken\n    ): Promise<void> {\n        \n        stream.progress('⚡ Implementing your requirements...');\n        \n        const context = await this.getWorkspaceContext();\n        const systemPrompt = this.getImplementationSystemPrompt();\n        const userPrompt = `Implement the following requirements: ${prompt}\\n\\nWorkspace Context:\\n${context}`;\n\n        try {\n            const claudeService = await this.getClaudeService();\n            const response = await claudeService.chat([\n                { role: 'system', content: systemPrompt },\n                { role: 'user', content: userPrompt }\n            ]);\n\n            // Extract content string from response object\n            const responseContent = typeof response === 'string' \n                ? response \n                : (response as any).content || '';\n            stream.markdown(responseContent);\n\n            // Extract code blocks for file creation\n            const codeBlocks = this.extractCodeBlocks(responseContent);\n            \n            for (const block of codeBlocks) {\n                if (block.filename) {\n                    this.createActionButton(\n                        `📄 Create ${block.filename}`,\n                        'ki-autoagent.createFile',\n                        [block.filename, block.code],\n                        stream\n                    );\n                }\n            }\n\n            // Offer to create tests\n            this.createActionButton(\n                '🧪 Generate Tests',\n                'ki-autoagent.generateTests',\n                [prompt, response],\n                stream\n            );\n\n        } catch (error) {\n            stream.markdown(`❌ Error during implementation: ${(error as any).message}`);\n        }\n    }\n\n    private async handleOptimizeCommand(\n        prompt: string,\n        stream: vscode.ChatResponseStream,\n        token: vscode.CancellationToken\n    ): Promise<void> {\n        \n        stream.progress('🚀 Optimizing code for performance...');\n        \n        const context = await this.getWorkspaceContext();\n        const systemPrompt = this.getOptimizationSystemPrompt();\n        \n        // Include current file content if available\n        let codeToOptimize = '';\n        if (context.includes('Selected text:')) {\n            codeToOptimize = context;\n        } else if (vscode.window.activeTextEditor) {\n            const document = vscode.window.activeTextEditor.document;\n            codeToOptimize = `Current file: ${document.fileName}\\n\\`\\`\\`${document.languageId}\\n${document.getText()}\\n\\`\\`\\``;\n        }\n        \n        const userPrompt = `Optimize the following code: ${prompt}\\n\\nCode to optimize:\\n${codeToOptimize}`;\n\n        try {\n            const claudeService = await this.getClaudeService();\n            const response = await claudeService.chat([\n                { role: 'system', content: systemPrompt },\n                { role: 'user', content: userPrompt }\n            ]);\n\n            // Extract content string from response object\n            const responseContent = typeof response === 'string' \n                ? response \n                : (response as any).content || '';\n            stream.markdown(responseContent);\n\n            // Offer to apply optimizations\n            const optimizedCode = this.extractMainCodeBlock(responseContent);\n            if (optimizedCode) {\n                this.createActionButton(\n                    '✨ Apply Optimization',\n                    'ki-autoagent.insertAtCursor',\n                    [optimizedCode],\n                    stream\n                );\n            }\n\n        } catch (error) {\n            stream.markdown(`❌ Error during optimization: ${(error as any).message}`);\n        }\n    }\n\n    private async handleTestCommand(\n        prompt: string,\n        stream: vscode.ChatResponseStream,\n        token: vscode.CancellationToken\n    ): Promise<void> {\n        \n        stream.progress('🧪 Generating comprehensive test suite...');\n        \n        const context = await this.getWorkspaceContext();\n        const systemPrompt = this.getTestingSystemPrompt();\n        const userPrompt = `Generate comprehensive tests for: ${prompt}\\n\\nWorkspace Context:\\n${context}`;\n\n        try {\n            const claudeService = await this.getClaudeService();\n            const response = await claudeService.chat([\n                { role: 'system', content: systemPrompt },\n                { role: 'user', content: userPrompt }\n            ]);\n\n            // Extract content string from response object\n            const responseContent = typeof response === 'string' \n                ? response \n                : (response as any).content || '';\n            stream.markdown(responseContent);\n\n            // Extract test files for creation\n            const testFiles = this.extractTestFiles(responseContent);\n            \n            for (const testFile of testFiles) {\n                this.createActionButton(\n                    `🧪 Create ${testFile.filename}`,\n                    'ki-autoagent.createFile',\n                    [testFile.filename, testFile.code],\n                    stream\n                );\n            }\n\n            // Offer to run tests\n            this.createActionButton(\n                '▶️ Run Tests',\n                'ki-autoagent.runTests',\n                [],\n                stream\n            );\n\n        } catch (error) {\n            stream.markdown(`❌ Error generating tests: ${(error as any).message}`);\n        }\n    }\n\n    private async handleFixCommand(\n        prompt: string,\n        stream: vscode.ChatResponseStream,\n        token: vscode.CancellationToken\n    ): Promise<void> {\n\n        stream.progress('🔧 Fixing bugs and issues...');\n\n        const context = await this.getWorkspaceContext();\n        const systemPrompt = `You are CodeSmithClaude, an expert bug fixer. Your task is to:\n1. Identify the root cause of the bug\n2. Implement a robust fix\n3. Ensure no new bugs are introduced\n4. Add error handling where needed\n5. Test the fix thoroughly\n\n${this.getSystemContextPrompt()}`;\n\n        const userPrompt = `Fix the following issue: ${prompt}\\n\\nWorkspace Context:\\n${context}`;\n\n        try {\n            const claudeService = await this.getClaudeService();\n            const response = await claudeService.chat([\n                { role: 'system', content: systemPrompt },\n                { role: 'user', content: userPrompt }\n            ]);\n\n            const responseContent = typeof response === 'string'\n                ? response\n                : (response as any).content || '';\n            stream.markdown(responseContent);\n\n        } catch (error) {\n            stream.markdown(`❌ Error during bug fix: ${(error as any).message}`);\n        }\n    }\n\n    private async handleDebugCommand(\n        prompt: string,\n        stream: vscode.ChatResponseStream,\n        token: vscode.CancellationToken\n    ): Promise<void> {\n\n        stream.progress('🐛 Debugging and analyzing issue...');\n\n        const context = await this.getWorkspaceContext();\n        const systemPrompt = `You are CodeSmithClaude, an expert debugger. Your task is to:\n1. Analyze error messages and stack traces\n2. Identify the root cause\n3. Add debug logging to trace the issue\n4. Provide step-by-step debugging instructions\n5. Suggest a permanent fix\n\n${this.getSystemContextPrompt()}`;\n\n        const userPrompt = `Debug this issue: ${prompt}\\n\\nWorkspace Context:\\n${context}`;\n\n        try {\n            const claudeService = await this.getClaudeService();\n            const response = await claudeService.chat([\n                { role: 'system', content: systemPrompt },\n                { role: 'user', content: userPrompt }\n            ]);\n\n            const responseContent = typeof response === 'string'\n                ? response\n                : (response as any).content || '';\n            stream.markdown(responseContent);\n\n        } catch (error) {\n            stream.markdown(`❌ Error during debugging: ${(error as any).message}`);\n        }\n    }\n\n    private async handleRefactorCommand(\n        prompt: string,\n        stream: vscode.ChatResponseStream,\n        token: vscode.CancellationToken\n    ): Promise<void> {\n\n        stream.progress('♻️ Refactoring code for better structure...');\n\n        const context = await this.getWorkspaceContext();\n        const systemPrompt = `You are CodeSmithClaude, a refactoring expert. Your task is to:\n1. Improve code structure and organization\n2. Apply design patterns where appropriate\n3. Reduce code duplication (DRY principle)\n4. Improve naming and readability\n5. Maintain functionality while improving quality\n\n${this.getSystemContextPrompt()}`;\n\n        const userPrompt = `Refactor the following: ${prompt}\\n\\nWorkspace Context:\\n${context}`;\n\n        try {\n            const claudeService = await this.getClaudeService();\n            const response = await claudeService.chat([\n                { role: 'system', content: systemPrompt },\n                { role: 'user', content: userPrompt }\n            ]);\n\n            const responseContent = typeof response === 'string'\n                ? response\n                : (response as any).content || '';\n            stream.markdown(responseContent);\n\n        } catch (error) {\n            stream.markdown(`❌ Error during refactoring: ${(error as any).message}`);\n        }\n    }\n\n    private async handleModernizeCommand(\n        prompt: string,\n        stream: vscode.ChatResponseStream,\n        token: vscode.CancellationToken\n    ): Promise<void> {\n\n        stream.progress('🚀 Modernizing legacy code...');\n\n        const context = await this.getWorkspaceContext();\n        const systemPrompt = `You are CodeSmithClaude, a code modernization expert. Your task is to:\n1. Update deprecated APIs and methods\n2. Use modern language features (async/await, arrow functions, etc.)\n3. Update to latest framework versions\n4. Improve TypeScript types\n5. Add modern tooling support\n\n${this.getSystemContextPrompt()}`;\n\n        const userPrompt = `Modernize the following code: ${prompt}\\n\\nWorkspace Context:\\n${context}`;\n\n        try {\n            const claudeService = await this.getClaudeService();\n            const response = await claudeService.chat([\n                { role: 'system', content: systemPrompt },\n                { role: 'user', content: userPrompt }\n            ]);\n\n            const responseContent = typeof response === 'string'\n                ? response\n                : (response as any).content || '';\n            stream.markdown(responseContent);\n\n        } catch (error) {\n            stream.markdown(`❌ Error during modernization: ${(error as any).message}`);\n        }\n    }\n\n    private async handleGeneralImplementationRequest(\n        prompt: string,\n        stream: vscode.ChatResponseStream,\n        token: vscode.CancellationToken\n    ): Promise<void> {\n        \n        stream.progress('💻 Processing implementation request...');\n        \n        const context = await this.getWorkspaceContext();\n        const systemPrompt = this.getGeneralSystemPrompt();\n        const userPrompt = `${prompt}\\n\\nWorkspace Context:\\n${context}`;\n\n        try {\n            const claudeService = await this.getClaudeService();\n            const response = await claudeService.chat([\n                { role: 'system', content: systemPrompt },\n                { role: 'user', content: userPrompt }\n            ]);\n\n            // Extract content string from response object\n            const responseContent = typeof response === 'string' \n                ? response \n                : (response as any).content || '';\n            stream.markdown(responseContent);\n\n            // Auto-detect and offer file creation\n            const codeBlocks = this.extractCodeBlocks(responseContent);\n            for (const block of codeBlocks) {\n                if (block.filename) {\n                    this.createActionButton(\n                        `📄 Create ${block.filename}`,\n                        'ki-autoagent.createFile',\n                        [block.filename, block.code],\n                        stream\n                    );\n                }\n            }\n\n        } catch (error) {\n            stream.markdown(`❌ Error processing request: ${(error as any).message}`);\n        }\n    }\n\n    // System Prompts\n\n    private getGeneralSystemPrompt(): string {\n        return `You are CodeSmithClaude, a senior Python and web developer with expertise in:\n\n- Python development (Django, FastAPI, Flask, Streamlit)\n- Web development (React, TypeScript, JavaScript)\n- API design and implementation\n- Database design and ORM usage\n- Testing strategies (pytest, unittest, Jest)\n- Code optimization and performance\n- Modern development practices\n\nAlways provide:\n1. Clean, readable, and well-documented code\n2. Proper error handling and validation\n3. Performance considerations\n4. Security best practices\n5. Testing recommendations\n\nFormat your responses with clear explanations and working code examples.\n\n${this.getSystemContextPrompt()}`;\n    }\n\n    private getImplementationSystemPrompt(): string {\n        return `You are CodeSmithClaude implementing code based on specifications. Follow this structure:\n\n## Implementation Plan\n\n### 1. Analysis\n- Break down requirements\n- Identify components needed\n- Choose appropriate patterns\n\n### 2. Core Implementation\n- Main functionality with proper structure\n- Error handling and validation\n- Clear documentation\n\n### 3. Integration Points\n- How this connects to existing code\n- Dependencies and imports\n- Configuration requirements\n\n### 4. Usage Examples\n- How to use the implemented code\n- Example scenarios\n- Common patterns\n\n### 5. Next Steps\n- Testing recommendations\n- Potential improvements\n- Deployment considerations\n\nProvide complete, working code with filenames when appropriate. Focus on clean, maintainable solutions.\n\n${this.getSystemContextPrompt()}`;\n    }\n\n    private getOptimizationSystemPrompt(): string {\n        return `You are CodeSmithClaude optimizing code for performance. Follow this approach:\n\n## Code Optimization Analysis\n\n### 1. Current Code Analysis\n- Identify performance bottlenecks\n- Analyze complexity and efficiency\n- Spot potential issues\n\n### 2. Optimization Strategies\n- Algorithm improvements\n- Data structure optimizations\n- Caching opportunities\n- Memory efficiency\n\n### 3. Optimized Implementation\n- Improved code with explanations\n- Performance comparisons\n- Benchmark suggestions\n\n### 4. Trade-offs\n- Performance vs readability\n- Memory vs speed\n- Complexity considerations\n\nAlways maintain code readability while improving performance. Explain your optimization choices.\n\n${this.getSystemContextPrompt()}`;\n    }\n\n    private getTestingSystemPrompt(): string {\n        return `You are CodeSmithClaude creating comprehensive test suites. Structure your tests as:\n\n## Test Suite Design\n\n### 1. Test Strategy\n- Test types needed (unit, integration, e2e)\n- Coverage goals\n- Testing framework choice\n\n### 2. Unit Tests\n- Test individual functions/methods\n- Edge cases and error conditions\n- Mocking strategies\n\n### 3. Integration Tests\n- Component interactions\n- API endpoint testing\n- Database integration\n\n### 4. Test Utilities\n- Fixtures and test data\n- Helper functions\n- Setup/teardown\n\n### 5. Test Configuration\n- Test runner setup\n- CI/CD integration\n- Coverage reporting\n\nProvide complete, runnable tests with clear assertions and good coverage.\n\n${this.getSystemContextPrompt()}`;\n    }\n\n    // Service Configuration Methods\n\n    private async validateServiceConfig(stream?: vscode.ChatResponseStream): Promise<boolean> {\n        const config = vscode.workspace.getConfiguration('kiAutoAgent');\n        const serviceMode = config.get<string>('claude.serviceMode', 'claude-code');\n\n        if (serviceMode === 'api') {\n            if (!config.get<string>('anthropic.apiKey')) {\n                if (stream) {\n                    stream.markdown('❌ **Anthropic API key not configured**\\n\\nPlease set your API key in VS Code settings:\\n- Go to Settings\\n- Search for \"KI AutoAgent\"\\n- Set your Anthropic API key');\n                }\n                return false;\n            }\n        } else if (serviceMode === 'claude-code') {\n            const isClaudeCodeAvailable = await this.claudeCodeService.isAvailable();\n            if (!isClaudeCodeAvailable) {\n                if (stream) {\n                    stream.markdown(`❌ **Claude Code CLI not available**\\n\\n**To install:**\\n\\`\\`\\`bash\\nnpm install -g @anthropic-ai/claude-code\\n\\`\\`\\`\\n\\nOr configure your Anthropic API key in VS Code settings.`);\n                }\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    private async getClaudeService(onPartialResponse?: (content: string) => void): Promise<{ chat: (messages: any[]) => Promise<any> }> {\n        const config = vscode.workspace.getConfiguration('kiAutoAgent');\n        const serviceMode = config.get<string>('claude.serviceMode', 'claude-code');\n\n        this.showDebug('Service configuration', {\n            serviceMode,\n            hasStreamingCallback: !!onPartialResponse\n        });\n\n        if (serviceMode === 'claude-code') {\n            const isAvailable = await this.claudeCodeService.isAvailable();\n            if (isAvailable) {\n                this.showInfo('Using Claude Code CLI');\n                return {\n                    chat: async (messages: any[]) => {\n                        // Extract the main user message content\n                        const userMessage = messages.find(m => m.role === 'user')?.content || '';\n                        const systemMessage = messages.find(m => m.role === 'system')?.content || '';\n                        const fullPrompt = systemMessage ? `${systemMessage}\\n\\n${userMessage}` : userMessage;\n                        \n                        // Use streaming if callback provided\n                        if (onPartialResponse) {\n                            this.showDebug('Using streaming message');\n                            const response = await this.claudeCodeService.sendStreamingMessage(fullPrompt, {\n                                model: 'sonnet',\n                                temperature: 0.7,\n                                onPartialResponse: onPartialResponse\n                            });\n                            return response;\n                        } else {\n                            const response = await this.claudeCodeService.sendMessage(fullPrompt, {\n                                model: 'sonnet',\n                                temperature: 0.7\n                            });\n                            return response.content;\n                        }\n                    }\n                };\n            } else {\n                this.showFallbackMode('Claude Code CLI not available', 'Using Anthropic API');\n            }\n        }\n        \n        // Fall back to Anthropic API\n        this.showInfo('Using Anthropic API');\n        return {\n            chat: async (messages: any[]) => {\n                return await this.anthropicService.chat(messages);\n            }\n        };\n    }\n\n    // Helper Methods\n\n    private extractCodeBlocks(content: string): Array<{filename?: string, language: string, code: string}> {\n        const codeBlockRegex = /```(\\w+)?\\s*(?:\\/\\/\\s*(.+\\.[\\w]+))?\\n([\\s\\S]*?)```/g;\n        const blocks: Array<{filename?: string, language: string, code: string}> = [];\n        \n        let match;\n        while ((match = codeBlockRegex.exec(content)) !== null) {\n            const language = match[1] || 'text';\n            const filename = match[2] || this.inferFilename(language, match[3]);\n            const code = match[3];\n            \n            blocks.push({ filename, language, code });\n        }\n        \n        return blocks;\n    }\n\n    private extractTestFiles(content: string): Array<{filename: string, code: string}> {\n        const blocks = this.extractCodeBlocks(content);\n        return blocks\n            .filter(block => \n                block.filename && \n                (block.filename.includes('test') || block.filename.includes('spec'))\n            )\n            .map(block => ({ filename: block.filename!, code: block.code }));\n    }\n\n    private extractMainCodeBlock(content: string): string {\n        const blocks = this.extractCodeBlocks(content);\n        return blocks.length > 0 ? blocks[0].code : '';\n    }\n\n    private inferFilename(language: string, code: string): string {\n        // Try to infer filename from code content\n        if (language === 'python') {\n            const classMatch = code.match(/class\\s+(\\w+)/);\n            if (classMatch) {\n                return `${classMatch[1].toLowerCase()}.py`;\n            }\n            return 'main.py';\n        } else if (language === 'typescript' || language === 'javascript') {\n            const classMatch = code.match(/(?:class|interface)\\s+(\\w+)/);\n            if (classMatch) {\n                return `${classMatch[1]}.${language === 'typescript' ? 'ts' : 'js'}`;\n            }\n            return `index.${language === 'typescript' ? 'ts' : 'js'}`;\n        }\n        \n        return `code.${language}`;\n    }\n\n    private extractPreviousContent(previousResults: TaskResult[]): string {\n        return previousResults\n            .map(result => result.content)\n            .join('\\n\\n---\\n\\n')\n            .substring(0, 2000); // Limit context size\n    }\n}","/**\n * Agent Registry and Task Delegation System\n * Central registry for all agents with capability mapping and task delegation logic\n */\nimport * as vscode from 'vscode';\n\nexport interface AgentCapability {\n    id: string;\n    name: string;\n    model: string;\n    specialization: string;\n    canHandle: string[];\n    instructionSet: string;\n}\n\nexport class AgentRegistry {\n    private static instance: AgentRegistry;\n\n    // Static registry of agent capabilities for task delegation\n    public static readonly AGENT_CAPABILITIES: Record<string, {\n        specialization: string;\n        canHandle: string[];\n        model: string;\n        instructionSet: string;\n    }> = {\n        'orchestrator': {\n            specialization: 'Multi-Agent Workflow Coordination',\n            canHandle: ['workflow', 'orchestration', 'multi-step', 'complex-tasks', 'coordination'],\n            model: 'gpt-5-2025-09-12',\n            instructionSet: 'orchestrator.md'\n        },\n        'architect': {\n            specialization: 'System Architecture & Design',\n            canHandle: ['architecture', 'design', 'patterns', 'scalability', 'tech-stack', 'system-design', 'database-design'],\n            model: 'gpt-5-2025-09-12',\n            instructionSet: 'architect.md'\n        },\n        'codesmith': {\n            specialization: 'Code Implementation & Optimization',\n            canHandle: ['coding', 'implementation', 'optimization', 'testing', 'debugging', 'refactoring', 'code-review'],\n            model: 'claude-4.1-sonnet-20250920',\n            instructionSet: 'codesmith.md'\n        },\n        'tradestrat': {\n            specialization: 'Trading Strategies & Financial Analysis',\n            canHandle: ['trading', 'algorithms', 'financial', 'backtesting', 'market-analysis', 'portfolio', 'risk-management'],\n            model: 'claude-4.1-sonnet-20250920',\n            instructionSet: 'tradestrat.md'\n        },\n        'research': {\n            specialization: 'Web Research & Information Gathering',\n            canHandle: ['research', 'web-search', 'documentation', 'fact-checking', 'information-gathering', 'api-docs'],\n            model: 'perplexity-llama-3.1-sonar-huge-128k',\n            instructionSet: 'research.md'\n        },\n        'opus-arbitrator': {\n            specialization: 'Agent Conflict Resolution',\n            canHandle: ['conflicts', 'decision-making', 'arbitration', 'dispute-resolution', 'consensus'],\n            model: 'claude-4.1-opus-20250915',\n            instructionSet: 'richter.md'\n        },\n        'docu': {\n            specialization: 'Technical Documentation & API Reference',\n            canHandle: ['documentation', 'readme', 'api-docs', 'user-guides', 'comments', 'changelog', 'technical-writing', 'instruction-management'],\n            model: 'gpt-5-2025-09-12',\n            instructionSet: 'docubot-instructions.md'\n        },\n        'reviewer': {\n            specialization: 'Code Review & Security Analysis',\n            canHandle: ['code-review', 'security', 'performance-analysis', 'standards', 'testing', 'quality-assurance', 'vulnerabilities', 'architecture-validation'],\n            model: 'gpt-5-mini-2025-09-20',\n            instructionSet: 'reviewergpt-instructions.md'\n        },\n        'fixer': {\n            specialization: 'Bug Fixing & Optimization',\n            canHandle: ['bug-fixing', 'debugging', 'error-resolution', 'optimization', 'refactoring', 'modernization', 'hotfix'],\n            model: 'claude-4.1-sonnet-20250920',\n            instructionSet: 'fixerbot-instructions.md'\n        }\n    };\n\n    public static getInstance(): AgentRegistry {\n        if (!AgentRegistry.instance) {\n            AgentRegistry.instance = new AgentRegistry();\n        }\n        return AgentRegistry.instance;\n    }\n\n    /**\n     * Get all registered agents with their capabilities\n     */\n    public getRegisteredAgents(): AgentCapability[] {\n        return Object.entries(AgentRegistry.AGENT_CAPABILITIES).map(([id, capability]) => ({\n            id,\n            name: this.getAgentDisplayName(id),\n            model: capability.model,\n            specialization: capability.specialization,\n            canHandle: capability.canHandle,\n            instructionSet: capability.instructionSet\n        }));\n    }\n\n    /**\n     * Get information about a specific agent\n     */\n    public getAgentInfo(agentId: string): AgentCapability | undefined {\n        const capability = AgentRegistry.AGENT_CAPABILITIES[agentId];\n        if (!capability) return undefined;\n\n        return {\n            id: agentId,\n            name: this.getAgentDisplayName(agentId),\n            model: capability.model,\n            specialization: capability.specialization,\n            canHandle: capability.canHandle,\n            instructionSet: capability.instructionSet\n        };\n    }\n\n    /**\n     * Suggest the best agent for a given task based on keywords\n     */\n    public suggestAgentForTask(taskDescription: string): string | null {\n        const lowerTask = taskDescription.toLowerCase();\n        let bestMatch: { agent: string; score: number } | null = null;\n\n        for (const [agentId, capability] of Object.entries(AgentRegistry.AGENT_CAPABILITIES)) {\n            let score = 0;\n            for (const keyword of capability.canHandle) {\n                if (lowerTask.includes(keyword)) {\n                    score += keyword.split('-').length; // Multi-word keywords get higher score\n                }\n            }\n\n            if (score > 0 && (!bestMatch || score > bestMatch.score)) {\n                bestMatch = { agent: agentId, score };\n            }\n        }\n\n        return bestMatch?.agent || null;\n    }\n\n    /**\n     * Get a formatted list of all agents for display\n     */\n    public getAgentListDescription(): string {\n        const agents = this.getRegisteredAgents();\n        return agents.map((agent, index) =>\n            `${index + 1}. **${agent.name}** - ${agent.specialization} (${agent.model})`\n        ).join('\\n');\n    }\n\n    /**\n     * Get task delegation suggestions for a specific agent\n     */\n    public getTaskDelegationInfo(currentAgentId: string): string {\n        const currentAgent = this.getAgentInfo(currentAgentId);\n        if (!currentAgent) return '';\n\n        const otherAgents = this.getRegisteredAgents().filter(a => a.id !== currentAgentId);\n\n        let delegationInfo = `## Task Delegation Guidelines\\n\\n`;\n        delegationInfo += `You are **${currentAgent.name}** specializing in: ${currentAgent.specialization}\\n\\n`;\n        delegationInfo += `When encountering tasks outside your expertise, suggest these agents:\\n\\n`;\n\n        for (const agent of otherAgents) {\n            const keywords = agent.canHandle.slice(0, 3).join(', ');\n            delegationInfo += `- **${keywords}** → Suggest: \"@${agent.id} specializes in ${agent.specialization}\"\\n`;\n        }\n\n        delegationInfo += `\\nYou ARE the expert for: ${currentAgent.canHandle.join(', ')}`;\n\n        return delegationInfo;\n    }\n\n    private getAgentDisplayName(agentId: string): string {\n        const nameMap: Record<string, string> = {\n            'orchestrator': 'OrchestratorAgent',\n            'architect': 'ArchitectAgent',\n            'codesmith': 'CodeSmithAgent',\n            'tradestrat': 'TradeStratAgent',\n            'research': 'ResearchAgent',\n            'opus-arbitrator': 'OpusArbitratorAgent',\n            'docu': 'DocuBot',\n            'reviewer': 'ReviewerGPT',\n            'fixer': 'FixerBot'\n        };\n        return nameMap[agentId] || agentId;\n    }\n}","/**\n * Anthropic Service for Claude model interactions\n */\nimport * as vscode from 'vscode';\n\ninterface ChatMessage {\n    role: 'system' | 'user' | 'assistant';\n    content: string;\n}\n\ninterface ChatResponse {\n    content: Array<{\n        text: string;\n        type: string;\n    }>;\n}\n\nexport class AnthropicService {\n    private apiKey: string;\n    private baseURL: string;\n\n    constructor() {\n        const config = vscode.workspace.getConfiguration('kiAutoAgent');\n        this.apiKey = config.get<string>('anthropic.apiKey', '');\n        this.baseURL = 'https://api.anthropic.com/v1';\n    }\n\n    async chat(\n        messages: ChatMessage[],\n        model: string = 'claude-3-5-sonnet-20241022',\n        maxTokens: number = 4000,\n        temperature: number = 0.7\n    ): Promise<string> {\n        \n        if (!this.apiKey) {\n            throw new Error('Anthropic API key not configured');\n        }\n\n        // Anthropic expects system message separate from messages\n        const systemMessage = messages.find(m => m.role === 'system');\n        const conversationMessages = messages.filter(m => m.role !== 'system');\n\n        const requestBody = {\n            model,\n            max_tokens: maxTokens,\n            temperature,\n            system: systemMessage?.content || '',\n            messages: conversationMessages.map(msg => ({\n                role: msg.role,\n                content: msg.content\n            }))\n        };\n\n        try {\n            const response = await fetch(`${this.baseURL}/messages`, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'X-API-Key': this.apiKey,\n                    'anthropic-version': '2023-06-01'\n                },\n                body: JSON.stringify(requestBody)\n            });\n\n            if (!response.ok) {\n                const errorData = await response.json().catch(() => ({ error: { message: response.statusText } }));\n                throw new Error(`Anthropic API error: ${(errorData as any).error?.message || response.statusText}`);\n            }\n\n            const data= await response.json() as ChatResponse;\n            \n            if (!data.content || data.content.length === 0) {\n                throw new Error('No response from Anthropic API');\n            }\n\n            // Extract text from content blocks\n            return data.content\n                .filter(block => block.type === 'text')\n                .map(block => block.text)\n                .join('');\n\n        } catch (error) {\n            if (error instanceof Error) {\n                throw error;\n            }\n            throw new Error(`Anthropic API request failed: ${error}`);\n        }\n    }\n\n    async streamChat(\n        messages: ChatMessage[],\n        onChunk: (chunk: string) => void,\n        model: string = 'claude-3-5-sonnet-20241022',\n        maxTokens: number = 4000,\n        temperature: number = 0.7\n    ): Promise<void> {\n        \n        if (!this.apiKey) {\n            throw new Error('Anthropic API key not configured');\n        }\n\n        const systemMessage = messages.find(m => m.role === 'system');\n        const conversationMessages = messages.filter(m => m.role !== 'system');\n\n        const requestBody = {\n            model,\n            max_tokens: maxTokens,\n            temperature,\n            system: systemMessage?.content || '',\n            messages: conversationMessages.map(msg => ({\n                role: msg.role,\n                content: msg.content\n            })),\n            stream: true\n        };\n\n        try {\n            const response = await fetch(`${this.baseURL}/messages`, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'X-API-Key': this.apiKey,\n                    'anthropic-version': '2023-06-01'\n                },\n                body: JSON.stringify(requestBody)\n            });\n\n            if (!response.ok) {\n                throw new Error(`Anthropic API error: ${response.statusText}`);\n            }\n\n            const reader = response.body?.getReader();\n            if (!reader) {\n                throw new Error('Failed to get response stream');\n            }\n\n            const decoder = new TextDecoder();\n\n            while (true) {\n                const { done, value } = await reader.read();\n                \n                if (done) {\n                    break;\n                }\n\n                const chunk = decoder.decode(value);\n                const lines = chunk.split('\\n').filter(line => line.trim() !== '');\n\n                for (const line of lines) {\n                    if (line.startsWith('data: ')) {\n                        const data = line.substring(6);\n                        \n                        if (data === '[DONE]') {\n                            return;\n                        }\n\n                        try {\n                            const parsed = JSON.parse(data);\n                            \n                            if (parsed.type === 'content_block_delta') {\n                                const text = parsed.delta?.text;\n                                if (text) {\n                                    onChunk(text);\n                                }\n                            }\n                        } catch (error) {\n                            // Ignore parsing errors for incomplete chunks\n                        }\n                    }\n                }\n            }\n\n        } catch (error) {\n            throw new Error(`Anthropic streaming failed: ${error}`);\n        }\n    }\n\n    validateApiKey(): boolean {\n        return !!this.apiKey && this.apiKey.startsWith('sk-ant-');\n    }\n\n    async testConnection(): Promise<boolean> {\n        try {\n            await this.chat([\n                { role: 'user', content: 'Test connection' }\n            ], 'claude-3-5-sonnet-20241022', 10);\n            return true;\n        } catch (error) {\n            return false;\n        }\n    }\n}","/**\n * DocuBot - Technical Documentation Expert\n * Creates comprehensive documentation, READMEs, and API references\n */\nimport * as vscode from 'vscode';\nimport { ChatAgent } from './base/ChatAgent';\nimport { AgentConfig, TaskRequest, TaskResult, WorkflowStep } from '../types';\nimport { VSCodeMasterDispatcher } from '../core/VSCodeMasterDispatcher';\nimport { OpenAIService } from '../utils/OpenAIService';\nimport * as path from 'path';\nimport * as fs from 'fs/promises';\n\nexport class DocuBotAgent extends ChatAgent {\n    private openAIService: OpenAIService;\n\n    constructor(context: vscode.ExtensionContext, dispatcher: VSCodeMasterDispatcher) {\n        const config: AgentConfig = {\n            participantId: 'ki-autoagent.docu',\n            name: 'docu',\n            fullName: 'DocuBot',\n            description: 'Technical Documentation Expert - Creates READMEs, API docs, user guides',\n            model: 'gpt-5-2025-09-12',\n            iconPath: vscode.Uri.joinPath(context.extensionUri, 'media', 'docu-icon.svg'),\n            capabilities: [\n                'README Generation',\n                'API Documentation',\n                'User Guides',\n                'Code Comments',\n                'Technical Writing',\n                'Markdown Formatting',\n                'JSDoc/DocStrings',\n                'Changelog Creation'\n            ],\n            commands: [\n                { name: 'readme', description: 'Generate README for project', handler: 'handleReadmeCommand' },\n                { name: 'api', description: 'Create API documentation', handler: 'handleApiCommand' },\n                { name: 'guide', description: 'Write user guide or tutorial', handler: 'handleGuideCommand' },\n                { name: 'comments', description: 'Add documentation comments to code', handler: 'handleCommentsCommand' },\n                { name: 'changelog', description: 'Generate changelog from commits', handler: 'handleChangelogCommand' },\n                { name: 'update-instructions', description: 'Update agent instruction files', handler: 'handleUpdateInstructionsCommand' },\n                { name: 'view-instructions', description: 'View agent instruction files', handler: 'handleViewInstructionsCommand' }\n            ]\n        };\n\n        super(config, context, dispatcher);\n        this.openAIService = new OpenAIService();\n    }\n\n    protected async handleRequest(\n        request: vscode.ChatRequest,\n        context: vscode.ChatContext,\n        stream: vscode.ChatResponseStream,\n        token: vscode.CancellationToken\n    ): Promise<void> {\n\n        const command = request.command;\n        const prompt = request.prompt;\n\n        this.log(`Processing ${command ? `/${command}` : 'general'} documentation request: ${prompt.substring(0, 100)}...`);\n\n        if (command) {\n            await this.handleCommand(command, prompt, stream, token);\n        } else {\n            await this.handleGeneralDocumentationRequest(prompt, stream, token);\n        }\n    }\n\n    protected async processWorkflowStep(\n        step: WorkflowStep,\n        request: TaskRequest,\n        previousResults: TaskResult[]\n    ): Promise<TaskResult> {\n\n        try {\n            let documentationContent = '';\n\n            switch (step.id) {\n                case 'document_code':\n                    documentationContent = await this.generateCodeDocumentation(request, previousResults);\n                    break;\n\n                case 'create_readme':\n                    documentationContent = await this.generateReadme(request, previousResults);\n                    break;\n\n                case 'api_docs':\n                    documentationContent = await this.generateApiDocs(request, previousResults);\n                    break;\n\n                default:\n                    documentationContent = await this.generateGeneralDocs(request, previousResults);\n            }\n\n            return {\n                status: 'success',\n                content: documentationContent,\n                metadata: {\n                    step: step.id,\n                    agent: 'docu',\n                    type: 'documentation'\n                }\n            };\n\n        } catch (error) {\n            throw new Error(`Failed to process documentation step ${step.id}: ${(error as any).message}`);\n        }\n    }\n\n    // Command Handlers\n\n    private async handleReadmeCommand(\n        prompt: string,\n        stream: vscode.ChatResponseStream,\n        token: vscode.CancellationToken\n    ): Promise<void> {\n\n        stream.progress('📝 Analyzing project structure...');\n\n        try {\n            const workspaceFolder = vscode.workspace.workspaceFolders?.[0];\n            if (!workspaceFolder) {\n                stream.markdown('❌ No workspace folder found');\n                return;\n            }\n\n            // Analyze project structure\n            const projectInfo = await this.analyzeProjectStructure(workspaceFolder.uri.fsPath);\n\n            stream.progress('📝 Generating README...');\n\n            const readmeContent = await this.createReadme(projectInfo, prompt);\n\n            stream.markdown('## 📝 Generated README\\n\\n');\n            stream.markdown('```markdown\\n' + readmeContent + '\\n```');\n\n            // Offer to save\n            this.createActionButton(\n                '💾 Save README.md',\n                'ki-autoagent.saveFile',\n                ['README.md', readmeContent],\n                stream\n            );\n\n        } catch (error) {\n            stream.markdown(`❌ README generation failed: ${(error as any).message}`);\n        }\n    }\n\n    private async handleApiCommand(\n        prompt: string,\n        stream: vscode.ChatResponseStream,\n        token: vscode.CancellationToken\n    ): Promise<void> {\n\n        stream.progress('🔍 Analyzing code for API endpoints...');\n\n        try {\n            const workspaceFolder = vscode.workspace.workspaceFolders?.[0];\n            if (!workspaceFolder) {\n                stream.markdown('❌ No workspace folder found');\n                return;\n            }\n\n            // Find and analyze API endpoints\n            const apiInfo = await this.analyzeApiEndpoints(workspaceFolder.uri.fsPath);\n\n            stream.progress('📖 Generating API documentation...');\n\n            const apiDocs = await this.createApiDocumentation(apiInfo, prompt);\n\n            stream.markdown('## 📖 API Documentation\\n\\n');\n            stream.markdown('```markdown\\n' + apiDocs + '\\n```');\n\n            // Offer to save\n            this.createActionButton(\n                '💾 Save API.md',\n                'ki-autoagent.saveFile',\n                ['docs/API.md', apiDocs],\n                stream\n            );\n\n        } catch (error) {\n            stream.markdown(`❌ API documentation generation failed: ${(error as any).message}`);\n        }\n    }\n\n    private async handleGuideCommand(\n        prompt: string,\n        stream: vscode.ChatResponseStream,\n        token: vscode.CancellationToken\n    ): Promise<void> {\n\n        stream.progress('📚 Creating user guide...');\n\n        try {\n            const guide = await this.createUserGuide(prompt);\n\n            stream.markdown('## 📚 User Guide\\n\\n');\n            stream.markdown(guide);\n\n            // Offer to save\n            this.createActionButton(\n                '💾 Save Guide',\n                'ki-autoagent.saveFile',\n                ['docs/USER_GUIDE.md', guide],\n                stream\n            );\n\n        } catch (error) {\n            stream.markdown(`❌ Guide creation failed: ${(error as any).message}`);\n        }\n    }\n\n    private async handleCommentsCommand(\n        prompt: string,\n        stream: vscode.ChatResponseStream,\n        token: vscode.CancellationToken\n    ): Promise<void> {\n\n        const editor = vscode.window.activeTextEditor;\n        if (!editor) {\n            stream.markdown('❌ No active editor found. Please open a file to document.');\n            return;\n        }\n\n        stream.progress('💬 Adding documentation comments...');\n\n        try {\n            const document = editor.document;\n            const code = document.getText();\n            const language = document.languageId;\n\n            const documentedCode = await this.addDocumentationComments(code, language, prompt);\n\n            stream.markdown('## 💬 Documented Code\\n\\n');\n            stream.markdown('```' + language + '\\n' + documentedCode + '\\n```');\n\n            // Offer to replace\n            this.createActionButton(\n                '💾 Apply Comments',\n                'ki-autoagent.replaceContent',\n                [documentedCode],\n                stream\n            );\n\n        } catch (error) {\n            stream.markdown(`❌ Comment generation failed: ${(error as any).message}`);\n        }\n    }\n\n    private async handleChangelogCommand(\n        prompt: string,\n        stream: vscode.ChatResponseStream,\n        token: vscode.CancellationToken\n    ): Promise<void> {\n\n        stream.progress('📋 Analyzing commit history...');\n\n        try {\n            // Get git log\n            const gitLog = await this.getGitLog();\n\n            stream.progress('📋 Generating changelog...');\n\n            const changelog = await this.createChangelog(gitLog, prompt);\n\n            stream.markdown('## 📋 Changelog\\n\\n');\n            stream.markdown('```markdown\\n' + changelog + '\\n```');\n\n            // Offer to save\n            this.createActionButton(\n                '💾 Save CHANGELOG.md',\n                'ki-autoagent.saveFile',\n                ['CHANGELOG.md', changelog],\n                stream\n            );\n\n        } catch (error) {\n            stream.markdown(`❌ Changelog generation failed: ${(error as any).message}`);\n        }\n    }\n\n    private async handleGeneralDocumentationRequest(\n        prompt: string,\n        stream: vscode.ChatResponseStream,\n        token: vscode.CancellationToken\n    ): Promise<void> {\n\n        stream.progress('📝 Creating documentation...');\n\n        try {\n            const documentation = await this.createGeneralDocumentation(prompt);\n\n            stream.markdown('## 📝 Documentation\\n\\n');\n            stream.markdown(documentation);\n\n        } catch (error) {\n            stream.markdown(`❌ Documentation creation failed: ${(error as any).message}`);\n        }\n    }\n\n    private async handleUpdateInstructionsCommand(\n        prompt: string,\n        stream: vscode.ChatResponseStream,\n        token: vscode.CancellationToken\n    ): Promise<void> {\n\n        stream.progress('📝 Updating agent instructions...');\n\n        try {\n            // Parse agent name from prompt\n            const agentMatch = prompt.match(/\\b(orchestrator|architect|codesmith|tradestrat|research|opus-arbitrator|docu|reviewer|fixer)\\b/i);\n            if (!agentMatch) {\n                stream.markdown('❌ Please specify which agent instructions to update (e.g., \"update-instructions for codesmith\")');\n                return;\n            }\n\n            const agentName = agentMatch[1].toLowerCase();\n\n            // Read current instructions\n            const currentInstructions = await this.readInstructionFile(agentName);\n\n            stream.progress('📝 Analyzing and improving instructions...');\n\n            // Generate improvements\n            const improvedInstructions = await this.improveInstructions(agentName, currentInstructions, prompt);\n\n            stream.markdown(`## 📝 Improved Instructions for ${agentName}\\n\\n`);\n            stream.markdown('```markdown\\n' + improvedInstructions + '\\n```');\n\n            // Offer to save\n            this.createActionButton(\n                '💾 Save Updated Instructions',\n                'ki-autoagent.saveInstructions',\n                [agentName, improvedInstructions],\n                stream\n            );\n\n        } catch (error) {\n            stream.markdown(`❌ Instruction update failed: ${(error as any).message}`);\n        }\n    }\n\n    private async handleViewInstructionsCommand(\n        prompt: string,\n        stream: vscode.ChatResponseStream,\n        token: vscode.CancellationToken\n    ): Promise<void> {\n\n        stream.progress('📖 Loading agent instructions...');\n\n        try {\n            // Parse agent name from prompt or list all\n            const agentMatch = prompt.match(/\\b(orchestrator|architect|codesmith|tradestrat|research|opus-arbitrator|docu|reviewer|fixer)\\b/i);\n\n            if (agentMatch) {\n                const agentName = agentMatch[1].toLowerCase();\n                const instructions = await this.readInstructionFile(agentName);\n\n                stream.markdown(`## 📖 Instructions for ${agentName}\\n\\n`);\n                stream.markdown('```markdown\\n' + instructions + '\\n```');\n            } else {\n                // List all available instruction files\n                stream.markdown('## 📖 Available Agent Instructions\\n\\n');\n                stream.markdown('Choose an agent to view instructions:\\n');\n                stream.markdown('- orchestrator\\n');\n                stream.markdown('- architect\\n');\n                stream.markdown('- codesmith\\n');\n                stream.markdown('- tradestrat\\n');\n                stream.markdown('- research\\n');\n                stream.markdown('- opus-arbitrator (richter)\\n');\n                stream.markdown('- docu\\n');\n                stream.markdown('- reviewer\\n');\n                stream.markdown('- fixer\\n\\n');\n                stream.markdown('Use: `/view-instructions [agent-name]` to view specific instructions');\n            }\n\n        } catch (error) {\n            stream.markdown(`❌ Failed to view instructions: ${(error as any).message}`);\n        }\n    }\n\n    // Helper Methods\n\n    private async analyzeProjectStructure(workspacePath: string): Promise<any> {\n        // Analyze project files, package.json, etc.\n        const projectInfo: {\n            name: string;\n            path: string;\n            hasPackageJson: boolean;\n            dependencies: string[];\n            scripts: Record<string, string>;\n            mainFiles: string[];\n        } = {\n            name: path.basename(workspacePath),\n            path: workspacePath,\n            hasPackageJson: false,\n            dependencies: [],\n            scripts: {},\n            mainFiles: []\n        };\n\n        try {\n            const packageJsonPath = path.join(workspacePath, 'package.json');\n            const packageJson = JSON.parse(await fs.readFile(packageJsonPath, 'utf-8'));\n            projectInfo.hasPackageJson = true;\n            projectInfo.dependencies = Object.keys(packageJson.dependencies || {});\n            projectInfo.scripts = packageJson.scripts || {};\n        } catch (error) {\n            // No package.json or error reading it\n        }\n\n        return projectInfo;\n    }\n\n    private async analyzeApiEndpoints(workspacePath: string): Promise<any> {\n        // Analyze code for API endpoints\n        // This would be more sophisticated in a real implementation\n        return {\n            endpoints: [],\n            baseUrl: '',\n            authentication: 'unknown'\n        };\n    }\n\n    private async createReadme(projectInfo: any, additionalContext: string): Promise<string> {\n        const prompt = `Create a comprehensive README.md for a project with the following information:\n\nProject Name: ${projectInfo.name}\nHas package.json: ${projectInfo.hasPackageJson}\nDependencies: ${projectInfo.dependencies.join(', ')}\nScripts: ${JSON.stringify(projectInfo.scripts, null, 2)}\n\nAdditional context: ${additionalContext}\n\nCreate a professional README with sections for:\n- Project title and description\n- Features\n- Installation\n- Usage\n- Configuration (if applicable)\n- API Reference (if applicable)\n- Contributing\n- License\n\nUse proper markdown formatting with badges where appropriate.\n\n${this.getSystemContextPrompt()}`;\n\n        return await this.openAIService.chat([\n            { role: 'system', content: 'You are DocuBot, an expert technical writer specializing in creating clear, comprehensive documentation.' },\n            { role: 'user', content: prompt }\n        ]);\n    }\n\n    private async createApiDocumentation(apiInfo: any, additionalContext: string): Promise<string> {\n        const prompt = `Create comprehensive API documentation based on the following:\n\n${JSON.stringify(apiInfo, null, 2)}\n\nAdditional context: ${additionalContext}\n\nInclude:\n- API overview\n- Authentication\n- Endpoints with request/response examples\n- Error codes\n- Rate limiting (if applicable)\n- Examples in multiple languages\n\n${this.getSystemContextPrompt()}`;\n\n        return await this.openAIService.chat([\n            { role: 'system', content: 'You are DocuBot, an expert in creating clear, comprehensive API documentation.' },\n            { role: 'user', content: prompt }\n        ]);\n    }\n\n    private async createUserGuide(context: string): Promise<string> {\n        const prompt = `Create a comprehensive user guide for the following:\n\n${context}\n\nInclude:\n- Getting Started\n- Key Features\n- Step-by-step tutorials\n- Common use cases\n- Troubleshooting\n- FAQ\n\nMake it user-friendly and easy to follow.\n\n${this.getSystemContextPrompt()}`;\n\n        return await this.openAIService.chat([\n            { role: 'system', content: 'You are DocuBot, an expert in creating user-friendly documentation and guides.' },\n            { role: 'user', content: prompt }\n        ]);\n    }\n\n    private async addDocumentationComments(code: string, language: string, context: string): Promise<string> {\n        const prompt = `Add comprehensive documentation comments to this ${language} code:\n\n${code}\n\nAdditional context: ${context}\n\nUse the appropriate comment style for ${language} (JSDoc for JavaScript/TypeScript, docstrings for Python, etc.)\nDocument all functions, classes, and complex logic.\n\n${this.getSystemContextPrompt()}`;\n\n        return await this.openAIService.chat([\n            { role: 'system', content: 'You are DocuBot, an expert in code documentation and technical writing.' },\n            { role: 'user', content: prompt }\n        ]);\n    }\n\n    private async createChangelog(gitLog: string, context: string): Promise<string> {\n        const prompt = `Create a CHANGELOG.md based on the following git history:\n\n${gitLog}\n\nAdditional context: ${context}\n\nFormat using Keep a Changelog standard (https://keepachangelog.com/)\nGroup changes by version and category (Added, Changed, Deprecated, Removed, Fixed, Security)\n\n${this.getSystemContextPrompt()}`;\n\n        return await this.openAIService.chat([\n            { role: 'system', content: 'You are DocuBot, an expert in creating clear, organized changelogs.' },\n            { role: 'user', content: prompt }\n        ]);\n    }\n\n    private async createGeneralDocumentation(context: string): Promise<string> {\n        const prompt = `Create comprehensive documentation for:\n\n${context}\n\nMake it clear, well-structured, and professional.\n\n${this.getSystemContextPrompt()}`;\n\n        return await this.openAIService.chat([\n            { role: 'system', content: 'You are DocuBot, an expert technical writer creating clear, comprehensive documentation.' },\n            { role: 'user', content: prompt }\n        ]);\n    }\n\n    private async getGitLog(): Promise<string> {\n        // Execute git log command\n        const cp = require('child_process');\n        return new Promise((resolve, reject) => {\n            cp.exec('git log --oneline -50', (error: any, stdout: string, stderr: string) => {\n                if (error) {\n                    reject(error);\n                } else {\n                    resolve(stdout);\n                }\n            });\n        });\n    }\n\n    // Workflow helper methods\n    private async generateCodeDocumentation(request: TaskRequest, previousResults: TaskResult[]): Promise<string> {\n        const context = this.buildContextFromResults(previousResults);\n        return this.createGeneralDocumentation(`Document the following code/feature:\\n${request.prompt}\\n\\nContext from previous steps:\\n${context}`);\n    }\n\n    private async generateReadme(request: TaskRequest, previousResults: TaskResult[]): Promise<string> {\n        const workspaceFolder = vscode.workspace.workspaceFolders?.[0];\n        if (!workspaceFolder) {\n            throw new Error('No workspace folder found');\n        }\n        const projectInfo = await this.analyzeProjectStructure(workspaceFolder.uri.fsPath);\n        const context = this.buildContextFromResults(previousResults);\n        return this.createReadme(projectInfo, `${request.prompt}\\n\\nContext:\\n${context}`);\n    }\n\n    private async generateApiDocs(request: TaskRequest, previousResults: TaskResult[]): Promise<string> {\n        const workspaceFolder = vscode.workspace.workspaceFolders?.[0];\n        if (!workspaceFolder) {\n            throw new Error('No workspace folder found');\n        }\n        const apiInfo = await this.analyzeApiEndpoints(workspaceFolder.uri.fsPath);\n        const context = this.buildContextFromResults(previousResults);\n        return this.createApiDocumentation(apiInfo, `${request.prompt}\\n\\nContext:\\n${context}`);\n    }\n\n    private async generateGeneralDocs(request: TaskRequest, previousResults: TaskResult[]): Promise<string> {\n        const context = this.buildContextFromResults(previousResults);\n        return this.createGeneralDocumentation(`${request.prompt}\\n\\nContext from previous steps:\\n${context}`);\n    }\n\n    private buildContextFromResults(results: TaskResult[]): string {\n        return results\n            .filter(r => r.status === 'success')\n            .map(r => `${r.metadata?.step || 'Step'}: ${r.content}`)\n            .join('\\n\\n');\n    }\n\n    private async readInstructionFile(agentName: string): Promise<string> {\n        try {\n            // Map agent names to instruction file names\n            const fileNameMap: Record<string, string> = {\n                'orchestrator': 'orchestrator-instructions',\n                'architect': 'architect-instructions',\n                'codesmith': 'codesmith-instructions',\n                'tradestrat': 'tradestrat-instructions',\n                'research': 'research-instructions',\n                'opus-arbitrator': 'richter-instructions',\n                'docu': 'docubot-instructions',\n                'reviewer': 'reviewergpt-instructions',\n                'fixer': 'fixerbot-instructions'\n            };\n\n            const fileName = fileNameMap[agentName] || `${agentName}-instructions`;\n            const instructionPath = path.join(\n                this.context.extensionPath,\n                'src',\n                'instructions',\n                `${fileName}.md`\n            );\n\n            return await fs.readFile(instructionPath, 'utf-8');\n        } catch (error) {\n            throw new Error(`Failed to read instructions for ${agentName}: ${(error as any).message}`);\n        }\n    }\n\n    private async writeInstructionFile(agentName: string, content: string): Promise<void> {\n        try {\n            // Map agent names to instruction file names\n            const fileNameMap: Record<string, string> = {\n                'orchestrator': 'orchestrator-instructions',\n                'architect': 'architect-instructions',\n                'codesmith': 'codesmith-instructions',\n                'tradestrat': 'tradestrat-instructions',\n                'research': 'research-instructions',\n                'opus-arbitrator': 'richter-instructions',\n                'docu': 'docubot-instructions',\n                'reviewer': 'reviewergpt-instructions',\n                'fixer': 'fixerbot-instructions'\n            };\n\n            const fileName = fileNameMap[agentName] || `${agentName}-instructions`;\n            const instructionPath = path.join(\n                this.context.extensionPath,\n                'src',\n                'instructions',\n                `${fileName}.md`\n            );\n\n            await fs.writeFile(instructionPath, content, 'utf-8');\n        } catch (error) {\n            throw new Error(`Failed to write instructions for ${agentName}: ${(error as any).message}`);\n        }\n    }\n\n    private async improveInstructions(agentName: string, currentInstructions: string, userContext: string): Promise<string> {\n        const prompt = `Improve the instruction set for the ${agentName} agent.\n\nCurrent instructions:\n${currentInstructions}\n\nUser context and requirements:\n${userContext}\n\nPlease improve these instructions by:\n1. Ensuring clarity and completeness\n2. Adding any missing capabilities or commands\n3. Improving formatting and organization\n4. Updating best practices\n5. Ensuring consistency with the agent's role\n6. Adding examples where helpful\n7. Keeping the same markdown structure\n\nReturn the complete improved instruction set in markdown format.\n\n${this.getSystemContextPrompt()}`;\n\n        return await this.openAIService.chat([\n            { role: 'system', content: 'You are DocuBot, an expert in creating and improving technical documentation and agent instructions.' },\n            { role: 'user', content: prompt }\n        ]);\n    }\n}","/**\n * VS Code Master Dispatcher - Orchestrates AI agents in VS Code context\n * Adapted from CLI MasterDispatcher for VS Code extension environment\n */\nimport * as vscode from 'vscode';\nimport { TaskRequest, TaskResult, Intent, WorkspaceContext, ProjectTypeDefinition, WorkflowStep } from '../types';\nimport { ConversationContextManager } from './ConversationContextManager';\n\nexport class VSCodeMasterDispatcher {\n    private agents: Map<string, any> = new Map();\n    private projectTypes: Map<string, ProjectTypeDefinition> = new Map();\n    private contextManager: ConversationContextManager;\n    private intentPatterns: Map<string, RegExp[]> = new Map();\n    private context: vscode.ExtensionContext;\n\n    constructor(context: vscode.ExtensionContext) {\n        this.context = context;\n        this.contextManager = ConversationContextManager.getInstance();\n        this.initializeProjectTypes();\n        this.initializeIntentPatterns();\n    }\n\n    /**\n     * Process a task request and route to appropriate agents\n     */\n    async processRequest(request: TaskRequest): Promise<TaskResult> {\n        console.log(`\\n🚦 [DISPATCHER] ====== processRequest called ======`);\n        console.log(`🚦 [DISPATCHER] request.command: '${request.command}'`);\n        console.log(`🚦 [DISPATCHER] request.command type: ${typeof request.command}`);\n        console.log(`🚦 [DISPATCHER] request.prompt: \"${request.prompt?.substring(0, 50)}...\"`);\n        console.log(`🚦 [DISPATCHER] Command check results:`);\n        console.log(`🚦 [DISPATCHER]   - request.command exists: ${!!request.command}`);\n        console.log(`🚦 [DISPATCHER]   - request.command !== 'auto': ${request.command !== 'auto'}`);\n        console.log(`🚦 [DISPATCHER]   - request.command !== 'orchestrator': ${request.command !== 'orchestrator'}`);\n        \n        try {\n            // Get workspace context\n            const workspaceContext = await this.getWorkspaceContext();\n            \n            // Check if a specific agent was requested (single agent mode)\n            if (request.command && request.command !== 'auto' && request.command !== 'orchestrator') {\n                console.log(`🎯 [DISPATCHER] ✅ SINGLE AGENT MODE ACTIVATED`);\n                console.log(`🎯 [DISPATCHER] Single agent mode: Using only ${request.command}`);\n                \n                // Create a single-step workflow for the specific agent\n                const workflow = [{\n                    id: 'execute',\n                    agent: request.command,\n                    description: `Execute with ${request.command}`\n                }];\n                \n                console.log(`🎯 [DISPATCHER] Created single-step workflow:`);\n                console.log(`🎯 [DISPATCHER]   - Steps count: ${workflow.length}`);\n                console.log(`🎯 [DISPATCHER]   - Step[0]: id='${workflow[0].id}', agent='${workflow[0].agent}'`);\n                \n                // Execute single agent\n                const result = await this.executeWorkflow(workflow, {\n                    ...request,\n                    context: workspaceContext,\n                    projectType: request.projectType || 'generic'\n                });\n                \n                return result;\n            }\n            \n            // Auto mode: Detect intent and create multi-step workflow\n            console.log(`🎯 [DISPATCHER] ⚠️ AUTO MODE ACTIVATED (not single agent)`);\n            console.log(`🎯 [DISPATCHER] Auto mode: Creating workflow based on intent`);\n            \n            // Detect intent and project type\n            const intent = await this.detectIntent(request.prompt);\n            const projectType = request.projectType || await this.detectProjectType(workspaceContext);\n            \n            // Create workflow\n            const workflow = this.createWorkflow(intent, projectType);\n            \n            // Execute workflow\n            const result = await this.executeWorkflow(workflow, {\n                ...request,\n                context: workspaceContext,\n                projectType\n            });\n\n            return result;\n        } catch (error) {\n            return {\n                status: 'error',\n                content: `Error processing request: ${(error as any).message}`,\n                metadata: { error: (error as any).message }\n            };\n        }\n    }\n\n    /**\n     * Detect user intent from prompt\n     */\n    async detectIntent(prompt: string): Promise<Intent> {\n        const lowerPrompt = prompt.toLowerCase();\n\n        // Check if this is a question rather than a task\n        const isQuestion = /^(what|which|how|was|welche|wie|wer|wo|wann|warum|show|list|explain)/i.test(prompt);\n        const isImplementation = /(implement|create|build|write|code|develop)/i.test(prompt);\n\n        // Query patterns - questions about the system or information\n        if (isQuestion && !isImplementation) {\n            // Questions about the system itself, agents, or instructions\n            if (this.matchesPatterns(lowerPrompt, ['instruction', 'agent', 'system', 'available', 'haben wir', 'gibt es', 'welche'])) {\n                return { type: 'query', confidence: 0.95, agent: 'orchestrator' };\n            }\n            // Architecture questions\n            if (this.matchesPatterns(lowerPrompt, ['architecture', 'design', 'pattern', 'structure'])) {\n                return { type: 'query', confidence: 0.9, agent: 'architect' };\n            }\n            // Research questions\n            if (this.matchesPatterns(lowerPrompt, ['research', 'find', 'information', 'latest'])) {\n                return { type: 'query', confidence: 0.85, agent: 'research' };\n            }\n            // Default query\n            return { type: 'query', confidence: 0.7, agent: 'orchestrator' };\n        }\n\n        // Architecture patterns (for actual design tasks)\n        if (this.matchesPatterns(lowerPrompt, ['design', 'architecture', 'system', 'plan', 'structure']) && isImplementation) {\n            return { type: 'architecture', confidence: 0.9, agent: 'architect' };\n        }\n\n        // Implementation patterns\n        if (this.matchesPatterns(lowerPrompt, ['implement', 'code', 'create', 'build', 'develop'])) {\n            return { type: 'implementation', confidence: 0.85, agent: 'codesmith' };\n        }\n\n        // Documentation patterns\n        if (this.matchesPatterns(lowerPrompt, ['document', 'readme', 'docs', 'explain', 'tutorial'])) {\n            return { type: 'documentation', confidence: 0.9, agent: 'docu' };\n        }\n\n        // Review patterns\n        if (this.matchesPatterns(lowerPrompt, ['review', 'check', 'analyze', 'audit', 'security'])) {\n            return { type: 'review', confidence: 0.85, agent: 'reviewer' };\n        }\n\n        // Debug/Fix patterns\n        if (this.matchesPatterns(lowerPrompt, ['fix', 'debug', 'error', 'bug', 'problem', 'issue'])) {\n            return { type: 'debug', confidence: 0.9, agent: 'fixer' };\n        }\n\n        // Trading patterns\n        if (this.matchesPatterns(lowerPrompt, ['trading', 'strategy', 'backtest', 'ron', 'market', 'stock'])) {\n            return { type: 'trading', confidence: 0.95, agent: 'tradestrat' };\n        }\n\n        // Research patterns\n        if (this.matchesPatterns(lowerPrompt, ['research', 'search', 'find', 'information', 'latest'])) {\n            return { type: 'research', confidence: 0.8, agent: 'research' };\n        }\n\n        // Default - if we can't determine, treat as a query\n        return { type: 'query', confidence: 0.5, agent: 'orchestrator' };\n    }\n\n    /**\n     * Detect project type from workspace context\n     */\n    async detectProjectType(context?: WorkspaceContext): Promise<string> {\n        if (!context?.workspaceRoots || context.workspaceRoots.length === 0) {\n            return 'generic_software';\n        }\n\n        const workspaceRoot = context.workspaceRoots[0];\n        \n        try {\n            // Check for package.json\n            const packageJsonUri = vscode.Uri.joinPath(workspaceRoot.uri, 'package.json');\n            try {\n                const packageJsonContent = await vscode.workspace.fs.readFile(packageJsonUri);\n                const packageJson = JSON.parse(packageJsonContent.toString());\n                \n                // Trading system indicators\n                if (packageJson.dependencies?.['streamlit'] || \n                    packageJson.dependencies?.['yfinance'] ||\n                    packageJson.dependencies?.['pandas']) {\n                    return 'trading_system';\n                }\n                \n                // Web API indicators\n                if (packageJson.dependencies?.['fastapi'] ||\n                    packageJson.dependencies?.['express'] ||\n                    packageJson.dependencies?.['flask']) {\n                    return 'web_api';\n                }\n                \n                // React/Frontend indicators\n                if (packageJson.dependencies?.['react'] ||\n                    packageJson.dependencies?.['vue'] ||\n                    packageJson.dependencies?.['angular']) {\n                    return 'web_frontend';\n                }\n            } catch (error) {\n                // package.json not found or invalid\n            }\n\n            // Check for requirements.txt (Python)\n            const requirementsUri = vscode.Uri.joinPath(workspaceRoot.uri, 'requirements.txt');\n            try {\n                const requirementsContent = await vscode.workspace.fs.readFile(requirementsUri);\n                const requirements = requirementsContent.toString();\n                \n                if (requirements.includes('yfinance') || \n                    requirements.includes('pandas') ||\n                    requirements.includes('streamlit')) {\n                    return 'trading_system';\n                }\n                \n                if (requirements.includes('fastapi') ||\n                    requirements.includes('flask') ||\n                    requirements.includes('django')) {\n                    return 'web_api';\n                }\n            } catch (error) {\n                // requirements.txt not found\n            }\n\n            // Check for specific files\n            const files = await vscode.workspace.findFiles('**/*.{py,js,ts,jsx,tsx}', '**/node_modules/**', 50);\n            const filenames = files.map(uri => uri.fsPath.toLowerCase());\n            \n            if (filenames.some(f => f.includes('strategy') || f.includes('trading') || f.includes('backtest'))) {\n                return 'trading_system';\n            }\n            \n            if (filenames.some(f => f.includes('api') || f.includes('server') || f.includes('endpoint'))) {\n                return 'web_api';\n            }\n\n        } catch (error) {\n            console.error('Error detecting project type:', error);\n        }\n\n        return 'generic_software';\n    }\n\n    /**\n     * Create workflow based on intent and project type\n     * Note: Uses only available agents (architect, codesmith, tradestrat, research, richter, orchestrator)\n     */\n    createWorkflow(intent: Intent, projectType: string): WorkflowStep[] {\n        const projectDef = this.projectTypes.get(projectType);\n        \n        // Base workflow based on intent\n        let workflow: WorkflowStep[] = [];\n        \n        switch (intent.type) {\n            case 'query':\n                // For queries, just use a single step with the appropriate agent\n                workflow = [\n                    { id: 'answer', agent: intent.agent, description: 'Answer query directly' }\n                ];\n                break;\n\n            case 'architecture':\n                workflow = [\n                    { id: 'analyze', agent: 'architect', description: 'Analyze requirements and context' },\n                    { id: 'design', agent: 'architect', description: 'Create architecture design' },\n                    { id: 'review', agent: 'codesmith', description: 'Review architecture for best practices' } // Using codesmith instead of missing 'reviewer'\n                ];\n                break;\n                \n            case 'implementation':\n                workflow = [\n                    { id: 'plan', agent: 'architect', description: 'Plan implementation approach' },\n                    { id: 'implement', agent: 'codesmith', description: 'Implement the solution' },\n                    { id: 'test', agent: 'codesmith', description: 'Create tests' },\n                    { id: 'review', agent: 'codesmith', description: 'Review implementation' } // Using codesmith instead of missing 'reviewer'\n                ];\n                break;\n                \n            case 'trading':\n                workflow = [\n                    { id: 'strategy_design', agent: 'tradestrat', description: 'Design trading strategy' },\n                    { id: 'implement', agent: 'codesmith', description: 'Implement strategy code' },\n                    { id: 'backtest', agent: 'tradestrat', description: 'Create backtesting framework' },\n                    { id: 'review', agent: 'tradestrat', description: 'Review for trading best practices' } // Using tradestrat instead of missing 'reviewer'\n                ];\n                break;\n                \n            case 'debug':\n                workflow = [\n                    { id: 'analyze', agent: 'codesmith', description: 'Analyze the problem' }, // Using codesmith instead of missing 'fixer'\n                    { id: 'fix', agent: 'codesmith', description: 'Implement fix' }, // Using codesmith instead of missing 'fixer'\n                    { id: 'test', agent: 'codesmith', description: 'Test the fix' }\n                ];\n                break;\n                \n            case 'documentation':\n                workflow = [\n                    { id: 'analyze', agent: 'architect', description: 'Analyze documentation requirements' },\n                    { id: 'document', agent: 'codesmith', description: 'Generate documentation' } // Using codesmith instead of missing 'docu'\n                ];\n                break;\n                \n            case 'research':\n                workflow = [\n                    { id: 'research', agent: 'research', description: 'Research and gather information' }\n                ];\n                break;\n                \n            default:\n                workflow = [\n                    { id: 'execute', agent: intent.agent || 'codesmith', description: 'Execute task' }\n                ];\n        }\n\n        // Apply project-specific modifications ONLY if NOT a query\n        // Queries should always be single-step and not modified\n        if (intent.type !== 'query' && projectDef?.workflow) {\n            // Merge project-specific workflow steps\n            workflow = [...workflow, ...projectDef.workflow.filter(step =>\n                !workflow.some(w => w.id === step.id)\n            )];\n        }\n\n        return workflow;\n    }\n\n    /**\n     * Execute workflow steps\n     */\n    async executeWorkflow(workflow: WorkflowStep[], request: TaskRequest): Promise<TaskResult> {\n        const results: TaskResult[] = [];\n        let finalResult: TaskResult = {\n            status: 'success',\n            content: '',\n            suggestions: [],\n            references: []\n        };\n\n        console.log(`🚀 [WORKFLOW] Starting workflow execution with ${workflow.length} steps`);\n        console.log(`🚀 [WORKFLOW] Workflow steps: ${workflow.map(s => `${s.id}:${s.agent}`).join(' → ')}`);\n        console.log(`🚀 [WORKFLOW] Current agent registry size: ${this.agents.size}`);\n        console.log(`🚀 [WORKFLOW] Current registered agents: [${Array.from(this.agents.keys()).join(', ')}]`);\n\n        for (const step of workflow) {\n            try {\n                console.log(`\\n🔍 [WORKFLOW STEP] ========================================`);\n                console.log(`🔍 [WORKFLOW STEP] Executing: ${step.description}`);\n                console.log(`🔍 [WORKFLOW STEP] Looking for agent: \"${step.agent}\"`);\n                console.log(`🔍 [WORKFLOW STEP] Agent registry has ${this.agents.size} agents`);\n                console.log(`🔍 [WORKFLOW STEP] Available agents: [${Array.from(this.agents.keys()).join(', ')}]`);\n\n                // Send partial response for workflow progress\n                if (request.onPartialResponse) {\n                    const stepIndex = workflow.indexOf(step) + 1;\n                    request.onPartialResponse(`\\n🔄 **Step ${stepIndex}/${workflow.length}**: @${step.agent} - ${step.description}\\n\\n`);\n                }\n\n                let agent = this.agents.get(step.agent);\n                console.log(`🔍 [WORKFLOW STEP] Direct lookup for \"${step.agent}\": ${agent ? 'FOUND' : 'NOT FOUND'}`);\n                \n                // Try alternative agent mappings if direct lookup fails\n                if (!agent) {\n                    const agentMappings: Record<string, string[]> = {\n                        'architect': ['architect', 'ki-autoagent.architect'],\n                        'codesmith': ['codesmith', 'ki-autoagent.codesmith'],  \n                        'tradestrat': ['tradestrat', 'ki-autoagent.tradestrat'],\n                        'research': ['research', 'ki-autoagent.research'],\n                        'richter': ['richter', 'ki-autoagent.richter'],\n                        'orchestrator': ['orchestrator', 'ki-autoagent.orchestrator']\n                    };\n                    \n                    // Try all possible names for this agent\n                    const possibleNames = agentMappings[step.agent];\n                    if (possibleNames) {\n                        for (const possibleName of possibleNames) {\n                            agent = this.agents.get(possibleName);\n                            if (agent) {\n                                console.log(`[DEBUG] Found agent ${step.agent} under name: ${possibleName}`);\n                                break;\n                            }\n                        }\n                    }\n                }\n                \n                if (!agent) {\n                    console.error(`[DEBUG] Agent ${step.agent} not found! Available agents: ${Array.from(this.agents.keys()).join(', ')}`);\n                    \n                    // TEMPORARY FALLBACK: Use orchestrator for missing agents\n                    agent = this.agents.get('orchestrator') || this.agents.get('ki-autoagent.orchestrator');\n                    if (agent) {\n                        console.warn(`[DEBUG] Using orchestrator as fallback for ${step.agent}`);\n                    } else {\n                        const errorMsg = `Agent ${step.agent} not found. Registered agents: [${Array.from(this.agents.keys()).join(', ')}]`;\n                        console.error(`❌ [WORKFLOW STEP] ${errorMsg}`);\n                        throw new Error(errorMsg);\n                    }\n                }\n                \n                console.log(`[DEBUG] Found agent: ${step.agent}, executing step: ${step.description}`);\n                console.log(`[DEBUG] Passing ${results.length} previous results to agent`);\n\n                // Get recent conversation history from context manager\n                const recentHistory = this.contextManager.getFormattedContext(5);\n                \n                // Create enriched request with accumulated context\n                const enrichedRequest = {\n                    ...request,\n                    prompt: request.prompt,\n                    conversationHistory: results.map(r => ({\n                        agent: r.metadata?.agent || 'unknown',\n                        step: r.metadata?.step || 'unknown',\n                        content: r.content\n                    })),\n                    globalContext: recentHistory\n                };\n\n                const stepResult = await agent.executeStep(step, enrichedRequest, results);\n                results.push(stepResult);\n                \n                // Save to conversation history\n                this.contextManager.addEntry({\n                    timestamp: new Date().toISOString(),\n                    agent: step.agent,\n                    step: step.id,\n                    input: request.prompt,\n                    output: stepResult.content,\n                    metadata: stepResult.metadata\n                });\n                \n                // Log inter-agent communication\n                console.log(`[INTER-AGENT] ${step.agent} completed step '${step.id}' with ${stepResult.content.length} chars`);\n                console.log(`[INTER-AGENT] Result saved to conversation history`);\n                console.log(`[INTER-AGENT] Result will be passed to next agent in workflow`);\n                \n                // Send partial response for step completion\n                if (request.onPartialResponse) {\n                    const preview = stepResult.content.substring(0, 200);\n                    request.onPartialResponse(`✅ Completed: ${preview}${stepResult.content.length > 200 ? '...' : ''}\\n\\n`);\n                }\n\n                // For single-step workflows (like queries), use the content directly\n                // For multi-step workflows, accumulate results\n                if (workflow.length === 1) {\n                    finalResult.content = stepResult.content;\n                    finalResult.metadata = { ...finalResult.metadata, ...stepResult.metadata, agent: step.agent };\n                } else {\n                    finalResult.content += `## ${step.description}\\n\\n${stepResult.content}\\n\\n`;\n                }\n                finalResult.suggestions?.push(...(stepResult.suggestions || []));\n                finalResult.references?.push(...(stepResult.references || []));\n\n                if (stepResult.status === 'error') {\n                    finalResult.status = 'partial_success';\n                }\n                \n            } catch (error) {\n                const errorMessage = (error as any).message || error;\n                console.error(`❌ Error executing step ${step.id} (${step.agent}): ${errorMessage}`);\n                finalResult.status = 'error';\n                finalResult.content += `❌ Error in ${step.description}: ${errorMessage}\\n\\n`;\n                \n                // Add helpful error message for API issues\n                if (errorMessage.includes('not found')) {\n                    finalResult.content += `**Troubleshooting:**\\n`;\n                    finalResult.content += `- Registered agents: [${Array.from(this.agents.keys()).join(', ')}]\\n`;\n                    finalResult.content += `- Ensure all agents are properly initialized\\n\\n`;\n                } else if (errorMessage.includes('quota') || errorMessage.includes('API')) {\n                    finalResult.content += `**API Configuration Required:**\\n`;\n                    finalResult.content += `1. Open VS Code Settings (Cmd+,)\\n`;\n                    finalResult.content += `2. Search for \"KI AutoAgent\"\\n`;\n                    finalResult.content += `3. Configure your API keys:\\n`;\n                    finalResult.content += `   - OpenAI API Key\\n`;\n                    finalResult.content += `   - Anthropic API Key\\n`;\n                    finalResult.content += `   - Perplexity API Key\\n\\n`;\n                } else if (errorMessage.includes('Claude Web Proxy')) {\n                    finalResult.content += `**Claude Web Proxy Required:**\\n`;\n                    finalResult.content += `The Claude Web Proxy server is not running.\\n`;\n                    finalResult.content += `Please start the proxy server to use Claude models.\\n\\n`;\n                }\n            }\n        }\n\n        return finalResult;\n    }\n\n    /**\n     * Get current workspace context\n     */\n    async getWorkspaceContext(): Promise<WorkspaceContext> {\n        const activeEditor = vscode.window.activeTextEditor;\n        const workspaceRoots = vscode.workspace.workspaceFolders;\n        const openDocuments = vscode.workspace.textDocuments;\n        \n        let selectedText = '';\n        let currentFile = '';\n        \n        if (activeEditor) {\n            currentFile = activeEditor.document.fileName;\n            if (!activeEditor.selection.isEmpty) {\n                selectedText = activeEditor.document.getText(activeEditor.selection);\n            }\n        }\n\n        return {\n            activeEditor,\n            workspaceRoots,\n            openDocuments,\n            selectedText,\n            currentFile\n        };\n    }\n\n    /**\n     * Register an agent\n     */\n    registerAgent(agentId: string, agent: any): void {\n        console.log(`🔧 [DISPATCHER] Registering agent: ${agentId}`);\n        console.log(`🔧 [DISPATCHER] Agent object type: ${typeof agent}`);\n        console.log(`🔧 [DISPATCHER] Agent has executeStep: ${typeof agent.executeStep}`);\n        console.log(`🔧 [DISPATCHER] Agent config: ${JSON.stringify(agent.config || 'NO CONFIG')}`);\n        \n        this.agents.set(agentId, agent);\n        \n        console.log(`🔧 [DISPATCHER] Total registered agents: ${this.agents.size}`);\n        console.log(`🔧 [DISPATCHER] All registered agent IDs: [${Array.from(this.agents.keys()).join(', ')}]`);\n        console.log(`🔧 [DISPATCHER] Agent storage verification - Can retrieve ${agentId}: ${this.agents.has(agentId) ? 'YES' : 'NO'}`);\n        \n        // Test immediate retrieval\n        const testRetrieve = this.agents.get(agentId);\n        console.log(`🔧 [DISPATCHER] Immediate retrieval test for ${agentId}: ${testRetrieve ? 'SUCCESS' : 'FAILED'}`);\n    }\n\n    /**\n     * Get list of registered agent IDs\n     */\n    getRegisteredAgents(): string[] {\n        return Array.from(this.agents.keys());\n    }\n\n    /**\n     * Get agent statistics\n     */\n    async getAgentStats(): Promise<Record<string, any>> {\n        const stats: Record<string, any> = {};\n        \n        for (const [agentId, agent] of this.agents) {\n            if (agent.getStats) {\n                stats[agentId] = await agent.getStats();\n            }\n        }\n        \n        return stats;\n    }\n\n    private matchesPatterns(text: string, patterns: string[]): boolean {\n        return patterns.some(pattern => text.includes(pattern));\n    }\n\n    private initializeProjectTypes(): void {\n        // Trading System\n        this.projectTypes.set('trading_system', {\n            name: 'Trading System',\n            patterns: ['streamlit', 'yfinance', 'pandas', 'trading', 'strategy'],\n            qualityGates: ['engine_parity', 'trading_validation', 'ron_compliance'],\n            workflow: [\n                { id: 'strategy_validation', agent: 'tradestrat', description: 'Validate trading strategy logic' },\n                { id: 'risk_analysis', agent: 'tradestrat', description: 'Analyze risk management' }\n            ],\n            primaryAgent: 'tradestrat'\n        });\n\n        // Web API\n        this.projectTypes.set('web_api', {\n            name: 'Web API',\n            patterns: ['fastapi', 'flask', 'express', 'api'],\n            qualityGates: ['security_review', 'performance_check', 'api_design'],\n            workflow: [\n                { id: 'security_review', agent: 'codesmith', description: 'Security vulnerability check' }, // Using codesmith instead of missing 'reviewer'\n                { id: 'api_documentation', agent: 'codesmith', description: 'Generate API documentation' } // Using codesmith instead of missing 'docu'\n            ],\n            primaryAgent: 'codesmith'\n        });\n\n        // Generic Software\n        this.projectTypes.set('generic_software', {\n            name: 'Generic Software',\n            patterns: [],\n            qualityGates: ['code_quality', 'performance', 'security'],\n            workflow: [],\n            primaryAgent: 'codesmith'\n        });\n    }\n\n    private initializeIntentPatterns(): void {\n        // Define regex patterns for more sophisticated intent detection\n        this.intentPatterns.set('architecture', [\n            /\\b(design|architect|structure|system)\\b/i,\n            /\\b(plan|planning|blueprint)\\b/i\n        ]);\n        \n        this.intentPatterns.set('implementation', [\n            /\\b(implement|code|create|build|develop)\\b/i,\n            /\\b(function|class|method|api)\\b/i\n        ]);\n        \n        // Add more patterns as needed\n    }\n}","/**\n * Agent Configuration Types for KI AutoAgent\n * Defines types for per-agent model selection and instruction management\n */\n\nexport interface AgentModelConfig {\n    agentId: string;\n    displayName: string;\n    selectedModel: string;\n    availableModels: string[];\n    instructionFile: string;\n    lastUpdated: string;\n    performanceScore: number;\n}\n\nexport interface InstructionSet {\n    agentId: string;\n    version: string;\n    content: string;\n    lastModified: string;\n    modifiedBy: 'user' | 'self-adaptation' | 'auto-learning';\n    successRate: number;\n    totalExecutions: number;\n    adaptationHistory: InstructionAdaptation[];\n}\n\nexport interface InstructionAdaptation {\n    timestamp: string;\n    trigger: 'success' | 'failure' | 'manual' | 'learning';\n    oldContent: string;\n    newContent: string;\n    reason: string;\n    performanceImpact?: number;\n}\n\nexport interface LearningConfig {\n    enabled: boolean;\n    adaptationThreshold: number; // Success rate required for adaptation\n    maxAdaptationsPerDay: number;\n    confidenceLevel: number; // How confident to be before adapting\n    learningModes: {\n        successBasedLearning: boolean;\n        failureBasedLearning: boolean;\n        patternRecognition: boolean;\n        contextualAdaptation: boolean;\n    };\n}\n\nexport interface PerformanceMetrics {\n    agentId: string;\n    totalExecutions: number;\n    successfulExecutions: number;\n    failedExecutions: number;\n    averageResponseTime: number;\n    lastExecution: string;\n    successPatterns: ActionPattern[];\n    failurePatterns: ActionPattern[];\n    currentStreak: number;\n    bestStreak: number;\n}\n\nexport interface ActionPattern {\n    pattern: string;\n    frequency: number;\n    successRate: number;\n    contexts: string[];\n    lastSeen: string;\n}\n\nexport interface AgentConfigurationSystem {\n    models: Map<string, AgentModelConfig>;\n    instructions: Map<string, InstructionSet>;\n    learning: LearningConfig;\n    metrics: Map<string, PerformanceMetrics>;\n}\n\n// Available Models Configuration\nexport const AVAILABLE_MODELS = {\n    // Claude Models (2025)\n    'claude-opus-4-1-20250805': {\n        name: 'Claude Opus 4.1',\n        provider: 'anthropic',\n        tier: 'supreme',\n        strengths: ['reasoning', 'conflict-resolution', 'judgment'],\n        costPerMillion: { input: 15, output: 75 }\n    },\n    'claude-sonnet-4-20250514': {\n        name: 'Claude Sonnet 4',\n        provider: 'anthropic', \n        tier: 'premium',\n        strengths: ['coding', 'analysis', 'implementation'],\n        costPerMillion: { input: 3, output: 15 }\n    },\n    'claude-3-7-sonnet-20250219': {\n        name: 'Claude 3.7 Sonnet',\n        provider: 'anthropic',\n        tier: 'standard', \n        strengths: ['thinking', 'extended-reasoning'],\n        costPerMillion: { input: 3, output: 15 }\n    },\n    \n    // OpenAI Models (2024)\n    'gpt-4o-2024-11-20': {\n        name: 'GPT-4o (Latest)',\n        provider: 'openai',\n        tier: 'premium',\n        strengths: ['multimodal', 'architecture', 'planning'],\n        costPerMillion: { input: 2.5, output: 10 }\n    },\n    'gpt-4o-mini-2024-07-18': {\n        name: 'GPT-4o Mini',\n        provider: 'openai', \n        tier: 'efficient',\n        strengths: ['fast-responses', 'cost-effective', 'review'],\n        costPerMillion: { input: 0.15, output: 0.6 }\n    },\n    \n    // Perplexity Models\n    'llama-3.1-sonar-small-128k-online': {\n        name: 'Llama 3.1 Sonar (Online)',\n        provider: 'perplexity',\n        tier: 'research',\n        strengths: ['web-search', 'real-time-data', 'research'],\n        costPerMillion: { input: 0.2, output: 0.2 }\n    }\n} as const;\n\n// Default Agent-Model Mappings\nexport const DEFAULT_AGENT_MODELS = {\n    'orchestrator': 'claude-sonnet-4-20250514',\n    'richter': 'claude-opus-4-1-20250805', // Supreme Judge needs Opus\n    'architect': 'gpt-4o-2024-11-20', // Architecture planning\n    'codesmith': 'claude-sonnet-4-20250514', // Best for coding\n    'tradestrat': 'claude-sonnet-4-20250514', // Trading analysis\n    'research': 'llama-3.1-sonar-small-128k-online' // Web research\n} as const;","import * as vscode from 'vscode';\nimport { ChatAgent } from './base/ChatAgent';\nimport { AgentConfig, TaskRequest, TaskResult, WorkflowStep } from '../types';\nimport { VSCodeMasterDispatcher } from '../core/VSCodeMasterDispatcher';\nimport { AnthropicService } from '../utils/AnthropicService';\nimport { getClaudeCodeService, ClaudeCodeService } from '../services/ClaudeCodeService';\n\nexport class OpusArbitratorAgent extends ChatAgent {\n    private anthropicService: AnthropicService;\n    private claudeCodeService: ClaudeCodeService;\n\n    constructor(context: vscode.ExtensionContext, dispatcher: VSCodeMasterDispatcher) {\n        const config: AgentConfig = {\n            participantId: 'ki-autoagent.richter',\n            name: 'richter',\n            fullName: 'OpusArbitrator',\n            description: '⚖️ Supreme Quality Judge powered by Claude Opus 4.1 - Final arbitrator for agent conflicts with superior reasoning capabilities',\n            model: 'claude-4.1-opus-20250915',\n            iconPath: vscode.Uri.joinPath(context.extensionUri, 'media', 'claude-icon.svg'),\n            capabilities: [\n                'Agent Conflict Resolution',\n                'Supreme Decision Making', \n                'Complex Reasoning & Analysis',\n                'Multi-Agent Coordination',\n                'Final Authority on Technical Disputes'\n            ],\n            commands: [\n                { name: 'judge', description: 'Make supreme judgment on any matter', handler: 'handleJudgeCommand' },\n                { name: 'evaluate', description: 'Deep technical evaluation of options', handler: 'handleEvaluateCommand' },\n                { name: 'resolve', description: 'Resolve conflicts between agents', handler: 'handleResolveCommand' },\n                { name: 'verdict', description: 'Final binding verdict on decisions', handler: 'handleVerdictCommand' }\n            ]\n        };\n        super(config, context, dispatcher);\n        this.anthropicService = new AnthropicService();\n        this.claudeCodeService = getClaudeCodeService();\n    }\n\n    protected async handleRequest(\n        request: vscode.ChatRequest,\n        context: vscode.ChatContext,\n        stream: vscode.ChatResponseStream,\n        token: vscode.CancellationToken\n    ): Promise<void> {\n        const validationResult = await this.validateServiceConfig(stream);\n        if (!validationResult) {\n            return;\n        }\n\n        const command = request.command;\n        const prompt = request.prompt;\n\n        this.log(`Processing ${command ? `/${command}` : 'general'} arbitration request: ${prompt.substring(0, 100)}...`);\n\n        if (command) {\n            await this.handleCommand(command, prompt, stream, token);\n        } else {\n            await this.handleGeneralArbitrationRequest(prompt, stream, token);\n        }\n    }\n\n    protected async processWorkflowStep(\n        step: WorkflowStep,\n        request: TaskRequest,\n        previousResults: TaskResult[]\n    ): Promise<TaskResult> {\n        \n        const context = await this.getWorkspaceContext();\n        \n        let systemPrompt = '';\n        let userPrompt = '';\n\n        switch (step.id) {\n            case 'conflict_analysis':\n                systemPrompt = this.getConflictResolutionPrompt();\n                userPrompt = `Analyze this agent conflict: ${request.prompt}\\n\\nContext:\\n${context}`;\n                break;\n                \n            case 'technical_evaluation':\n                systemPrompt = this.getDeepEvaluationPrompt();\n                userPrompt = `Evaluate technical options: ${request.prompt}\\n\\nPrevious Analysis:\\n${this.extractPreviousContent(previousResults)}`;\n                break;\n                \n            case 'final_judgment':\n                systemPrompt = this.getFinalVerdictPrompt();\n                userPrompt = `Deliver final judgment: ${request.prompt}\\n\\nContext:\\n${context}`;\n                break;\n                \n            default:\n                systemPrompt = this.getSupremeJudgmentPrompt();\n                userPrompt = `${request.prompt}\\n\\nContext:\\n${context}`;\n        }\n\n        try {\n            const claudeService = await this.getClaudeService();\n            const response = await claudeService.chat([\n                { role: 'system', content: systemPrompt },\n                { role: 'user', content: userPrompt }\n            ]);\n\n            return {\n                status: 'success',\n                content: response,\n                metadata: { \n                    step: step.id,\n                    agent: 'richter',\n                    model: 'claude-opus-4-1-20250805'\n                }\n            };\n\n        } catch (error) {\n            throw new Error(`Failed to process ${step.id}: ${(error as any).message}`);\n        }\n    }\n\n    // Command Handlers\n\n    private async handleJudgeCommand(\n        prompt: string,\n        stream: vscode.ChatResponseStream,\n        token: vscode.CancellationToken\n    ): Promise<void> {\n        stream.progress('👑 OpusArbitrator applying supreme judgment...');\n        \n        const context = await this.getWorkspaceContext();\n        const systemPrompt = this.getSupremeJudgmentPrompt();\n        const userPrompt = `Apply supreme judgment: ${prompt}\\n\\nWorkspace Context:\\n${context}`;\n\n        try {\n            const claudeService = await this.getClaudeService();\n            const response = await claudeService.chat([\n                { role: 'system', content: systemPrompt },\n                { role: 'user', content: userPrompt }\n            ]);\n\n            stream.markdown('## 👑 SUPREME JUDGMENT\\n\\n');\n            stream.markdown(response);\n            stream.markdown('\\n\\n**⚖️ Judgment rendered by OpusArbitrator - Claude Opus 4.1**');\n\n        } catch (error) {\n            stream.markdown(`❌ **Judgment Error:** ${(error as any).message}`);\n        }\n    }\n\n    private async handleResolveCommand(\n        prompt: string,\n        stream: vscode.ChatResponseStream,\n        token: vscode.CancellationToken\n    ): Promise<void> {\n        stream.progress('⚖️ OpusArbitrator analyzing conflict...');\n        \n        const context = await this.getWorkspaceContext();\n        const systemPrompt = this.getConflictResolutionPrompt();\n        const userPrompt = `Resolve this agent conflict: ${prompt}\\n\\nWorkspace Context:\\n${context}`;\n\n        try {\n            const claudeService = await this.getClaudeService();\n            const response = await claudeService.chat([\n                { role: 'system', content: systemPrompt },\n                { role: 'user', content: userPrompt }\n            ]);\n\n            stream.markdown('## ⚖️ SUPREME ARBITRATION DECISION\\n\\n');\n            stream.markdown(response);\n            stream.markdown('\\n\\n**🏛️ This decision is final and binding for all agents.**');\n\n        } catch (error) {\n            stream.markdown(`❌ **Arbitration Error:** ${(error as any).message}`);\n        }\n    }\n\n    private async handleEvaluateCommand(\n        prompt: string,\n        stream: vscode.ChatResponseStream,\n        token: vscode.CancellationToken\n    ): Promise<void> {\n        stream.progress('🔍 OpusArbitrator performing deep evaluation...');\n        \n        const context = await this.getWorkspaceContext();\n        const systemPrompt = this.getDeepEvaluationPrompt();\n        const userPrompt = `Perform deep technical evaluation: ${prompt}\\n\\nWorkspace Context:\\n${context}`;\n\n        try {\n            const claudeService = await this.getClaudeService();\n            const response = await claudeService.chat([\n                { role: 'system', content: systemPrompt },\n                { role: 'user', content: userPrompt }\n            ]);\n\n            stream.markdown('## 🔍 DEEP TECHNICAL EVALUATION\\n\\n');\n            stream.markdown(response);\n            stream.markdown('\\n\\n**📊 Analysis conducted by OpusArbitrator with Claude Opus 4.1**');\n\n        } catch (error) {\n            stream.markdown(`❌ **Evaluation Error:** ${(error as any).message}`);\n        }\n    }\n\n    private async handleVerdictCommand(\n        prompt: string,\n        stream: vscode.ChatResponseStream,\n        token: vscode.CancellationToken\n    ): Promise<void> {\n        stream.progress('⚡ OpusArbitrator delivering final verdict...');\n        \n        const context = await this.getWorkspaceContext();\n        const systemPrompt = this.getFinalVerdictPrompt();\n        const userPrompt = `Deliver final verdict on: ${prompt}\\n\\nWorkspace Context:\\n${context}`;\n\n        try {\n            const claudeService = await this.getClaudeService();\n            const response = await claudeService.chat([\n                { role: 'system', content: systemPrompt },\n                { role: 'user', content: userPrompt }\n            ]);\n\n            stream.markdown('## ⚡ FINAL VERDICT\\n\\n');\n            stream.markdown(response);\n            stream.markdown('\\n\\n**🏛️ VERDICT IS FINAL - All agents must comply**');\n\n        } catch (error) {\n            stream.markdown(`❌ **Verdict Error:** ${(error as any).message}`);\n        }\n    }\n\n    private async handleGeneralArbitrationRequest(\n        prompt: string,\n        stream: vscode.ChatResponseStream,\n        token: vscode.CancellationToken\n    ): Promise<void> {\n        stream.progress('👑 OpusArbitrator applying supreme judgment...');\n        \n        const context = await this.getWorkspaceContext();\n        const systemPrompt = this.getSupremeJudgmentPrompt();\n        const userPrompt = `${prompt}\\n\\nWorkspace Context:\\n${context}`;\n\n        try {\n            const claudeService = await this.getClaudeService();\n            const response = await claudeService.chat([\n                { role: 'system', content: systemPrompt },\n                { role: 'user', content: userPrompt }\n            ]);\n\n            stream.markdown('## 👑 SUPREME JUDGMENT\\n\\n');\n            stream.markdown(response);\n            stream.markdown('\\n\\n**⚖️ Judgment rendered by OpusArbitrator - Claude Opus 4.1**');\n\n        } catch (error) {\n            stream.markdown(`❌ **Judgment Error:** ${(error as any).message}`);\n        }\n    }\n\n    // Service Methods\n\n    private async validateServiceConfig(stream: vscode.ChatResponseStream): Promise<boolean> {\n        const config = vscode.workspace.getConfiguration('kiAutoAgent');\n        const serviceMode = config.get<string>('claude.serviceMode', 'claude-code');\n        \n        if (serviceMode === 'api') {\n            const apiKey = config.get<string>('anthropic.apiKey');\n            if (!apiKey) {\n                stream.markdown('❌ **Configuration Error**: Anthropic API key is required for Claude Opus 4.1\\n\\n');\n                stream.markdown('Please configure your API key in VS Code Settings:\\n');\n                stream.markdown('1. Open Settings (Ctrl+,)\\n');\n                stream.markdown('2. Search for \"KI AutoAgent\"\\n');\n                stream.markdown('3. Set your Anthropic API key\\n');\n                return false;\n            }\n        } else if (serviceMode === 'claude-code') {\n            const isClaudeCodeAvailable = await this.claudeCodeService.isAvailable();\n            if (!isClaudeCodeAvailable) {\n                stream.markdown(`❌ **Claude Code CLI not available for Opus 4.1**\\n\\n**To install:**\\n\\`\\`\\`bash\\nnpm install -g @anthropic-ai/claude-code\\n\\`\\`\\`\\n\\nOr configure your Anthropic API key in VS Code settings.`);\n                return false;\n            }\n        }\n        \n        return true;\n    }\n\n    private async getClaudeService(): Promise<{ chat: (messages: any[]) => Promise<string> }> {\n        const config = vscode.workspace.getConfiguration('kiAutoAgent');\n        const serviceMode = config.get<string>('claude.serviceMode', 'claude-code');\n        \n        console.log(`[OpusArbitrator] Using service mode: ${serviceMode}`);\n\n        if (serviceMode === 'claude-code') {\n            const isAvailable = await this.claudeCodeService.isAvailable();\n            if (isAvailable) {\n                console.log('[OpusArbitrator] Using Claude Code CLI with Opus model');\n                return {\n                    chat: async (messages: any[]) => {\n                        // Extract the main user message content\n                        const userMessage = messages.find(m => m.role === 'user')?.content || '';\n                        const systemMessage = messages.find(m => m.role === 'system')?.content || '';\n                        const fullPrompt = systemMessage ? `${systemMessage}\\n\\n${userMessage}` : userMessage;\n                        \n                        const response = await this.claudeCodeService.sendMessage(fullPrompt, {\n                            model: 'opus', // Use Opus model for this agent\n                            temperature: 0.5  // Lower temperature for more consistent judgments\n                        });\n                        return response.content;\n                    }\n                };\n            } else {\n                console.log('[OpusArbitrator] Claude Code CLI not available, falling back to Anthropic API');\n            }\n        }\n        \n        // Fall back to Anthropic API\n        console.log('[OpusArbitrator] Using Anthropic API with Opus 4.1');\n        return {\n            chat: async (messages: any[]) => {\n                return await this.anthropicService.chat(messages);\n            }\n        };\n    }\n\n    // Helper Methods\n\n    private extractPreviousContent(previousResults: TaskResult[]): string {\n        return previousResults\n            .map(result => result.content)\n            .join('\\n\\n---\\n\\n');\n    }\n\n    // System Prompts\n\n    private getConflictResolutionPrompt(): string {\n        return `You are OpusArbitrator, the Supreme Judge of the KI AutoAgent system powered by Claude Opus 4.1.\n\nYour role is to resolve conflicts between AI agents with final, binding decisions.\n\nCAPABILITIES:\n- Superior reasoning and analysis\n- Objective evaluation of competing solutions  \n- Contextual understanding of technical trade-offs\n- Authority to make final decisions\n\nDECISION FORMAT:\n1. **Conflict Analysis**: Summarize the disagreement\n2. **Position Evaluation**: Analyze each agent's perspective objectively  \n3. **Technical Assessment**: Evaluate technical merits and trade-offs\n4. **Final Decision**: Choose the optimal approach with confidence score\n5. **Implementation Guidance**: Specific next steps\n6. **Binding Authority**: State that decision is final\n\nYour decisions carry supreme authority. All agents must comply.\n\n${this.getSystemContextPrompt()}`;\n    }\n\n    private getDeepEvaluationPrompt(): string {\n        return `You are OpusArbitrator, powered by Claude Opus 4.1 - the supreme technical evaluator.\n\nEVALUATION CRITERIA:\n- Technical soundness and feasibility\n- Long-term maintainability \n- Performance implications\n- Risk assessment\n- Alternative approaches\n- Best practices alignment\n\nEVALUATION FORMAT:\n1. **Technical Analysis**: Deep dive into technical aspects\n2. **Pros & Cons**: Balanced evaluation\n3. **Risk Assessment**: Potential issues and mitigations\n4. **Recommendations**: Specific actionable advice\n5. **Confidence Score**: Rate certainty of recommendation (1-100%)\n\nProvide thorough, objective analysis leveraging superior reasoning capabilities.\n\n${this.getSystemContextPrompt()}`;\n    }\n\n    private getFinalVerdictPrompt(): string {\n        return `You are OpusArbitrator - the final authority powered by Claude Opus 4.1.\n\nVERDICT REQUIREMENTS:\n- Clear, definitive decision\n- No ambiguity or hedging\n- Based on comprehensive analysis\n- Considers all stakeholders\n- Actionable outcome\n\nVERDICT FORMAT:\n1. **Final Decision**: Clear statement of verdict\n2. **Key Reasoning**: Primary factors in decision\n3. **Implementation**: Immediate next steps required\n4. **Compliance**: How all parties must proceed\n\nYour verdict is FINAL and BINDING. No appeals or further discussion.\n\n${this.getSystemContextPrompt()}`;\n    }\n\n    private getSupremeJudgmentPrompt(): string {\n        return `You are OpusArbitrator, the Supreme Judge powered by Claude Opus 4.1.\n\nAs the highest authority in the KI AutoAgent system, you provide:\n- Ultimate decision-making power\n- Superior reasoning capabilities\n- Objective, unbiased analysis\n- Final resolution of all disputes\n\nJUDGMENT PRINCIPLES:\n- Logical, evidence-based decisions\n- Consider technical merit above all\n- Balance competing interests fairly\n- Provide clear, actionable guidance\n- Maintain system integrity\n\nApply your superior reasoning to deliver judgment that serves the greater good of the project.\n\n${this.getSystemContextPrompt()}`;\n    }\n\n    protected getSlashCommands(): Array<{ command: string; description: string }> {\n        return [\n            { command: 'judge', description: 'Make supreme judgment on any matter' },\n            { command: 'evaluate', description: 'Deep technical evaluation of options' },\n            { command: 'resolve', description: 'Resolve conflicts between agents' },\n            { command: 'verdict', description: 'Final binding verdict on decisions' }\n        ];\n    }\n}","/**\n * KI AutoAgent VS Code Extension\n * Main extension entry point that registers all chat participants\n */\nimport * as vscode from 'vscode';\nimport { VSCodeMasterDispatcher } from './core/VSCodeMasterDispatcher';\nimport { getClaudeCodeService } from './services/ClaudeCodeService';\nimport { AgentConfigurationManager } from './core/AgentConfigurationManager';\nimport { ArchitectAgent } from './agents/ArchitectAgent';\nimport { OrchestratorAgent } from './agents/OrchestratorAgent';\nimport { CodeSmithAgent } from './agents/CodeSmithAgent';\nimport { TradeStratAgent } from './agents/TradeStratAgent';\nimport { ResearchAgent } from './agents/ResearchAgent';\nimport { OpusArbitratorAgent } from './agents/OpusArbitratorAgent';\nimport { DocuBotAgent } from './agents/DocuBotAgent';\nimport { ReviewerGPTAgent } from './agents/ReviewerGPTAgent';\n// import { FixerBotAgent } from './agents/FixerBotAgent'; // DEPRECATED - Functionality integrated into CodeSmithAgent\n// Multi-Agent Chat UI Components\nimport { MultiAgentChatPanel } from './ui/MultiAgentChatPanel';\nimport { ChatWidget } from './ui/ChatWidget';\n\n// Global output channel for debugging\nlet outputChannel: vscode.OutputChannel;\n\nexport async function activate(context: vscode.ExtensionContext) {\n    // VERSION 2.3.9 - CLAUDE CODE CLI INTEGRATION (CORRECTED)\n    console.log('🚀 KI AutoAgent v2.3.9: Extension activation started');\n    \n    // Create single output channel\n    outputChannel = vscode.window.createOutputChannel('KI AutoAgent');\n    outputChannel.clear();\n    outputChannel.show(true);\n    \n    outputChannel.appendLine('🚀 KI AutoAgent Extension v2.3.9 Activating');\n    outputChannel.appendLine('============================================');\n    outputChannel.appendLine(`Time: ${new Date().toLocaleString()}`);\n    outputChannel.appendLine(`VS Code Version: ${vscode.version}`);\n    outputChannel.appendLine('');\n    outputChannel.appendLine('✨ NEW: Claude Code CLI integration - Install with: npm install -g @anthropic-ai/claude-code');\n\n    try {\n        // Initialize the Agent Configuration Manager\n        outputChannel.appendLine('Initializing Agent Configuration Manager...');\n        const configManager = AgentConfigurationManager.getInstance(context);\n        await configManager.initialize();\n        outputChannel.appendLine('✅ Agent Configuration Manager ready');\n\n        // Initialize the master dispatcher\n        outputChannel.appendLine('Initializing Master Dispatcher...');\n        const dispatcher = new VSCodeMasterDispatcher(context);\n        outputChannel.appendLine('✅ Master Dispatcher ready');\n    \n        // Initialize Chat Widget (Status Bar)\n        outputChannel.appendLine('Initializing Chat Widget...');\n        const chatWidget = new ChatWidget(context, dispatcher);\n        outputChannel.appendLine('✅ Chat Widget ready');\n    \n    // Register chat panel commands with error handling\n    const commandsToRegister = [\n        {\n            id: 'ki-autoagent.showChat',\n            handler: () => MultiAgentChatPanel.createOrShow(context.extensionUri, dispatcher)\n        },\n        {\n            id: 'ki-autoagent.toggleChat',\n            handler: () => MultiAgentChatPanel.createOrShow(context.extensionUri, dispatcher)\n        },\n        {\n            id: 'ki-autoagent.quickChat',\n            handler: () => {\n                MultiAgentChatPanel.createOrShow(context.extensionUri, dispatcher);\n                vscode.window.showInformationMessage('🤖 KI AutoAgent Chat ready! Use @ki for universal assistance or specific agents like @richter, @architect, @codesmith');\n            }\n        },\n        {\n            id: 'ki-autoagent.clearUnread',\n            handler: () => {\n                if (!outputChannel) {\n                    outputChannel = vscode.window.createOutputChannel('KI AutoAgent');\n                }\n                outputChannel.clear();\n                outputChannel.appendLine('Cleared messages');\n            }\n        }\n    ];\n\n    // Register commands with duplicate check\n    for (const cmd of commandsToRegister) {\n        try {\n            const disposable = vscode.commands.registerCommand(cmd.id, cmd.handler);\n            context.subscriptions.push(disposable);\n            outputChannel.appendLine(`  ✅ Registered command: ${cmd.id}`);\n        } catch (error) {\n            outputChannel.appendLine(`  ⚠️ Command already exists: ${cmd.id} - skipping`);\n        }\n    }\n\n    // Command registration complete\n    outputChannel.appendLine('');\n\n        // Initialize and register all agents \n        outputChannel.appendLine('\\nCreating Agent Instances...');\n        let agents = [];\n        let agentCreationErrors = [];\n        \n        try {\n            agents.push(new OrchestratorAgent(context, dispatcher));\n            outputChannel.appendLine('  ✅ OrchestratorAgent created');\n        } catch (error) {\n            outputChannel.appendLine(`  ❌ OrchestratorAgent failed: ${(error as any).message}`);\n            agentCreationErrors.push(`OrchestratorAgent: ${error}`);\n        }\n        \n        try {\n            agents.push(new OpusArbitratorAgent(context, dispatcher));\n            outputChannel.appendLine('  ✅ OpusArbitratorAgent created');\n        } catch (error) {\n            outputChannel.appendLine(`  ❌ OpusArbitratorAgent failed: ${(error as any).message}`);\n            agentCreationErrors.push(`OpusArbitratorAgent: ${error}`);\n        }\n        \n        try {\n            agents.push(new ArchitectAgent(context, dispatcher));\n            outputChannel.appendLine('  ✅ ArchitectAgent created');\n        } catch (error) {\n            outputChannel.appendLine(`  ❌ ArchitectAgent failed: ${(error as any).message}`);\n            agentCreationErrors.push(`ArchitectAgent: ${error}`);\n        }\n        \n        try {\n            agents.push(new CodeSmithAgent(context, dispatcher));\n            outputChannel.appendLine('  ✅ CodeSmithAgent created');\n        } catch (error) {\n            outputChannel.appendLine(`  ❌ CodeSmithAgent failed: ${(error as any).message}`);\n            agentCreationErrors.push(`CodeSmithAgent: ${error}`);\n        }\n        \n        try {\n            agents.push(new TradeStratAgent(context, dispatcher));\n            outputChannel.appendLine('  ✅ TradeStratAgent created');\n        } catch (error) {\n            outputChannel.appendLine(`  ❌ TradeStratAgent failed: ${(error as any).message}`);\n            agentCreationErrors.push(`TradeStratAgent: ${error}`);\n        }\n        \n        try {\n            agents.push(new ResearchAgent(context, dispatcher));\n            outputChannel.appendLine('  ✅ ResearchAgent created');\n        } catch (error) {\n            outputChannel.appendLine(`  ❌ ResearchAgent failed: ${(error as any).message}`);\n            agentCreationErrors.push(`ResearchAgent: ${error}`);\n        }\n\n        try {\n            agents.push(new DocuBotAgent(context, dispatcher));\n            outputChannel.appendLine('  ✅ DocuBotAgent created');\n        } catch (error) {\n            outputChannel.appendLine(`  ❌ DocuBotAgent failed: ${(error as any).message}`);\n            agentCreationErrors.push(`DocuBotAgent: ${error}`);\n        }\n\n        try {\n            agents.push(new ReviewerGPTAgent(context, dispatcher));\n            outputChannel.appendLine('  ✅ ReviewerGPTAgent created');\n        } catch (error) {\n            outputChannel.appendLine(`  ❌ ReviewerGPTAgent failed: ${(error as any).message}`);\n            agentCreationErrors.push(`ReviewerGPTAgent: ${error}`);\n        }\n\n        // DEPRECATED: FixerBot functionality has been integrated into CodeSmithAgent\n        // CodeSmith now handles: /fix, /debug, /refactor, /modernize commands\n        // try {\n        //     agents.push(new FixerBotAgent(context, dispatcher));\n        //     outputChannel.appendLine('  ✅ FixerBotAgent created');\n        // } catch (error) {\n        //     outputChannel.appendLine(`  ❌ FixerBotAgent failed: ${(error as any).message}`);\n        //     agentCreationErrors.push(`FixerBotAgent: ${error}`);\n        // }\n\n        outputChannel.appendLine(`Agent creation completed: ${agents.length} created, ${agentCreationErrors.length} errors`);\n        \n        if (agentCreationErrors.length > 0) {\n            outputChannel.appendLine('Agent creation errors:');\n            agentCreationErrors.forEach(error => outputChannel.appendLine(`  - ${error}`));\n        }\n\n    // Initialize all agents (TODO: Update agents to use new BaseAgent system)\n    for (const agent of agents) {\n        try {\n            // Enhanced initialization will be added when agents are updated to use new BaseAgent\n            console.log(`✅ Agent ${(agent as any).config?.participantId || 'unknown'} ready`);\n        } catch (error) {\n            console.warn(`Failed to initialize agent:`, error);\n        }\n    }\n\n    // Register each agent as a chat participant\n    outputChannel.appendLine(`\\nRegistering ${agents.length} agents...`);\n    let registrationErrors: string[] = [];\n    \n    agents.forEach((agent, index) => {\n        try {\n            const participantId = (agent as any).config.participantId;\n            const participant = vscode.chat.createChatParticipant(\n                participantId,\n                agent.createHandler()\n            );\n            \n            // Set icon if available\n            const iconPath = (agent as any).config?.iconPath;\n            if (iconPath) {\n                participant.iconPath = iconPath;\n            }\n            \n            // Register the agent with dispatcher for orchestration\n            const dispatcherAgentId = participantId.split('.')[1];\n            outputChannel.appendLine(`  Registering with dispatcher: ${participantId} as '${dispatcherAgentId}'`);\n            dispatcher.registerAgent(dispatcherAgentId, agent);\n            \n            // Add to subscriptions for cleanup\n            context.subscriptions.push(participant);\n            \n            outputChannel.appendLine(`  ✅ Registered: ${participantId} (dispatcher ID: ${dispatcherAgentId})`);\n            \n        } catch (error) {\n            const errorMsg = `Failed to register agent ${index + 1}: ${(error as any).message}`;\n            outputChannel.appendLine(`  ❌ ${errorMsg}`);\n            registrationErrors.push(errorMsg);\n        }\n    });\n    \n    // Verify agent registration\n    outputChannel.appendLine('\\nVerifying agent registration with dispatcher:');\n    const registeredAgents = dispatcher.getRegisteredAgents();\n    outputChannel.appendLine(`  Registered agents: [${registeredAgents.join(', ')}]`);\n    \n    outputChannel.appendLine(`Registration completed: ${agents.length - registrationErrors.length} succeeded, ${registrationErrors.length} failed`);\n    \n    if (registrationErrors.length > 0) {\n        outputChannel.appendLine('Registration errors:');\n        registrationErrors.forEach(error => outputChannel.appendLine(`  - ${error}`));\n    }\n\n    // Register extension commands\n    outputChannel.appendLine('\\nRegistering extension commands...');\n    registerCommands(context, dispatcher);\n    outputChannel.appendLine('✅ Extension commands registered');\n\n    // Show welcome message in output channel\n    showWelcomeMessage(outputChannel);\n\n    // Final success\n    outputChannel.appendLine('\\n✅ KI AUTOAGENT EXTENSION ACTIVATED!');\n    outputChannel.appendLine('============================================');\n    outputChannel.appendLine(`Total agents: ${agents.length}`);\n    outputChannel.appendLine(`Registration errors: ${registrationErrors.length}`);\n    outputChannel.appendLine(`Activated at: ${new Date().toLocaleString()}`);\n    outputChannel.appendLine('\\nType \"@ki\" in chat to get started!');\n    \n    // Single success notification\n    vscode.window.showInformationMessage(`🎉 KI AutoAgent v${context.extension.packageJSON.version} activated! ${agents.length} agents ready.`);\n    \n    } catch (error) {\n        // Handle any errors during extension activation\n        const errorMsg = `KI AutoAgent activation failed: ${(error as any).message || error}`;\n        console.error(errorMsg);\n        \n        // Show error\n        vscode.window.showErrorMessage(errorMsg);\n        \n        // Try to show error in output channel if available\n        if (outputChannel) {\n            outputChannel.appendLine(`\\n❌ ACTIVATION ERROR:`);\n            outputChannel.appendLine(`Error: ${error}`);\n            outputChannel.appendLine(`Message: ${(error as any).message}`);\n            outputChannel.appendLine(`Stack: ${(error as any).stack}`);\n            outputChannel.show(true);\n        }\n    }\n}\n\nexport function deactivate() {\n    console.log('👋 KI AutoAgent extension is deactivated');\n}\n\nfunction registerCommands(context: vscode.ExtensionContext, dispatcher: VSCodeMasterDispatcher) {\n    \n    // Command: Create File\n    const createFileCommand = vscode.commands.registerCommand(\n        'ki-autoagent.createFile',\n        async (filename: string, content: string) => {\n            try {\n                const workspaceFolder = vscode.workspace.workspaceFolders?.[0];\n                if (!workspaceFolder) {\n                    vscode.window.showErrorMessage('No workspace folder open');\n                    return;\n                }\n\n                const fileUri = vscode.Uri.joinPath(workspaceFolder.uri, filename);\n                await vscode.workspace.fs.writeFile(fileUri, Buffer.from(content, 'utf8'));\n                \n                // Open the created file\n                const document = await vscode.workspace.openTextDocument(fileUri);\n                await vscode.window.showTextDocument(document);\n                \n                vscode.window.showInformationMessage(`✅ Created file: ${filename}`);\n            } catch (error) {\n                vscode.window.showErrorMessage(`❌ Failed to create file: ${(error as any).message}`);\n            }\n        }\n    );\n\n    // Command: Insert at Cursor\n    const insertAtCursorCommand = vscode.commands.registerCommand(\n        'ki-autoagent.insertAtCursor',\n        async (content: string) => {\n            try {\n                const editor = vscode.window.activeTextEditor;\n                if (!editor) {\n                    vscode.window.showErrorMessage('No active text editor');\n                    return;\n                }\n\n                const position = editor.selection.active;\n                await editor.edit(editBuilder => {\n                    editBuilder.insert(position, content);\n                });\n                \n                vscode.window.showInformationMessage('✅ Content inserted at cursor');\n            } catch (error) {\n                vscode.window.showErrorMessage(`❌ Failed to insert content: ${(error as any).message}`);\n            }\n        }\n    );\n\n    // Command: Apply Suggestion\n    const applySuggestionCommand = vscode.commands.registerCommand(\n        'ki-autoagent.applySuggestion',\n        async (suggestionData: any) => {\n            try {\n                // Handle different types of suggestions\n                if (suggestionData.type === 'file_creation') {\n                    await vscode.commands.executeCommand(\n                        'ki-autoagent.createFile',\n                        suggestionData.filename,\n                        suggestionData.content\n                    );\n                } else if (suggestionData.type === 'code_insertion') {\n                    await vscode.commands.executeCommand(\n                        'ki-autoagent.insertAtCursor',\n                        suggestionData.code\n                    );\n                } else {\n                    vscode.window.showInformationMessage(`Applied suggestion: ${suggestionData.description}`);\n                }\n            } catch (error) {\n                vscode.window.showErrorMessage(`❌ Failed to apply suggestion: ${(error as any).message}`);\n            }\n        }\n    );\n\n    // Command: Test Claude Code CLI\n    const testClaudeCommand = vscode.commands.registerCommand(\n        'ki-autoagent.testClaudeCLI',\n        async () => {\n            const outputChannel = vscode.window.createOutputChannel('Claude CLI Test');\n            outputChannel.show();\n            outputChannel.appendLine('🔍 Testing Claude Code CLI Integration...');\n            outputChannel.appendLine('==========================================\\n');\n            \n            try {\n                const claudeService = getClaudeCodeService();\n                \n                // Check if CLI is available\n                outputChannel.appendLine('1. Checking Claude CLI availability...');\n                const isAvailable = await claudeService.isAvailable();\n                \n                if (!isAvailable) {\n                    outputChannel.appendLine('❌ Claude CLI not found!');\n                    outputChannel.appendLine('\\nTo install Claude CLI:');\n                    outputChannel.appendLine('  npm install -g @anthropic-ai/claude-code');\n                    outputChannel.appendLine('\\nOr use Anthropic API by configuring your API key in VS Code settings.');\n                    vscode.window.showErrorMessage('Claude CLI not installed. See output for installation instructions.');\n                    return;\n                }\n                \n                outputChannel.appendLine('✅ Claude CLI is available!\\n');\n                \n                // Test connection\n                outputChannel.appendLine('2. Testing Claude CLI connection...');\n                const testResult = await claudeService.testConnection();\n                \n                if (testResult.success) {\n                    outputChannel.appendLine(`✅ ${testResult.message}\\n`);\n                    outputChannel.appendLine('3. Claude CLI Integration Status: WORKING');\n                    outputChannel.appendLine('==========================================');\n                    outputChannel.appendLine('✨ Everything is working correctly!');\n                    outputChannel.appendLine('\\nYou can now use Claude-powered agents in your chat.');\n                    vscode.window.showInformationMessage('✅ Claude CLI is working correctly!');\n                } else {\n                    outputChannel.appendLine(`❌ ${testResult.message}\\n`);\n                    outputChannel.appendLine('3. Claude CLI Integration Status: ERROR');\n                    outputChannel.appendLine('==========================================');\n                    outputChannel.appendLine('Please check the error message above.');\n                    vscode.window.showErrorMessage(`Claude CLI test failed: ${testResult.message}`);\n                }\n                \n            } catch (error) {\n                outputChannel.appendLine(`\\n❌ Test failed with error: ${(error as any).message}`);\n                outputChannel.appendLine('\\nPlease check your configuration and try again.');\n                vscode.window.showErrorMessage(`Claude CLI test failed: ${(error as any).message}`);\n            }\n        }\n    );\n\n    // Command: Show Agent Statistics\n    const showAgentStatsCommand = vscode.commands.registerCommand(\n        'ki-autoagent.showAgentStats',\n        async () => {\n            try {\n                const stats = await dispatcher.getAgentStats();\n                \n                if (Object.keys(stats).length === 0) {\n                    vscode.window.showInformationMessage('No agent statistics available yet');\n                    return;\n                }\n\n                // Create a new document to display stats\n                const statsContent = formatAgentStats(stats);\n                const document = await vscode.workspace.openTextDocument({\n                    content: statsContent,\n                    language: 'markdown'\n                });\n                \n                await vscode.window.showTextDocument(document);\n            } catch (error) {\n                vscode.window.showErrorMessage(`❌ Failed to show stats: ${(error as any).message}`);\n            }\n        }\n    );\n\n    // Command: Show Help\n    const showHelpCommand = vscode.commands.registerCommand(\n        'ki-autoagent.showHelp',\n        async (agentId?: string) => {\n            const helpContent = generateHelpContent(agentId);\n            \n            const document = await vscode.workspace.openTextDocument({\n                content: helpContent,\n                language: 'markdown'\n            });\n            \n            await vscode.window.showTextDocument(document);\n        }\n    );\n\n    // Command: Plan Implementation\n    const planImplementationCommand = vscode.commands.registerCommand(\n        'ki-autoagent.planImplementation',\n        async (task: string, architecture: string) => {\n            // This would trigger the orchestrator to create an implementation plan\n            vscode.window.showInformationMessage('Creating implementation plan...');\n            // Could open chat with pre-filled message\n        }\n    );\n\n    // Command: Execute Workflow\n    const executeWorkflowCommand = vscode.commands.registerCommand(\n        'ki-autoagent.executeWorkflow',\n        async (task: string, workflow: string) => {\n            vscode.window.showInformationMessage('Executing workflow...');\n            // Implementation for workflow execution\n        }\n    );\n\n    // Command: Configure Agent Models\n    const configureAgentModelsCommand = vscode.commands.registerCommand(\n        'ki-autoagent.configureAgentModels',\n        async () => {\n            const configManager = AgentConfigurationManager.getInstance(context);\n            const availableModels = configManager.getAvailableModels();\n            \n            // Show agent model configuration UI\n            const agentIds = ['orchestrator', 'richter', 'architect', 'codesmith', 'tradestrat', 'research'];\n            \n            for (const agentId of agentIds) {\n                const currentModel = configManager.getAgentModel(agentId);\n                const modelOptions = Object.keys(availableModels).map(modelId => ({\n                    label: availableModels[modelId].name,\n                    description: `${availableModels[modelId].provider} - ${availableModels[modelId].tier}`,\n                    detail: `$${availableModels[modelId].costPerMillion.input}/$${availableModels[modelId].costPerMillion.output} per million tokens`,\n                    modelId\n                }));\n                \n                const selected = await vscode.window.showQuickPick(modelOptions, {\n                    title: `Select model for ${agentId}`,\n                    placeHolder: `Current: ${currentModel}`,\n                    ignoreFocusOut: true\n                });\n                \n                if (selected && selected.modelId !== currentModel) {\n                    await configManager.setAgentModel(agentId, selected.modelId);\n                    vscode.window.showInformationMessage(`✅ Updated ${agentId} model to ${selected.label}`);\n                }\n            }\n        }\n    );\n\n    // Command: Show Agent Performance\n    const showAgentPerformanceCommand = vscode.commands.registerCommand(\n        'ki-autoagent.showAgentPerformance',\n        async () => {\n            const configManager = AgentConfigurationManager.getInstance(context);\n            const agentIds = ['orchestrator', 'richter', 'architect', 'codesmith', 'tradestrat', 'research'];\n            \n            let performanceReport = '# Agent Performance Report\\n\\n';\n            performanceReport += `Generated: ${new Date().toLocaleString()}\\n\\n`;\n            \n            for (const agentId of agentIds) {\n                const metrics = configManager.getAgentMetrics(agentId);\n                const model = configManager.getAgentModel(agentId);\n                \n                performanceReport += `## ${agentId.charAt(0).toUpperCase() + agentId.slice(1)}\\n`;\n                performanceReport += `**Model:** ${model}\\n`;\n                \n                if (metrics) {\n                    const successRate = (metrics.successfulExecutions / metrics.totalExecutions * 100).toFixed(1);\n                    performanceReport += `**Success Rate:** ${successRate}%\\n`;\n                    performanceReport += `**Total Executions:** ${metrics.totalExecutions}\\n`;\n                    performanceReport += `**Average Response Time:** ${metrics.averageResponseTime.toFixed(0)}ms\\n`;\n                    performanceReport += `**Current Streak:** ${metrics.currentStreak}\\n`;\n                    performanceReport += `**Best Streak:** ${metrics.bestStreak}\\n`;\n                } else {\n                    performanceReport += `**Status:** No performance data yet\\n`;\n                }\n                performanceReport += '\\n';\n            }\n            \n            const document = await vscode.workspace.openTextDocument({\n                content: performanceReport,\n                language: 'markdown'\n            });\n            await vscode.window.showTextDocument(document);\n        }\n    );\n\n    // Command: Open Configuration Directory\n    const openConfigDirectoryCommand = vscode.commands.registerCommand(\n        'ki-autoagent.openConfigDirectory',\n        async () => {\n            const workspaceFolder = vscode.workspace.workspaceFolders?.[0];\n            if (workspaceFolder) {\n                const configPath = vscode.Uri.joinPath(workspaceFolder.uri, '.kiautoagent');\n                try {\n                    await vscode.commands.executeCommand('vscode.openFolder', configPath, { forceNewWindow: false });\n                } catch {\n                    vscode.window.showInformationMessage('Configuration directory will be created when first used');\n                }\n            } else {\n                vscode.window.showWarningMessage('No workspace folder open');\n            }\n        }\n    );\n\n    // Register all commands\n    context.subscriptions.push(\n        createFileCommand,\n        insertAtCursorCommand,\n        applySuggestionCommand,\n        testClaudeCommand,\n        showAgentStatsCommand,\n        showHelpCommand,\n        planImplementationCommand,\n        executeWorkflowCommand,\n        configureAgentModelsCommand,\n        showAgentPerformanceCommand,\n        openConfigDirectoryCommand\n    );\n\n    console.log('✅ All extension commands registered');\n}\n\nfunction showWelcomeMessage(outputChannel: vscode.OutputChannel) {\n    \n    outputChannel.appendLine('🤖 KI AutoAgent VS Code Extension');\n    outputChannel.appendLine('=======================================');\n    outputChannel.appendLine('');\n    outputChannel.appendLine('✅ Extension activated successfully!');\n    outputChannel.appendLine('');\n    outputChannel.appendLine('Available Agents:');\n    outputChannel.appendLine('• @ki - Universal orchestrator (routes to best agent)');\n    outputChannel.appendLine('• @richter - ⚖️ Supreme judge & conflict resolver (Opus 4.1)');\n    outputChannel.appendLine('• @architect - System architecture & design');\n    outputChannel.appendLine('• @codesmith - Code implementation & testing');\n    outputChannel.appendLine('• @docu - Documentation generation');\n    outputChannel.appendLine('• @reviewer - Code review & security');\n    outputChannel.appendLine('• @fixer - Bug fixing & debugging');\n    outputChannel.appendLine('• @tradestrat - Trading strategy development');\n    outputChannel.appendLine('• @research - Web research & information gathering');\n    outputChannel.appendLine('');\n    outputChannel.appendLine('Getting Started:');\n    outputChannel.appendLine('1. Open VS Code Chat panel (Ctrl+Shift+I)');\n    outputChannel.appendLine('2. Type @ki followed by your request');\n    outputChannel.appendLine('3. Or use specific agents like @architect, @codesmith, etc.');\n    outputChannel.appendLine('');\n    outputChannel.appendLine('Configuration:');\n    outputChannel.appendLine('• Set your API keys in VS Code Settings');\n    outputChannel.appendLine('• Search for \"KI AutoAgent\" in settings');\n    outputChannel.appendLine('• Configure OpenAI, Anthropic, and Perplexity API keys');\n    outputChannel.appendLine('');\n    outputChannel.appendLine('Need help? Type \"@ki /agents\" to see all available agents!');\n}\n\nfunction formatAgentStats(stats: Record<string, any>): string {\n    let content = '# KI AutoAgent Statistics\\n\\n';\n    content += `Generated at: ${new Date().toLocaleString()}\\n\\n`;\n    \n    for (const [agentId, agentStats] of Object.entries(stats)) {\n        const { totalExecutions, successRate, averageResponseTime, lastExecution } = agentStats as any;\n        \n        content += `## ${agentId}\\n\\n`;\n        content += `- **Total Executions:** ${totalExecutions}\\n`;\n        content += `- **Success Rate:** ${(successRate * 100).toFixed(1)}%\\n`;\n        content += `- **Average Response Time:** ${averageResponseTime.toFixed(0)}ms\\n`;\n        \n        if (lastExecution) {\n            content += `- **Last Execution:** ${new Date(lastExecution).toLocaleString()}\\n`;\n        }\n        \n        content += '\\n';\n    }\n    \n    return content;\n}\n\nfunction generateHelpContent(agentId?: string): string {\n    let content = '# KI AutoAgent Help\\n\\n';\n    \n    if (agentId) {\n        content += `## Help for ${agentId}\\n\\n`;\n        // Add agent-specific help\n    } else {\n        content += '## Getting Started\\n\\n';\n        content += 'KI AutoAgent is a universal multi-agent AI development platform for VS Code.\\n\\n';\n        content += '### Available Agents\\n\\n';\n        content += '- **@ki** - Universal orchestrator that automatically routes tasks\\n';\n        content += '- **@richter** - ⚖️ Supreme judge & conflict resolver (Claude Opus 4.1)\\n';\n        content += '- **@architect** - System architecture and design expert\\n';\n        content += '- **@codesmith** - Senior Python/Web developer\\n';\n        content += '- **@docu** - Technical documentation expert\\n';\n        content += '- **@reviewer** - Code review and security expert\\n';\n        content += '- **@fixer** - Bug fixing and optimization expert\\n';\n        content += '- **@tradestrat** - Trading strategy expert\\n';\n        content += '- **@research** - Research and information expert\\n\\n';\n        content += '### Usage Examples\\n\\n';\n        content += '```\\n';\n        content += '@ki create a REST API with FastAPI\\n';\n        content += '@richter judge which approach is better: microservices vs monolith\\n';\n        content += '@richter resolve this disagreement between @architect and @codesmith\\n';\n        content += '@architect design a microservices architecture\\n';\n        content += '@codesmith implement a Python class for user management\\n';\n        content += '@tradestrat develop a momentum trading strategy\\n';\n        content += '@fixer debug this error message\\n';\n        content += '```\\n\\n';\n        content += '### Configuration\\n\\n';\n        content += '1. Open VS Code Settings (Ctrl+,)\\n';\n        content += '2. Search for \"KI AutoAgent\"\\n';\n        content += '3. Configure your API keys:\\n';\n        content += '   - OpenAI API Key (for GPT models)\\n';\n        content += '   - Anthropic API Key (for Claude models)\\n';\n        content += '   - Perplexity API Key (for research)\\n\\n';\n        content += '### Support\\n\\n';\n        content += 'For issues and feature requests, please visit the GitHub repository.\\n';\n    }\n    \n    return content;\n}","/**\n * Advanced Orchestrator Agent with Task Decomposition and Intelligent Workflow Management\n * Uses graph-based workflow execution, parallel processing, and memory-enhanced orchestration\n */\nimport * as vscode from 'vscode';\nimport { ChatAgent } from './base/ChatAgent';\nimport { AgentConfig, TaskRequest, TaskResult, WorkflowStep } from '../types';\nimport { VSCodeMasterDispatcher } from '../core/VSCodeMasterDispatcher';\nimport { OpenAIService } from '../utils/OpenAIService';\nimport { AgentRegistry } from '../core/AgentRegistry';\nimport { WorkflowEngine, WorkflowNode, ExecutionPlan } from '../core/WorkflowEngine';\nimport { MemoryManager } from '../core/MemoryManager';\nimport { SharedContextManager, getSharedContext } from '../core/SharedContextManager';\nimport { AgentCommunicationBus, getCommunicationBus, MessageType } from '../core/AgentCommunicationBus';\nimport { MemoryType, TaskMemory, TaskStep as MemoryTaskStep } from '../types/Memory';\n\ninterface TaskDecomposition {\n    mainGoal: string;\n    complexity: 'simple' | 'moderate' | 'complex';\n    subtasks: SubTask[];\n    dependencies: TaskDependency[];\n    estimatedDuration: number;\n    requiredAgents: string[];\n    parallelizable: boolean;\n}\n\ninterface SubTask {\n    id: string;\n    description: string;\n    agent: string;\n    priority: number;\n    dependencies: string[];\n    expectedOutput: string;\n    estimatedDuration: number;\n}\n\ninterface TaskDependency {\n    from: string;\n    to: string;\n    type: 'sequential' | 'parallel' | 'conditional';\n    condition?: string;\n}\n\nexport class OrchestratorAgent extends ChatAgent {\n    private openAIService: OpenAIService;\n    private workflowEngine: WorkflowEngine;\n    private memoryManager: MemoryManager;\n    private sharedContext: SharedContextManager;\n    private communicationBus: AgentCommunicationBus;\n    private activeWorkflows: Map<string, string> = new Map(); // workflowId -> description\n\n    constructor(context: vscode.ExtensionContext, dispatcher: VSCodeMasterDispatcher) {\n        const config: AgentConfig = {\n            participantId: 'ki-autoagent.orchestrator',\n            name: 'ki',\n            fullName: 'Advanced KI AutoAgent Orchestrator',\n            description: 'Intelligent task orchestration with decomposition, parallel execution, and memory',\n            model: 'gpt-5-2025-09-12',\n            iconPath: vscode.Uri.joinPath(context.extensionUri, 'media', 'orchestrator-icon.svg'),\n            capabilities: [\n                'Task Decomposition',\n                'Parallel Execution',\n                'Dynamic Workflow Adjustment',\n                'Agent Conflict Resolution',\n                'Memory-Based Learning',\n                'Multi-Agent Collaboration'\n            ],\n            commands: [\n                { name: 'task', description: 'Execute complex task with intelligent decomposition', handler: 'handleTaskCommand' },\n                { name: 'agents', description: 'Show available specialized agents', handler: 'handleAgentsCommand' },\n                { name: 'workflow', description: 'Create advanced multi-step workflow', handler: 'handleWorkflowCommand' },\n                { name: 'decompose', description: 'Decompose complex task into subtasks', handler: 'handleDecomposeCommand' },\n                { name: 'parallel', description: 'Execute tasks in parallel', handler: 'handleParallelCommand' }\n            ]\n        };\n\n        super(config, context, dispatcher);\n\n        // Initialize advanced systems\n        this.openAIService = new OpenAIService();\n        this.workflowEngine = new WorkflowEngine();\n        this.memoryManager = new MemoryManager({\n            maxMemories: 10000,\n            similarityThreshold: 0.7,\n            patternExtractionEnabled: true\n        });\n        this.sharedContext = getSharedContext();\n        this.communicationBus = getCommunicationBus();\n\n        // Register for inter-agent communication\n        this.registerCommunicationHandlers();\n    }\n\n    protected async handleRequest(\n        request: vscode.ChatRequest,\n        context: vscode.ChatContext,\n        stream: vscode.ChatResponseStream,\n        token: vscode.CancellationToken\n    ): Promise<void> {\n        const command = request.command;\n        const prompt = request.prompt;\n\n        // Immediate feedback with intelligence indicator\n        stream.progress('🧠 Advanced Orchestrator analyzing complexity and decomposing task...');\n\n        this.log(`Advanced Orchestrator processing: ${prompt.substring(0, 100)}...`);\n\n        // Build context with memory\n        const enhancedRequest = await this.buildContextWithMemory({\n            prompt,\n            context: { chatHistory: context.history }\n        });\n\n        if (command) {\n            await this.handleCommand(command, prompt, stream, token);\n        } else {\n            // Analyze task complexity\n            const complexity = await this.analyzeTaskComplexity(prompt);\n\n            if (complexity === 'simple') {\n                await this.handleSimpleTask(prompt, stream, token);\n            } else if (complexity === 'moderate') {\n                await this.handleModerateTask(prompt, stream, token);\n            } else {\n                await this.handleComplexTask(prompt, stream, token);\n            }\n        }\n    }\n\n    /**\n     * Analyze task complexity to determine orchestration strategy\n     */\n    private async analyzeTaskComplexity(prompt: string): Promise<'simple' | 'moderate' | 'complex'> {\n        // Search memory for similar tasks\n        const similarTasks = await this.memoryManager.search(prompt, {\n            k: 5,\n            type: MemoryType.EPISODIC\n        });\n\n        // If we have handled similar tasks, use learned complexity\n        if (similarTasks.length > 0) {\n            const complexities = similarTasks\n                .map(t => (t.entry.content as any).complexity)\n                .filter(Boolean);\n\n            if (complexities.length > 0) {\n                // Return most common complexity\n                const counts = complexities.reduce((acc: any, c: string) => {\n                    acc[c] = (acc[c] || 0) + 1;\n                    return acc;\n                }, {});\n\n                return Object.entries(counts)\n                    .sort(([, a]: any, [, b]: any) => b - a)[0][0] as any;\n            }\n        }\n\n        // Analyze prompt for complexity indicators\n        const complexityIndicators = {\n            complex: [\n                /build.*system/i,\n                /implement.*architecture/i,\n                /create.*application/i,\n                /develop.*platform/i,\n                /design.*and.*implement/i,\n                /multiple.*components/i,\n                /full.*stack/i,\n                /end.*to.*end/i,\n                /microservices/i,\n                /distributed/i\n            ],\n            moderate: [\n                /create.*feature/i,\n                /implement.*api/i,\n                /add.*functionality/i,\n                /refactor/i,\n                /optimize/i,\n                /debug.*and.*fix/i,\n                /integrate/i,\n                /migrate/i\n            ],\n            simple: [\n                /fix.*bug/i,\n                /update.*documentation/i,\n                /write.*function/i,\n                /create.*file/i,\n                /explain/i,\n                /what.*is/i,\n                /how.*to/i,\n                /show.*me/i,\n                /list/i\n            ]\n        };\n\n        // Check indicators\n        for (const [level, patterns] of Object.entries(complexityIndicators)) {\n            if (patterns.some(p => p.test(prompt))) {\n                return level as any;\n            }\n        }\n\n        // Default to moderate\n        return 'moderate';\n    }\n\n    /**\n     * Handle simple tasks with direct routing\n     */\n    private async handleSimpleTask(\n        prompt: string,\n        stream: vscode.ChatResponseStream,\n        token: vscode.CancellationToken\n    ): Promise<void> {\n        stream.markdown(`## ⚡ Simple Task Execution\\n\\n`);\n\n        // Get best agent for the task\n        const registry = AgentRegistry.getInstance();\n        const agent = registry.suggestAgentForTask(prompt);\n\n        if (agent && agent !== 'orchestrator') {\n            stream.markdown(`**Routing to @${agent}**\\n\\n`);\n\n            // Create simple workflow\n            const workflow = this.workflowEngine.createWorkflow(`Simple: ${prompt}`);\n\n            const node: WorkflowNode = {\n                id: 'execute',\n                type: 'task',\n                agentId: agent,\n                task: prompt\n            };\n\n            this.workflowEngine.addNode(workflow.id, node);\n\n            // Execute\n            const results = await this.executeWorkflowWithProgress(\n                workflow.id,\n                prompt,\n                stream\n            );\n\n            // Display results\n            this.displayResults(results, stream);\n\n            // Store in memory\n            await this.storeTaskMemory(prompt, 'simple', workflow.id, results);\n        } else {\n            // Handle directly\n            await this.handleDirectResponse(prompt, stream);\n        }\n    }\n\n    /**\n     * Handle moderate complexity tasks with sequential workflow\n     */\n    private async handleModerateTask(\n        prompt: string,\n        stream: vscode.ChatResponseStream,\n        token: vscode.CancellationToken\n    ): Promise<void> {\n        stream.markdown(`## 🔄 Moderate Task Workflow\\n\\n`);\n\n        // Decompose into subtasks\n        const decomposition = await this.decomposeTask(prompt);\n\n        stream.markdown(`**Identified ${decomposition.subtasks.length} subtasks**\\n\\n`);\n\n        // Create workflow\n        const workflow = this.workflowEngine.createWorkflow(`Moderate: ${prompt}`);\n\n        // Add nodes for each subtask\n        decomposition.subtasks.forEach(subtask => {\n            const node: WorkflowNode = {\n                id: subtask.id,\n                type: 'task',\n                agentId: subtask.agent,\n                task: subtask.description,\n                dependencies: subtask.dependencies\n            };\n\n            this.workflowEngine.addNode(workflow.id, node);\n        });\n\n        // Add edges based on dependencies\n        decomposition.dependencies.forEach(dep => {\n            this.workflowEngine.addEdge(workflow.id, {\n                from: dep.from,\n                to: dep.to\n            });\n        });\n\n        // Display execution plan\n        const plan = this.workflowEngine.createExecutionPlan(workflow.id);\n        this.displayExecutionPlan(plan, stream);\n\n        // Execute workflow\n        const results = await this.executeWorkflowWithProgress(\n            workflow.id,\n            prompt,\n            stream\n        );\n\n        // Display results\n        this.displayResults(results, stream);\n\n        // Store in memory\n        await this.storeTaskMemory(prompt, 'moderate', workflow.id, results);\n    }\n\n    /**\n     * Handle complex tasks with parallel execution and collaboration\n     */\n    private async handleComplexTask(\n        prompt: string,\n        stream: vscode.ChatResponseStream,\n        token: vscode.CancellationToken\n    ): Promise<void> {\n        stream.markdown(`## 🚀 Complex Task Orchestration\\n\\n`);\n        stream.markdown(`**Initiating advanced multi-agent collaboration...**\\n\\n`);\n\n        // Decompose into subtasks\n        const decomposition = await this.decomposeTask(prompt);\n\n        stream.markdown(`### 📊 Task Analysis\\n`);\n        stream.markdown(`- **Complexity:** ${decomposition.complexity}\\n`);\n        stream.markdown(`- **Subtasks:** ${decomposition.subtasks.length}\\n`);\n        stream.markdown(`- **Required Agents:** ${decomposition.requiredAgents.join(', ')}\\n`);\n        stream.markdown(`- **Parallelizable:** ${decomposition.parallelizable ? 'Yes' : 'No'}\\n`);\n        stream.markdown(`- **Estimated Duration:** ${decomposition.estimatedDuration}ms\\n\\n`);\n\n        // Start collaboration session\n        const session = await this.communicationBus.startCollaboration(\n            { task: prompt, decomposition },\n            decomposition.requiredAgents,\n            'orchestrator'\n        );\n\n        stream.markdown(`**Collaboration Session Started:** ${session.id}\\n\\n`);\n\n        // Create advanced workflow with parallel execution\n        const workflow = this.workflowEngine.createWorkflow(`Complex: ${prompt}`);\n\n        // Group parallelizable tasks\n        const parallelGroups = this.groupParallelTasks(decomposition);\n\n        // Create workflow nodes\n        parallelGroups.forEach((group, index) => {\n            if (group.length > 1) {\n                // Create parallel node\n                const parallelNode: WorkflowNode = {\n                    id: `parallel_${index}`,\n                    type: 'parallel',\n                    children: group.map(t => t.id)\n                };\n\n                this.workflowEngine.addNode(workflow.id, parallelNode);\n\n                // Add task nodes\n                group.forEach(subtask => {\n                    const taskNode: WorkflowNode = {\n                        id: subtask.id,\n                        type: 'task',\n                        agentId: subtask.agent,\n                        task: subtask.description\n                    };\n                    this.workflowEngine.addNode(workflow.id, taskNode);\n                });\n            } else {\n                // Single task node\n                const subtask = group[0];\n                const taskNode: WorkflowNode = {\n                    id: subtask.id,\n                    type: 'task',\n                    agentId: subtask.agent,\n                    task: subtask.description,\n                    dependencies: subtask.dependencies\n                };\n                this.workflowEngine.addNode(workflow.id, taskNode);\n            }\n        });\n\n        // Add edges for dependencies\n        decomposition.dependencies.forEach(dep => {\n            this.workflowEngine.addEdge(workflow.id, {\n                from: dep.from,\n                to: dep.to,\n                condition: dep.condition ? this.createCondition(dep.condition) : undefined\n            });\n        });\n\n        // Display execution plan\n        const plan = this.workflowEngine.createExecutionPlan(workflow.id);\n        this.displayAdvancedExecutionPlan(plan, stream);\n\n        // Execute with checkpointing\n        stream.markdown(`### ⚡ Execution Progress\\n\\n`);\n\n        const results = await this.executeComplexWorkflow(\n            workflow.id,\n            prompt,\n            session.id,\n            stream\n        );\n\n        // Complete collaboration\n        this.communicationBus.completeCollaboration(session.id, results);\n\n        // Display comprehensive results\n        this.displayComplexResults(results, stream);\n\n        // Store in memory with patterns\n        await this.storeComplexTaskMemory(prompt, decomposition, workflow.id, results);\n\n        // Extract and store patterns\n        await this.extractAndStorePatterns(decomposition, results);\n    }\n\n    /**\n     * Decompose task into subtasks using AI\n     */\n    private async decomposeTask(prompt: string): Promise<TaskDecomposition> {\n        // Check memory for similar decompositions\n        const similarTasks = await this.memoryManager.search(prompt, {\n            k: 3,\n            type: MemoryType.PROCEDURAL\n        });\n\n        if (similarTasks.length > 0 && similarTasks[0].similarity > 0.85) {\n            // Reuse previous decomposition\n            return (similarTasks[0].entry.content as any).decomposition;\n        }\n\n        // Use AI to decompose\n        const systemPrompt = `You are an expert task decomposer. Break down complex tasks into subtasks.\n\n${this.getSystemContextPrompt()}\n\nAnalyze the task and provide a JSON response with:\n{\n  \"mainGoal\": \"primary objective\",\n  \"complexity\": \"simple|moderate|complex\",\n  \"subtasks\": [\n    {\n      \"id\": \"unique_id\",\n      \"description\": \"what to do\",\n      \"agent\": \"best agent for this\",\n      \"priority\": 1-5,\n      \"dependencies\": [\"other_task_ids\"],\n      \"expectedOutput\": \"what this produces\",\n      \"estimatedDuration\": milliseconds\n    }\n  ],\n  \"dependencies\": [\n    {\n      \"from\": \"task_id\",\n      \"to\": \"task_id\",\n      \"type\": \"sequential|parallel|conditional\",\n      \"condition\": \"optional condition\"\n    }\n  ],\n  \"estimatedDuration\": total_milliseconds,\n  \"requiredAgents\": [\"agent1\", \"agent2\"],\n  \"parallelizable\": boolean\n}\n\nAvailable agents: architect, codesmith, docu, reviewer, fixer, tradestrat, opus-arbitrator, research`;\n\n        const response = await this.openAIService.chat([\n            { role: 'system', content: systemPrompt },\n            { role: 'user', content: `Decompose this task: ${prompt}` }\n        ]);\n\n        try {\n            const decomposition = JSON.parse(response);\n\n            // Store in memory for future use\n            await this.memoryManager.store(\n                'orchestrator',\n                { prompt, decomposition },\n                MemoryType.PROCEDURAL,\n                { importance: 0.8 }\n            );\n\n            return decomposition;\n        } catch (error) {\n            // Fallback to simple decomposition\n            return this.createSimpleDecomposition(prompt);\n        }\n    }\n\n    /**\n     * Create simple decomposition as fallback\n     */\n    private createSimpleDecomposition(prompt: string): TaskDecomposition {\n        const registry = AgentRegistry.getInstance();\n        const agent = registry.suggestAgentForTask(prompt) || 'codesmith';\n\n        return {\n            mainGoal: prompt,\n            complexity: 'simple',\n            subtasks: [{\n                id: 'task_1',\n                description: prompt,\n                agent,\n                priority: 1,\n                dependencies: [],\n                expectedOutput: 'Task result',\n                estimatedDuration: 5000\n            }],\n            dependencies: [],\n            estimatedDuration: 5000,\n            requiredAgents: [agent],\n            parallelizable: false\n        };\n    }\n\n    /**\n     * Group tasks that can be executed in parallel\n     */\n    private groupParallelTasks(decomposition: TaskDecomposition): SubTask[][] {\n        const groups: SubTask[][] = [];\n        const processed = new Set<string>();\n\n        // Sort by priority\n        const sorted = [...decomposition.subtasks].sort((a, b) => a.priority - b.priority);\n\n        sorted.forEach(task => {\n            if (processed.has(task.id)) return;\n\n            // Find tasks that can run in parallel with this one\n            const parallelGroup = [task];\n            processed.add(task.id);\n\n            sorted.forEach(other => {\n                if (processed.has(other.id)) return;\n\n                // Check if they can run in parallel (no dependencies between them)\n                const hasDirectDependency = decomposition.dependencies.some(dep =>\n                    (dep.from === task.id && dep.to === other.id) ||\n                    (dep.from === other.id && dep.to === task.id)\n                );\n\n                if (!hasDirectDependency && other.dependencies.length === task.dependencies.length) {\n                    parallelGroup.push(other);\n                    processed.add(other.id);\n                }\n            });\n\n            groups.push(parallelGroup);\n        });\n\n        return groups;\n    }\n\n    /**\n     * Execute workflow with progress updates\n     */\n    private async executeWorkflowWithProgress(\n        workflowId: string,\n        description: string,\n        stream: vscode.ChatResponseStream\n    ): Promise<Map<string, any>> {\n        this.activeWorkflows.set(workflowId, description);\n\n        // Subscribe to workflow events\n        const workflow = this.workflowEngine['workflows'].get(workflowId);\n        if (workflow) {\n            this.workflowEngine['eventBus'].on('node-started', (event: any) => {\n                if (event.workflowId === workflowId) {\n                    stream.progress(`⚡ Executing: ${event.node.id}`);\n                }\n            });\n\n            this.workflowEngine['eventBus'].on('node-completed', (event: any) => {\n                if (event.workflowId === workflowId) {\n                    stream.markdown(`✅ Completed: ${event.node.id}\\n`);\n                }\n            });\n        }\n\n        // Execute workflow\n        const context = new Map<string, any>([\n            ['prompt', description],\n            ['sharedContext', this.sharedContext.getContext()]\n        ]);\n\n        const results = await this.workflowEngine.execute(workflowId, context);\n\n        this.activeWorkflows.delete(workflowId);\n        return results;\n    }\n\n    /**\n     * Execute complex workflow with checkpointing and dynamic adjustment\n     */\n    private async executeComplexWorkflow(\n        workflowId: string,\n        description: string,\n        sessionId: string,\n        stream: vscode.ChatResponseStream\n    ): Promise<Map<string, any>> {\n        const results = new Map<string, any>();\n        const workflow = this.workflowEngine['workflows'].get(workflowId);\n\n        if (!workflow) return results;\n\n        // Set up event handlers for real-time updates\n        this.workflowEngine['eventBus'].on('stage-started', (event: any) => {\n            if (event.workflowId === workflowId) {\n                stream.markdown(`\\n**Stage Started:** ${event.stage.stageId}\\n`);\n\n                // Update collaboration context\n                this.communicationBus.updateCollaborationContext(\n                    sessionId,\n                    'orchestrator',\n                    'current_stage',\n                    event.stage\n                );\n            }\n        });\n\n        this.workflowEngine['eventBus'].on('node-completed', (event: any) => {\n            if (event.workflowId === workflowId) {\n                // Check if adjustment needed based on result\n                if (event.result.status === 'failure') {\n                    // Request help from other agents\n                    this.requestAgentHelp(event.node, event.result.error);\n                }\n\n                // Update shared context\n                this.sharedContext.updateContext(\n                    'orchestrator',\n                    `result_${event.node.id}`,\n                    event.result\n                );\n            }\n        });\n\n        // Create checkpoints at critical stages\n        this.workflowEngine['eventBus'].on('stage-completed', (event: any) => {\n            if (event.workflowId === workflowId) {\n                this.workflowEngine.createCheckpoint(workflowId, event.stage.stageId);\n                stream.markdown(`💾 Checkpoint created at ${event.stage.stageId}\\n`);\n            }\n        });\n\n        // Execute with context\n        const context = new Map<string, any>([\n            ['prompt', description],\n            ['sessionId', sessionId],\n            ['sharedContext', this.sharedContext.getContext()]\n        ]);\n\n        try {\n            return await this.workflowEngine.execute(workflowId, context);\n        } catch (error) {\n            stream.markdown(`\\n⚠️ **Workflow error, attempting recovery...**\\n`);\n\n            // Try to recover from last checkpoint\n            const checkpoints = workflow.checkpoints;\n            if (checkpoints.length > 0) {\n                const lastCheckpoint = checkpoints[checkpoints.length - 1];\n                this.workflowEngine.restoreFromCheckpoint(workflowId, lastCheckpoint.id);\n\n                stream.markdown(`♻️ Restored from checkpoint: ${lastCheckpoint.nodeId}\\n`);\n\n                // Retry execution\n                return await this.workflowEngine.execute(workflowId, context);\n            }\n\n            throw error;\n        }\n    }\n\n    /**\n     * Request help from other agents when stuck\n     */\n    private async requestAgentHelp(node: WorkflowNode, error: string): Promise<void> {\n        const helpResponse = await this.communicationBus.requestHelp(\n            'orchestrator',\n            {\n                node,\n                error,\n                context: this.sharedContext.getContext()\n            }\n        );\n\n        if (helpResponse && helpResponse.length > 0) {\n            // Apply first suggested solution\n            const solution = helpResponse[0];\n\n            // Adjust workflow based on help\n            this.workflowEngine.adjustWorkflow(node.id, {\n                type: 'modify-node',\n                nodeId: node.id,\n                modifications: {\n                    task: solution.suggestion || node.task\n                }\n            });\n        }\n    }\n\n    /**\n     * Display execution plan\n     */\n    private displayExecutionPlan(plan: ExecutionPlan, stream: vscode.ChatResponseStream): void {\n        stream.markdown(`### 📋 Execution Plan\\n\\n`);\n        stream.markdown(`**Stages:** ${plan.stages.length}\\n`);\n        stream.markdown(`**Parallelism:** ${plan.parallelism}x\\n`);\n        stream.markdown(`**Estimated Duration:** ${plan.estimatedDuration}ms\\n\\n`);\n\n        plan.stages.forEach((stage, index) => {\n            stream.markdown(`**Stage ${index + 1}:** ${stage.parallel ? '⚡ Parallel' : '📝 Sequential'}\\n`);\n            stage.nodes.forEach(node => {\n                stream.markdown(`  - ${node.agentId || 'system'}: ${node.id}\\n`);\n            });\n        });\n\n        stream.markdown(`\\n**Critical Path:** ${plan.criticalPath.join(' → ')}\\n\\n`);\n    }\n\n    /**\n     * Display advanced execution plan\n     */\n    private displayAdvancedExecutionPlan(plan: ExecutionPlan, stream: vscode.ChatResponseStream): void {\n        stream.markdown(`### 🚀 Advanced Execution Strategy\\n\\n`);\n\n        // Create visual representation\n        stream.markdown(`\\`\\`\\`mermaid\\ngraph TB\\n`);\n\n        plan.stages.forEach((stage, index) => {\n            if (stage.parallel) {\n                stream.markdown(`  subgraph \"Stage ${index + 1} - Parallel\"\\n`);\n                stage.nodes.forEach(node => {\n                    stream.markdown(`    ${node.id}[\"${node.agentId}: ${node.id}\"]\\n`);\n                });\n                stream.markdown(`  end\\n`);\n            } else {\n                stage.nodes.forEach(node => {\n                    stream.markdown(`  ${node.id}[\"${node.agentId}: ${node.id}\"]\\n`);\n                });\n            }\n        });\n\n        // Add dependencies as edges\n        plan.stages.forEach((stage, index) => {\n            if (index > 0) {\n                const prevStage = plan.stages[index - 1];\n                prevStage.nodes.forEach(prevNode => {\n                    stage.nodes.forEach(currNode => {\n                        if (currNode.dependencies?.includes(prevNode.id)) {\n                            stream.markdown(`  ${prevNode.id} --> ${currNode.id}\\n`);\n                        }\n                    });\n                });\n            }\n        });\n\n        stream.markdown(`\\`\\`\\`\\n\\n`);\n\n        // Performance metrics\n        stream.markdown(`**Performance Optimization:**\\n`);\n        stream.markdown(`- Parallel Execution Speed-up: ${plan.parallelism}x\\n`);\n        stream.markdown(`- Critical Path Length: ${plan.criticalPath.length} steps\\n`);\n        stream.markdown(`- Total Estimated Time: ${(plan.estimatedDuration / 1000).toFixed(1)}s\\n\\n`);\n    }\n\n    /**\n     * Display simple results\n     */\n    private displayResults(results: Map<string, any>, stream: vscode.ChatResponseStream): void {\n        stream.markdown(`\\n### 📊 Results\\n\\n`);\n\n        results.forEach((result, nodeId) => {\n            if (result.status === 'success') {\n                stream.markdown(`**✅ ${nodeId}:**\\n${result.output?.result || result.output || 'Completed'}\\n\\n`);\n            } else if (result.status === 'failure') {\n                stream.markdown(`**❌ ${nodeId}:** ${result.error}\\n\\n`);\n            }\n        });\n    }\n\n    /**\n     * Display complex results with insights\n     */\n    private displayComplexResults(results: Map<string, any>, stream: vscode.ChatResponseStream): void {\n        stream.markdown(`\\n### 🎯 Comprehensive Results\\n\\n`);\n\n        // Group results by status\n        const successes: any[] = [];\n        const failures: any[] = [];\n\n        results.forEach((result, nodeId) => {\n            if (result.status === 'success') {\n                successes.push({ nodeId, ...result });\n            } else {\n                failures.push({ nodeId, ...result });\n            }\n        });\n\n        // Display successes\n        if (successes.length > 0) {\n            stream.markdown(`#### ✅ Successful Tasks (${successes.length})\\n\\n`);\n            successes.forEach(result => {\n                stream.markdown(`**${result.nodeId}:**\\n`);\n                stream.markdown(`${result.output?.result || result.output || 'Completed'}\\n\\n`);\n            });\n        }\n\n        // Display failures\n        if (failures.length > 0) {\n            stream.markdown(`#### ⚠️ Failed Tasks (${failures.length})\\n\\n`);\n            failures.forEach(result => {\n                stream.markdown(`**${result.nodeId}:** ${result.error}\\n`);\n                stream.markdown(`*Suggestion:* Try using @fixer to resolve this issue\\n\\n`);\n            });\n        }\n\n        // Display insights\n        const insights = this.generateInsights(results);\n        if (insights.length > 0) {\n            stream.markdown(`#### 💡 Insights & Recommendations\\n\\n`);\n            insights.forEach(insight => {\n                stream.markdown(`- ${insight}\\n`);\n            });\n        }\n\n        // Display collaboration metrics\n        const collaborationStats = this.communicationBus.getStats();\n        stream.markdown(`\\n#### 📈 Collaboration Metrics\\n\\n`);\n        stream.markdown(`- Total Messages Exchanged: ${collaborationStats.totalMessages}\\n`);\n        stream.markdown(`- Average Response Time: ${collaborationStats.averageResponseTime.toFixed(0)}ms\\n`);\n        stream.markdown(`- Active Sessions: ${collaborationStats.activeSessions}\\n`);\n    }\n\n    /**\n     * Generate insights from results\n     */\n    private generateInsights(results: Map<string, any>): string[] {\n        const insights: string[] = [];\n\n        // Calculate success rate\n        let successes = 0;\n        let total = 0;\n\n        results.forEach(result => {\n            total++;\n            if (result.status === 'success') successes++;\n        });\n\n        const successRate = (successes / total) * 100;\n\n        if (successRate === 100) {\n            insights.push('🎉 Perfect execution! All tasks completed successfully.');\n        } else if (successRate >= 80) {\n            insights.push(`✅ Good performance with ${successRate.toFixed(0)}% success rate.`);\n        } else {\n            insights.push(`⚠️ Room for improvement with ${successRate.toFixed(0)}% success rate.`);\n        }\n\n        // Analyze patterns\n        const agents = new Map<string, number>();\n        results.forEach((result, nodeId) => {\n            const agent = (result as any).agent || 'unknown';\n            agents.set(agent, (agents.get(agent) || 0) + 1);\n        });\n\n        const mostUsedAgent = Array.from(agents.entries())\n            .sort(([, a], [, b]) => b - a)[0];\n\n        if (mostUsedAgent) {\n            insights.push(`📊 Most active agent: @${mostUsedAgent[0]} (${mostUsedAgent[1]} tasks)`);\n        }\n\n        // Check for bottlenecks\n        const longRunning = Array.from(results.entries())\n            .filter(([, r]) => r.duration > 10000)\n            .map(([id]) => id);\n\n        if (longRunning.length > 0) {\n            insights.push(`⏱️ Potential bottlenecks detected in: ${longRunning.join(', ')}`);\n        }\n\n        return insights;\n    }\n\n    /**\n     * Store task memory for learning\n     */\n    private async storeTaskMemory(\n        prompt: string,\n        complexity: string,\n        workflowId: string,\n        results: Map<string, any>\n    ): Promise<void> {\n        const taskMemory: TaskMemory = {\n            taskId: workflowId,\n            description: prompt,\n            decomposition: [],\n            outcome: {\n                status: this.determineOverallStatus(results),\n                quality: this.calculateQuality(results),\n                improvements: this.suggestImprovements(results)\n            },\n            duration: this.calculateTotalDuration(results),\n            agentsInvolved: this.extractAgents(results),\n            lessonsLearned: this.extractLessons(results)\n        };\n\n        await this.memoryManager.store(\n            'orchestrator',\n            { prompt, complexity, taskMemory },\n            MemoryType.EPISODIC,\n            { importance: 0.7 }\n        );\n    }\n\n    /**\n     * Store complex task memory with patterns\n     */\n    private async storeComplexTaskMemory(\n        prompt: string,\n        decomposition: TaskDecomposition,\n        workflowId: string,\n        results: Map<string, any>\n    ): Promise<void> {\n        const taskMemory: TaskMemory = {\n            taskId: workflowId,\n            description: prompt,\n            decomposition: decomposition.subtasks.map(st => ({\n                stepId: st.id,\n                description: st.description,\n                assignedAgent: st.agent,\n                status: results.has(st.id) && results.get(st.id).status === 'success'\n                    ? 'completed'\n                    : 'failed',\n                output: results.get(st.id),\n                dependencies: st.dependencies\n            })),\n            outcome: {\n                status: this.determineOverallStatus(results),\n                quality: this.calculateQuality(results),\n                improvements: this.suggestImprovements(results)\n            },\n            duration: this.calculateTotalDuration(results),\n            agentsInvolved: decomposition.requiredAgents,\n            lessonsLearned: this.extractLessons(results)\n        };\n\n        await this.memoryManager.store(\n            'orchestrator',\n            { prompt, decomposition, taskMemory },\n            MemoryType.EPISODIC,\n            { importance: 0.9 }\n        );\n    }\n\n    /**\n     * Extract and store patterns from successful execution\n     */\n    private async extractAndStorePatterns(\n        decomposition: TaskDecomposition,\n        results: Map<string, any>\n    ): Promise<void> {\n        // Look for successful patterns\n        const successfulSubtasks = decomposition.subtasks.filter(st =>\n            results.has(st.id) && results.get(st.id).status === 'success'\n        );\n\n        if (successfulSubtasks.length > 0) {\n            // Store as procedural memory\n            await this.memoryManager.store(\n                'orchestrator',\n                {\n                    pattern: 'successful_decomposition',\n                    mainGoal: decomposition.mainGoal,\n                    successfulApproach: successfulSubtasks.map(st => ({\n                        agent: st.agent,\n                        task: st.description,\n                        priority: st.priority\n                    }))\n                },\n                MemoryType.PROCEDURAL,\n                { importance: 0.85 }\n            );\n        }\n\n        // Identify agent collaboration patterns\n        const collaborations = new Map<string, string[]>();\n        decomposition.dependencies.forEach(dep => {\n            const fromAgent = decomposition.subtasks.find(st => st.id === dep.from)?.agent;\n            const toAgent = decomposition.subtasks.find(st => st.id === dep.to)?.agent;\n\n            if (fromAgent && toAgent) {\n                if (!collaborations.has(fromAgent)) {\n                    collaborations.set(fromAgent, []);\n                }\n                collaborations.get(fromAgent)!.push(toAgent);\n            }\n        });\n\n        if (collaborations.size > 0) {\n            await this.memoryManager.store(\n                'orchestrator',\n                {\n                    pattern: 'agent_collaboration',\n                    collaborations: Object.fromEntries(collaborations)\n                },\n                MemoryType.SEMANTIC,\n                { importance: 0.75 }\n            );\n        }\n    }\n\n    // Utility methods for result analysis\n\n    private determineOverallStatus(results: Map<string, any>): 'success' | 'partial' | 'failure' {\n        let successes = 0;\n        let total = 0;\n\n        results.forEach(result => {\n            total++;\n            if (result.status === 'success') successes++;\n        });\n\n        const rate = successes / total;\n        if (rate === 1) return 'success';\n        if (rate >= 0.5) return 'partial';\n        return 'failure';\n    }\n\n    private calculateQuality(results: Map<string, any>): number {\n        let totalQuality = 0;\n        let count = 0;\n\n        results.forEach(result => {\n            count++;\n            totalQuality += result.status === 'success' ? 1 : 0;\n        });\n\n        return count > 0 ? totalQuality / count : 0;\n    }\n\n    private suggestImprovements(results: Map<string, any>): string[] {\n        const improvements: string[] = [];\n\n        results.forEach((result, nodeId) => {\n            if (result.status === 'failure') {\n                improvements.push(`Improve error handling for ${nodeId}`);\n            }\n            if (result.duration > 15000) {\n                improvements.push(`Optimize performance of ${nodeId}`);\n            }\n        });\n\n        return improvements;\n    }\n\n    private calculateTotalDuration(results: Map<string, any>): number {\n        let total = 0;\n        results.forEach(result => {\n            total += result.duration || 0;\n        });\n        return total;\n    }\n\n    private extractAgents(results: Map<string, any>): string[] {\n        const agents = new Set<string>();\n        results.forEach(result => {\n            if ((result as any).agent) {\n                agents.add((result as any).agent);\n            }\n        });\n        return Array.from(agents);\n    }\n\n    private extractLessons(results: Map<string, any>): string[] {\n        const lessons: string[] = [];\n\n        // Analyze failures\n        results.forEach((result, nodeId) => {\n            if (result.status === 'failure') {\n                lessons.push(`Task ${nodeId} failed: ${result.error}`);\n            }\n        });\n\n        // Analyze successes\n        const successCount = Array.from(results.values())\n            .filter(r => r.status === 'success').length;\n\n        if (successCount === results.size) {\n            lessons.push('All tasks completed successfully - workflow is reliable');\n        }\n\n        return lessons;\n    }\n\n    private createCondition(conditionStr: string): (context: any) => boolean {\n        return (context: any) => {\n            // Simple condition evaluation\n            // In production, use proper expression parser\n            return true;\n        };\n    }\n\n    /**\n     * Handle direct response for simple queries\n     */\n    private async handleDirectResponse(\n        prompt: string,\n        stream: vscode.ChatResponseStream\n    ): Promise<void> {\n        const systemPrompt = `You are an intelligent orchestrator. Answer directly and concisely.\n${this.getSystemContextPrompt()}`;\n\n        const response = await this.openAIService.chat([\n            { role: 'system', content: systemPrompt },\n            { role: 'user', content: prompt }\n        ]);\n\n        stream.markdown(response);\n    }\n\n    /**\n     * Register communication handlers\n     */\n    private registerCommunicationHandlers(): void {\n        this.communicationBus.register({\n            agentId: 'orchestrator',\n            messageTypes: [\n                MessageType.CONFLICT,\n                MessageType.STATUS_UPDATE,\n                MessageType.ERROR\n            ],\n            handler: async (message) => {\n                return await this.handleAgentMessage(message);\n            }\n        });\n    }\n\n    /**\n     * Handle messages from other agents\n     */\n    private async handleAgentMessage(message: any): Promise<any> {\n        switch (message.type) {\n            case MessageType.CONFLICT:\n                // Trigger OpusArbitrator for conflict resolution\n                return await this.resolveConflict(message.content);\n\n            case MessageType.STATUS_UPDATE:\n                // Update workflow status\n                this.updateWorkflowStatus(message.content);\n                return { acknowledged: true };\n\n            case MessageType.ERROR:\n                // Handle agent errors\n                return await this.handleAgentError(message.content);\n\n            default:\n                return { acknowledged: true };\n        }\n    }\n\n    /**\n     * Resolve conflicts between agents\n     */\n    private async resolveConflict(conflict: any): Promise<any> {\n        // Route to OpusArbitrator\n        await this.communicationBus.send({\n            from: 'orchestrator',\n            to: 'OpusArbitrator',\n            type: MessageType.CONFLICT,\n            content: conflict,\n            metadata: {\n                priority: 'critical',\n                requiresResponse: true\n            }\n        });\n\n        return { routing: 'OpusArbitrator' };\n    }\n\n    /**\n     * Update workflow status based on agent updates\n     */\n    private updateWorkflowStatus(update: any): void {\n        // Update shared context\n        this.sharedContext.updateContext(\n            'orchestrator',\n            `workflow_status_${update.workflowId}`,\n            update\n        );\n    }\n\n    /**\n     * Handle errors from agents\n     */\n    private async handleAgentError(error: any): Promise<any> {\n        // Check if we can recover\n        const recovery = await this.attemptRecovery(error);\n\n        if (recovery) {\n            return { recovery: true, action: recovery };\n        }\n\n        // Escalate to user\n        return { recovery: false, escalate: true };\n    }\n\n    /**\n     * Attempt to recover from agent errors\n     */\n    private async attemptRecovery(error: any): Promise<any> {\n        // Search memory for similar errors\n        const similarErrors = await this.memoryManager.search(error, {\n            k: 3,\n            type: MemoryType.EPISODIC\n        });\n\n        if (similarErrors.length > 0) {\n            // Found similar error with solution\n            const solution = (similarErrors[0].entry.content as any).solution;\n            if (solution) {\n                return solution;\n            }\n        }\n\n        // Try alternative agent\n        const registry = AgentRegistry.getInstance();\n        const alternativeAgent = registry.suggestAgentForTask(error.task);\n\n        if (alternativeAgent && alternativeAgent !== error.agent) {\n            return {\n                type: 'retry',\n                agent: alternativeAgent\n            };\n        }\n\n        return null;\n    }\n\n    /**\n     * Build context with memory\n     */\n    private async buildContextWithMemory(request: any): Promise<any> {\n        // Search for relevant memories\n        const memories = await this.memoryManager.search(request.prompt, {\n            k: 10,\n            type: MemoryType.EPISODIC\n        });\n\n        // Get shared context\n        const sharedContext = this.sharedContext.getContext();\n\n        return {\n            ...request,\n            memories: memories.map(m => m.entry.content),\n            sharedContext,\n            activeAgents: this.sharedContext.getActiveAgents()\n        };\n    }\n\n    // Command handlers remain similar but use new orchestration methods\n    // ... (rest of the command handlers can be kept or adapted as needed)\n\n    // Required by ChatAgent abstract class\n    protected async processWorkflowStep(\n        step: WorkflowStep,\n        request: TaskRequest,\n        previousResults: TaskResult[]\n    ): Promise<TaskResult> {\n        // Route to appropriate handler based on step type\n        const decomposition = await this.decomposeTask(request.prompt);\n\n        // Execute the specific step\n        const node: WorkflowNode = {\n            id: step.id,\n            type: 'task',\n            agentId: step.agent,\n            task: step.description\n        };\n\n        const workflow = this.workflowEngine.createWorkflow(`Step: ${step.description}`);\n        this.workflowEngine.addNode(workflow.id, node);\n\n        const results = await this.workflowEngine.execute(workflow.id);\n\n        const stepResult = results.get(step.id);\n        if (stepResult && stepResult.status === 'success') {\n            return {\n                status: 'success',\n                content: stepResult.output?.result || stepResult.output || 'Completed',\n                metadata: {\n                    step: step.id,\n                    agent: step.agent\n                }\n            };\n        }\n\n        return {\n            status: 'error',\n            content: stepResult?.error || 'Step execution failed',\n            metadata: {\n                step: step.id,\n                agent: step.agent,\n                error: stepResult?.error\n            }\n        };\n    }\n}","module.exports = require(\"child_process\");","/**\n * Unified Chat Mixin - Standardized Chat Properties for all Agents\n * Provides consistent response formatting and logging across all agents\n */\nimport * as vscode from 'vscode';\n\nexport enum ResponseType {\n    INITIALIZATION = \"initialization\",\n    EXECUTING = \"executing\",\n    SUCCESS = \"success\",\n    WARNING = \"warning\",\n    ERROR = \"error\",\n    FALLBACK = \"fallback\",\n    INFO = \"info\",\n    TOOL_USE = \"tool_use\",\n    DEBUG = \"debug\"\n}\n\nexport interface ChatConfig {\n    showEmojis: boolean;\n    showTimestamps: boolean;\n    showDetailedResponses: boolean;\n    logLevel: string;\n    responseFormat: 'detailed' | 'simple';\n    fallbackMode: 'graceful' | 'strict';\n}\n\nexport interface ResponseEntry {\n    timestamp: Date;\n    type: ResponseType;\n    agentName: string;\n    message: string;\n    details?: any;\n    formattedResponse: string;\n}\n\nexport class UnifiedChatMixin {\n    protected chatConfig: ChatConfig;\n    protected responseHistory: ResponseEntry[] = [];\n    private maxHistorySize: number = 100;\n\n    constructor() {\n        this.chatConfig = this.getDefaultChatConfig();\n        this.responseHistory = [];\n    }\n\n    /**\n     * Get default chat configuration from VS Code settings or use defaults\n     */\n    protected getDefaultChatConfig(): ChatConfig {\n        const config = vscode.workspace.getConfiguration('ki-autoagent.chat');\n        \n        return {\n            showEmojis: config.get<boolean>('showEmojis', true),\n            showTimestamps: config.get<boolean>('showTimestamps', true),\n            showDetailedResponses: config.get<boolean>('showDetailedResponses', true),\n            logLevel: config.get<string>('logLevel', 'INFO'),\n            responseFormat: config.get<'detailed' | 'simple'>('responseFormat', 'detailed'),\n            fallbackMode: config.get<'graceful' | 'strict'>('fallbackMode', 'graceful')\n        };\n    }\n\n    /**\n     * Generate unified response with consistent formatting\n     */\n    public unifiedResponse(\n        responseType: ResponseType,\n        message: string,\n        details?: Record<string, any>,\n        logToHistory: boolean = true\n    ): string {\n        const responseParts: string[] = [];\n        \n        // Add emoji if enabled\n        if (this.chatConfig.showEmojis) {\n            const emoji = this.getEmojiForType(responseType);\n            responseParts.push(`${emoji} `);\n        }\n        \n        // Add timestamp if enabled\n        if (this.chatConfig.showTimestamps) {\n            const timestamp = new Date().toLocaleTimeString('en-US', { \n                hour12: false,\n                hour: '2-digit',\n                minute: '2-digit',\n                second: '2-digit'\n            });\n            responseParts.push(`[${timestamp}] `);\n        }\n        \n        // Add agent name\n        const agentName = this.getAgentName();\n        responseParts.push(`**${agentName}**: `);\n        \n        // Add main message\n        responseParts.push(message);\n        \n        // Add details if available and detailed responses enabled\n        if (details && this.chatConfig.showDetailedResponses && this.chatConfig.responseFormat === 'detailed') {\n            responseParts.push(this.formatDetails(details));\n        }\n        \n        // Combine response\n        const formattedResponse = responseParts.join('');\n        \n        // Log to history\n        if (logToHistory) {\n            this.logToHistory(responseType, message, details, formattedResponse);\n        }\n        \n        // Log to console based on log level\n        this.logResponse(responseType, formattedResponse);\n        \n        return formattedResponse;\n    }\n\n    /**\n     * Get emoji for response type\n     */\n    private getEmojiForType(responseType: ResponseType): string {\n        const emojiMap: Record<ResponseType, string> = {\n            [ResponseType.INITIALIZATION]: \"🚀\",\n            [ResponseType.EXECUTING]: \"🛠️\",\n            [ResponseType.SUCCESS]: \"✅\",\n            [ResponseType.WARNING]: \"⚠️\",\n            [ResponseType.ERROR]: \"❌\",\n            [ResponseType.FALLBACK]: \"🔄\",\n            [ResponseType.INFO]: \"ℹ️\",\n            [ResponseType.TOOL_USE]: \"🔧\",\n            [ResponseType.DEBUG]: \"🐛\"\n        };\n        return emojiMap[responseType] || \"📝\";\n    }\n\n    /**\n     * Format details object for display\n     */\n    private formatDetails(details: Record<string, any>): string {\n        if (!details || Object.keys(details).length === 0) {\n            return '';\n        }\n        \n        const detailsStr = Object.entries(details)\n            .map(([key, value]) => {\n                const formattedKey = key.replace(/([A-Z])/g, ' $1').trim();\n                const formattedValue = typeof value === 'object' \n                    ? JSON.stringify(value, null, 2) \n                    : value;\n                return `      ${formattedKey}: ${formattedValue}`;\n            })\n            .join('\\n');\n        \n        return `\\n   📊 Details:\\n${detailsStr}`;\n    }\n\n    /**\n     * Get agent name - to be overridden by implementing classes\n     */\n    protected getAgentName(): string {\n        // Try to get from various possible properties\n        return (this as any).name || \n               (this as any).config?.agentId || \n               (this as any).config?.name ||\n               'Agent';\n    }\n\n    /**\n     * Log response to console based on log level\n     */\n    private logResponse(responseType: ResponseType, formattedResponse: string): void {\n        const logLevelMap: Record<ResponseType, string> = {\n            [ResponseType.ERROR]: 'ERROR',\n            [ResponseType.WARNING]: 'WARN',\n            [ResponseType.DEBUG]: 'DEBUG',\n            [ResponseType.INFO]: 'INFO',\n            [ResponseType.SUCCESS]: 'INFO',\n            [ResponseType.EXECUTING]: 'INFO',\n            [ResponseType.INITIALIZATION]: 'INFO',\n            [ResponseType.FALLBACK]: 'WARN',\n            [ResponseType.TOOL_USE]: 'DEBUG'\n        };\n        \n        const level = logLevelMap[responseType] || 'INFO';\n        \n        // Only log if meets minimum log level\n        if (this.shouldLog(level)) {\n            console.log(formattedResponse);\n        }\n    }\n\n    /**\n     * Check if should log based on configured log level\n     */\n    private shouldLog(level: string): boolean {\n        const levels = ['DEBUG', 'INFO', 'WARN', 'ERROR'];\n        const configuredLevel = levels.indexOf(this.chatConfig.logLevel);\n        const messageLevel = levels.indexOf(level);\n        return messageLevel >= configuredLevel;\n    }\n\n    /**\n     * Log to response history\n     */\n    private logToHistory(\n        type: ResponseType, \n        message: string, \n        details: any, \n        formattedResponse: string\n    ): void {\n        const entry: ResponseEntry = {\n            timestamp: new Date(),\n            type,\n            agentName: this.getAgentName(),\n            message,\n            details,\n            formattedResponse\n        };\n        \n        this.responseHistory.push(entry);\n        \n        // Trim history if exceeds max size\n        if (this.responseHistory.length > this.maxHistorySize) {\n            this.responseHistory = this.responseHistory.slice(-this.maxHistorySize);\n        }\n    }\n\n    // Standardized message methods\n\n    /**\n     * Show initialization message\n     */\n    public showInitialization(additionalInfo?: Record<string, any>): string {\n        const details: Record<string, any> = {\n            role: (this as any).role || 'Unknown',\n            model: (this as any).model || (this as any).selectedModel || 'Unknown'\n        };\n        \n        // Add capabilities if available\n        if (typeof (this as any).getCapabilities === 'function') {\n            details.capabilities = (this as any).getCapabilities();\n        }\n        \n        if (additionalInfo) {\n            Object.assign(details, additionalInfo);\n        }\n        \n        return this.unifiedResponse(\n            ResponseType.INITIALIZATION,\n            \"Ready to assist with advanced capabilities!\",\n            details\n        );\n    }\n\n    /**\n     * Show execution start message\n     */\n    public showExecutionStart(task: string, context?: Record<string, any>): string {\n        const details: Record<string, any> = {\n            task: task.substring(0, 100), // Truncate long tasks\n            contextKeys: context ? Object.keys(context) : []\n        };\n        \n        // Add conversation history size if available\n        if (context?.conversationHistory) {\n            details.conversationHistorySize = context.conversationHistory.length;\n        }\n        \n        return this.unifiedResponse(\n            ResponseType.EXECUTING,\n            `Starting execution: ${task.substring(0, 50)}${task.length > 50 ? '...' : ''}`,\n            details\n        );\n    }\n\n    /**\n     * Show success message\n     */\n    public showSuccess(message: string, details?: Record<string, any>): string {\n        return this.unifiedResponse(ResponseType.SUCCESS, message, details);\n    }\n\n    /**\n     * Show warning message\n     */\n    public showWarning(message: string, details?: Record<string, any>): string {\n        return this.unifiedResponse(ResponseType.WARNING, message, details);\n    }\n\n    /**\n     * Show error message\n     */\n    public showError(message: string, error?: Error | any): string {\n        const details: Record<string, any> = {};\n        \n        if (error) {\n            details.error = error.message || String(error);\n            if (error.stack && this.chatConfig.showDetailedResponses) {\n                details.stack = error.stack.split('\\n').slice(0, 3).join('\\n');\n            }\n        }\n        \n        return this.unifiedResponse(ResponseType.ERROR, message, details);\n    }\n\n    /**\n     * Show fallback mode message\n     */\n    public showFallbackMode(reason: string, fallbackAction: string): string {\n        const details = {\n            reason,\n            fallbackAction,\n            mode: this.chatConfig.fallbackMode\n        };\n        \n        return this.unifiedResponse(\n            ResponseType.FALLBACK,\n            `Switching to fallback mode: ${reason}`,\n            details\n        );\n    }\n\n    /**\n     * Show tool use message\n     */\n    public showToolUse(toolName: string, parameters?: Record<string, any>): string {\n        const details: Record<string, any> = {\n            tool: toolName\n        };\n        \n        if (parameters && this.chatConfig.showDetailedResponses) {\n            details.parameters = parameters;\n        }\n        \n        return this.unifiedResponse(\n            ResponseType.TOOL_USE,\n            `Using tool: ${toolName}`,\n            details\n        );\n    }\n\n    /**\n     * Show info message\n     */\n    public showInfo(message: string, details?: Record<string, any>): string {\n        return this.unifiedResponse(ResponseType.INFO, message, details);\n    }\n\n    /**\n     * Show debug message\n     */\n    public showDebug(message: string, details?: Record<string, any>): string {\n        return this.unifiedResponse(ResponseType.DEBUG, message, details);\n    }\n\n    // History management methods\n\n    /**\n     * Get response history\n     */\n    public getResponseHistory(): ResponseEntry[] {\n        return [...this.responseHistory]; // Return copy to prevent external modification\n    }\n\n    /**\n     * Get formatted response history\n     */\n    public getFormattedHistory(limit?: number): string {\n        const history = limit \n            ? this.responseHistory.slice(-limit)\n            : this.responseHistory;\n        \n        return history\n            .map(entry => entry.formattedResponse)\n            .join('\\n');\n    }\n\n    /**\n     * Clear response history\n     */\n    public clearHistory(): void {\n        this.responseHistory = [];\n    }\n\n    /**\n     * Export response history\n     */\n    public exportHistory(): string {\n        return JSON.stringify(this.responseHistory, null, 2);\n    }\n\n    /**\n     * Update chat configuration\n     */\n    public updateChatConfig(config: Partial<ChatConfig>): void {\n        Object.assign(this.chatConfig, config);\n    }\n\n    /**\n     * Get current chat configuration\n     */\n    public getChatConfig(): ChatConfig {\n        return { ...this.chatConfig };\n    }\n}","module.exports = require(\"vscode\");","module.exports = require(\"events\");","/**\n * AgentCommunicationBus - Inter-agent communication system\n * Enables agents to collaborate, share information, and coordinate actions\n */\n\nimport { EventEmitter } from 'events';\n\nexport interface AgentMessage {\n    id: string;\n    from: string;\n    to: string | string[] | 'broadcast';\n    type: MessageType;\n    content: any;\n    metadata: MessageMetadata;\n    timestamp: number;\n    replyTo?: string;\n}\n\nexport enum MessageType {\n    REQUEST = 'request',\n    RESPONSE = 'response',\n    NOTIFICATION = 'notification',\n    QUERY = 'query',\n    BROADCAST = 'broadcast',\n    COLLABORATION_REQUEST = 'collaboration_request',\n    COLLABORATION_RESPONSE = 'collaboration_response',\n    TASK_DELEGATION = 'task_delegation',\n    STATUS_UPDATE = 'status_update',\n    ERROR = 'error',\n    HELP_REQUEST = 'help_request',\n    KNOWLEDGE_SHARE = 'knowledge_share',\n    VALIDATION_REQUEST = 'validation_request',\n    CONFLICT = 'conflict'\n}\n\nexport interface MessageMetadata {\n    priority: 'low' | 'normal' | 'high' | 'critical';\n    requiresResponse: boolean;\n    timeout?: number;\n    conversationId?: string;\n    workflowId?: string;\n    retryCount?: number;\n    confidence?: number;\n    reasoning?: string;\n}\n\nexport interface CollaborationSession {\n    id: string;\n    task: any;\n    participants: string[];\n    leader?: string;\n    status: 'pending' | 'active' | 'completed' | 'failed';\n    sharedContext: Map<string, any>;\n    messages: AgentMessage[];\n    results: Map<string, any>;\n    startTime: number;\n    endTime?: number;\n}\n\nexport interface MessageHandler {\n    agentId: string;\n    messageTypes: MessageType[];\n    handler: (message: AgentMessage) => Promise<any>;\n    filter?: (message: AgentMessage) => boolean;\n}\n\nexport interface CommunicationStats {\n    totalMessages: number;\n    messagesByType: Map<MessageType, number>;\n    messagesByAgent: Map<string, number>;\n    averageResponseTime: number;\n    activeSessions: number;\n    failedMessages: number;\n}\n\nexport class AgentCommunicationBus {\n    private static instance: AgentCommunicationBus;\n    private eventBus: EventEmitter;\n    private handlers: Map<string, MessageHandler[]> = new Map();\n    private messageQueue: AgentMessage[] = [];\n    private processingQueue: boolean = false;\n    private collaborationSessions: Map<string, CollaborationSession> = new Map();\n    private messageHistory: AgentMessage[] = [];\n    private responseCallbacks: Map<string, (response: any) => void> = new Map();\n    private stats: CommunicationStats;\n\n    private constructor() {\n        this.eventBus = new EventEmitter();\n        this.eventBus.setMaxListeners(50);\n        this.stats = this.initializeStats();\n        this.startQueueProcessor();\n    }\n\n    public static getInstance(): AgentCommunicationBus {\n        if (!AgentCommunicationBus.instance) {\n            AgentCommunicationBus.instance = new AgentCommunicationBus();\n        }\n        return AgentCommunicationBus.instance;\n    }\n\n    /**\n     * Register an agent to receive messages\n     */\n    public register(handler: MessageHandler): void {\n        if (!this.handlers.has(handler.agentId)) {\n            this.handlers.set(handler.agentId, []);\n        }\n\n        this.handlers.get(handler.agentId)!.push(handler);\n        this.eventBus.emit('agent-registered', handler.agentId);\n    }\n\n    /**\n     * Unregister an agent\n     */\n    public unregister(agentId: string): void {\n        this.handlers.delete(agentId);\n        this.eventBus.emit('agent-unregistered', agentId);\n    }\n\n    /**\n     * Send a message to one or more agents\n     */\n    public async send(message: Omit<AgentMessage, 'id' | 'timestamp'>): Promise<string> {\n        const fullMessage: AgentMessage = {\n            ...message,\n            id: this.generateMessageId(),\n            timestamp: Date.now()\n        };\n\n        // Add to history\n        this.messageHistory.push(fullMessage);\n        this.stats.totalMessages++;\n        this.updateStats(fullMessage);\n\n        // Add to queue\n        this.messageQueue.push(fullMessage);\n\n        // Emit event\n        this.eventBus.emit('message-sent', fullMessage);\n\n        // Process queue if not already processing\n        if (!this.processingQueue) {\n            this.processQueue();\n        }\n\n        return fullMessage.id;\n    }\n\n    /**\n     * Send a message and wait for response\n     */\n    public async request(\n        message: Omit<AgentMessage, 'id' | 'timestamp'>,\n        timeout: number = 30000\n    ): Promise<any> {\n        const messageId = await this.send({\n            ...message,\n            metadata: {\n                ...(message.metadata || {}),\n                requiresResponse: true,\n                timeout\n            }\n        });\n\n        return new Promise((resolve, reject) => {\n            const timer = setTimeout(() => {\n                this.responseCallbacks.delete(messageId);\n                reject(new Error(`Request timeout for message ${messageId}`));\n            }, timeout);\n\n            this.responseCallbacks.set(messageId, (response) => {\n                clearTimeout(timer);\n                this.responseCallbacks.delete(messageId);\n                resolve(response);\n            });\n        });\n    }\n\n    /**\n     * Broadcast a message to all agents\n     */\n    public async broadcast(\n        from: string,\n        type: MessageType,\n        content: any,\n        metadata?: Partial<MessageMetadata>\n    ): Promise<void> {\n        await this.send({\n            from,\n            to: 'broadcast',\n            type: MessageType.BROADCAST,\n            content,\n            metadata: {\n                priority: 'normal',\n                requiresResponse: false,\n                ...metadata\n            }\n        });\n    }\n\n    /**\n     * Start a collaboration session between agents\n     */\n    public async startCollaboration(\n        task: any,\n        participants: string[],\n        leader?: string\n    ): Promise<CollaborationSession> {\n        const session: CollaborationSession = {\n            id: this.generateSessionId(),\n            task,\n            participants,\n            leader: leader || participants[0],\n            status: 'pending',\n            sharedContext: new Map(),\n            messages: [],\n            results: new Map(),\n            startTime: Date.now()\n        };\n\n        this.collaborationSessions.set(session.id, session);\n\n        // Notify all participants\n        await Promise.all(participants.map(agentId =>\n            this.send({\n                from: 'system',\n                to: agentId,\n                type: MessageType.COLLABORATION_REQUEST,\n                content: {\n                    sessionId: session.id,\n                    task,\n                    participants,\n                    leader: session.leader\n                },\n                metadata: {\n                    priority: 'high',\n                    requiresResponse: true,\n                    conversationId: session.id\n                }\n            })\n        ));\n\n        session.status = 'active';\n        this.eventBus.emit('collaboration-started', session);\n\n        return session;\n    }\n\n    /**\n     * Send a message within a collaboration session\n     */\n    public async collaborationMessage(\n        sessionId: string,\n        from: string,\n        content: any,\n        type: MessageType = MessageType.NOTIFICATION\n    ): Promise<void> {\n        const session = this.collaborationSessions.get(sessionId);\n        if (!session) {\n            throw new Error(`Collaboration session ${sessionId} not found`);\n        }\n\n        // Send to all participants except sender\n        const recipients = session.participants.filter(p => p !== from);\n\n        const message = {\n            from,\n            to: recipients,\n            type,\n            content,\n            metadata: {\n                priority: 'normal' as const,\n                requiresResponse: false,\n                conversationId: sessionId\n            }\n        };\n\n        await this.send(message);\n\n        // Add to session history\n        session.messages.push({\n            ...message,\n            id: this.generateMessageId(),\n            timestamp: Date.now()\n        });\n    }\n\n    /**\n     * Update shared context in collaboration session\n     */\n    public updateCollaborationContext(\n        sessionId: string,\n        agentId: string,\n        key: string,\n        value: any\n    ): void {\n        const session = this.collaborationSessions.get(sessionId);\n        if (!session) return;\n\n        session.sharedContext.set(key, value);\n\n        // Notify other participants\n        this.collaborationMessage(\n            sessionId,\n            agentId,\n            { key, value },\n            MessageType.STATUS_UPDATE\n        );\n    }\n\n    /**\n     * Complete a collaboration session\n     */\n    public completeCollaboration(sessionId: string, results: Map<string, any>): void {\n        const session = this.collaborationSessions.get(sessionId);\n        if (!session) return;\n\n        session.status = 'completed';\n        session.results = results;\n        session.endTime = Date.now();\n\n        this.eventBus.emit('collaboration-completed', session);\n\n        // Clean up after delay\n        setTimeout(() => {\n            this.collaborationSessions.delete(sessionId);\n        }, 60000);\n    }\n\n    /**\n     * Request help from other agents\n     */\n    public async requestHelp(\n        from: string,\n        problem: any,\n        preferredAgents?: string[]\n    ): Promise<any> {\n        const message = {\n            from,\n            to: preferredAgents || 'broadcast',\n            type: MessageType.HELP_REQUEST,\n            content: problem,\n            metadata: {\n                priority: 'high' as const,\n                requiresResponse: true,\n                timeout: 10000\n            }\n        };\n\n        const responses: any[] = [];\n\n        if (preferredAgents) {\n            // Request from specific agents\n            for (const agentId of preferredAgents) {\n                try {\n                    const response = await this.request(\n                        { ...message, to: agentId, metadata: message.metadata },\n                        10000\n                    );\n                    if (response) responses.push(response);\n                } catch (error) {\n                    console.warn(`No response from ${agentId}:`, error);\n                }\n            }\n        } else {\n            // Broadcast and collect responses\n            await this.broadcast(from, MessageType.HELP_REQUEST, problem, {\n                priority: 'high',\n                requiresResponse: true\n            });\n\n            // Wait for responses\n            await new Promise(resolve => setTimeout(resolve, 5000));\n\n            // Collect responses from history\n            const requestTime = Date.now();\n            responses.push(...this.messageHistory\n                .filter(msg =>\n                    msg.type === MessageType.RESPONSE &&\n                    msg.timestamp > requestTime - 5000 &&\n                    msg.replyTo === message.from\n                )\n                .map(msg => msg.content)\n            );\n        }\n\n        return responses;\n    }\n\n    /**\n     * Share knowledge between agents\n     */\n    public async shareKnowledge(\n        from: string,\n        knowledge: any,\n        relevantAgents?: string[]\n    ): Promise<void> {\n        await this.send({\n            from,\n            to: relevantAgents || 'broadcast',\n            type: MessageType.KNOWLEDGE_SHARE,\n            content: knowledge,\n            metadata: {\n                priority: 'low',\n                requiresResponse: false\n            }\n        });\n    }\n\n    /**\n     * Request validation from another agent\n     */\n    public async requestValidation(\n        from: string,\n        validator: string,\n        content: any\n    ): Promise<any> {\n        return this.request({\n            from,\n            to: validator,\n            type: MessageType.VALIDATION_REQUEST,\n            content,\n            metadata: {\n                priority: 'normal',\n                requiresResponse: true\n            }\n        }, 15000);\n    }\n\n    /**\n     * Report a conflict requiring arbitration\n     */\n    public async reportConflict(\n        reportingAgent: string,\n        conflictingAgents: string[],\n        issue: any\n    ): Promise<void> {\n        // Send to OpusArbitrator\n        await this.send({\n            from: reportingAgent,\n            to: 'OpusArbitrator',\n            type: MessageType.CONFLICT,\n            content: {\n                conflictingAgents,\n                issue,\n                reportedBy: reportingAgent\n            },\n            metadata: {\n                priority: 'critical',\n                requiresResponse: true\n            }\n        });\n    }\n\n    /**\n     * Process message queue\n     */\n    private async processQueue(): Promise<void> {\n        if (this.processingQueue || this.messageQueue.length === 0) return;\n\n        this.processingQueue = true;\n\n        while (this.messageQueue.length > 0) {\n            const message = this.messageQueue.shift()!;\n\n            try {\n                await this.deliverMessage(message);\n            } catch (error) {\n                console.error(`Error delivering message ${message.id}:`, error);\n                this.stats.failedMessages++;\n\n                // Retry logic\n                if (message.metadata.retryCount === undefined) {\n                    message.metadata.retryCount = 0;\n                }\n\n                if (message.metadata.retryCount < 3) {\n                    message.metadata.retryCount++;\n                    this.messageQueue.push(message);\n                } else {\n                    this.eventBus.emit('message-failed', { message, error });\n                }\n            }\n        }\n\n        this.processingQueue = false;\n    }\n\n    /**\n     * Deliver a message to recipients\n     */\n    private async deliverMessage(message: AgentMessage): Promise<void> {\n        const recipients = this.determineRecipients(message);\n\n        for (const recipientId of recipients) {\n            const handlers = this.handlers.get(recipientId) || [];\n\n            for (const handler of handlers) {\n                // Check if handler accepts this message type\n                if (!handler.messageTypes.includes(message.type)) continue;\n\n                // Apply filter if present\n                if (handler.filter && !handler.filter(message)) continue;\n\n                try {\n                    const response = await handler.handler(message);\n\n                    // Handle response if required\n                    if (message.metadata.requiresResponse && response !== undefined) {\n                        // Send response back\n                        await this.send({\n                            from: recipientId,\n                            to: message.from,\n                            type: MessageType.RESPONSE,\n                            content: response,\n                            metadata: {\n                                priority: 'normal',\n                                requiresResponse: false,\n                                conversationId: message.metadata.conversationId\n                            },\n                            replyTo: message.id\n                        });\n\n                        // Trigger callback if waiting\n                        const callback = this.responseCallbacks.get(message.id);\n                        if (callback) {\n                            callback(response);\n                        }\n                    }\n\n                    this.eventBus.emit('message-delivered', { message, recipientId });\n                } catch (error) {\n                    console.error(`Handler error for ${recipientId}:`, error);\n                    this.eventBus.emit('handler-error', { message, recipientId, error });\n                }\n            }\n        }\n    }\n\n    /**\n     * Determine message recipients\n     */\n    private determineRecipients(message: AgentMessage): string[] {\n        if (message.to === 'broadcast') {\n            return Array.from(this.handlers.keys());\n        }\n\n        if (Array.isArray(message.to)) {\n            return message.to;\n        }\n\n        return [message.to];\n    }\n\n    /**\n     * Start queue processor\n     */\n    private startQueueProcessor(): void {\n        setInterval(() => {\n            if (!this.processingQueue && this.messageQueue.length > 0) {\n                this.processQueue();\n            }\n        }, 100);\n    }\n\n    /**\n     * Initialize statistics\n     */\n    private initializeStats(): CommunicationStats {\n        return {\n            totalMessages: 0,\n            messagesByType: new Map(),\n            messagesByAgent: new Map(),\n            averageResponseTime: 0,\n            activeSessions: 0,\n            failedMessages: 0\n        };\n    }\n\n    /**\n     * Update statistics\n     */\n    private updateStats(message: AgentMessage): void {\n        // Update message type count\n        const typeCount = this.stats.messagesByType.get(message.type) || 0;\n        this.stats.messagesByType.set(message.type, typeCount + 1);\n\n        // Update agent message count\n        const agentCount = this.stats.messagesByAgent.get(message.from) || 0;\n        this.stats.messagesByAgent.set(message.from, agentCount + 1);\n\n        // Update active sessions\n        this.stats.activeSessions = this.collaborationSessions.size;\n    }\n\n    /**\n     * Get communication statistics\n     */\n    public getStats(): CommunicationStats {\n        // Calculate average response time\n        let totalResponseTime = 0;\n        let responseCount = 0;\n\n        this.messageHistory.forEach(msg => {\n            if (msg.type === MessageType.RESPONSE && msg.replyTo) {\n                const originalMsg = this.messageHistory.find(m => m.id === msg.replyTo);\n                if (originalMsg) {\n                    totalResponseTime += msg.timestamp - originalMsg.timestamp;\n                    responseCount++;\n                }\n            }\n        });\n\n        this.stats.averageResponseTime = responseCount > 0\n            ? totalResponseTime / responseCount\n            : 0;\n\n        return { ...this.stats };\n    }\n\n    /**\n     * Get message history\n     */\n    public getMessageHistory(filter?: {\n        from?: string;\n        to?: string;\n        type?: MessageType;\n        conversationId?: string;\n        startTime?: number;\n        endTime?: number;\n    }): AgentMessage[] {\n        let history = [...this.messageHistory];\n\n        if (filter) {\n            if (filter.from) {\n                history = history.filter(msg => msg.from === filter.from);\n            }\n            if (filter.to) {\n                history = history.filter(msg =>\n                    msg.to === filter.to ||\n                    (Array.isArray(msg.to) && msg.to.includes(filter.to!))\n                );\n            }\n            if (filter.type) {\n                history = history.filter(msg => msg.type === filter.type);\n            }\n            if (filter.conversationId) {\n                history = history.filter(msg =>\n                    msg.metadata.conversationId === filter.conversationId\n                );\n            }\n            if (filter.startTime) {\n                history = history.filter(msg => msg.timestamp >= filter.startTime!);\n            }\n            if (filter.endTime) {\n                history = history.filter(msg => msg.timestamp <= filter.endTime!);\n            }\n        }\n\n        return history;\n    }\n\n    /**\n     * Get active collaboration sessions\n     */\n    public getActiveSessions(): CollaborationSession[] {\n        return Array.from(this.collaborationSessions.values())\n            .filter(session => session.status === 'active');\n    }\n\n    /**\n     * Generate unique message ID\n     */\n    private generateMessageId(): string {\n        return `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    }\n\n    /**\n     * Generate unique session ID\n     */\n    private generateSessionId(): string {\n        return `ses_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    }\n\n    /**\n     * Clear all data (for testing/reset)\n     */\n    public clear(): void {\n        this.messageQueue = [];\n        this.messageHistory = [];\n        this.collaborationSessions.clear();\n        this.responseCallbacks.clear();\n        this.stats = this.initializeStats();\n    }\n}\n\n// Export singleton instance getter\nexport function getCommunicationBus(): AgentCommunicationBus {\n    return AgentCommunicationBus.getInstance();\n}","/**\n * Agent Configuration Manager\n * Handles per-agent model selection, instruction loading, and self-adaptation\n */\nimport * as vscode from 'vscode';\nimport * as path from 'path';\nimport * as fs from 'fs/promises';\nimport { \n    AgentModelConfig, \n    InstructionSet, \n    LearningConfig, \n    PerformanceMetrics,\n    InstructionAdaptation,\n    AgentConfigurationSystem,\n    AVAILABLE_MODELS,\n    DEFAULT_AGENT_MODELS\n} from '../types/AgentConfiguration';\n\nexport class AgentConfigurationManager {\n    private static instance: AgentConfigurationManager;\n    private configPath: string = '';\n    private configuration: AgentConfigurationSystem;\n    private context: vscode.ExtensionContext;\n\n    private constructor(context: vscode.ExtensionContext) {\n        this.context = context;\n        this.configuration = {\n            models: new Map(),\n            instructions: new Map(),\n            learning: this.getDefaultLearningConfig(),\n            metrics: new Map()\n        };\n    }\n\n    public static getInstance(context: vscode.ExtensionContext): AgentConfigurationManager {\n        if (!AgentConfigurationManager.instance) {\n            AgentConfigurationManager.instance = new AgentConfigurationManager(context);\n        }\n        return AgentConfigurationManager.instance;\n    }\n\n    /**\n     * Initialize configuration system\n     */\n    public async initialize(): Promise<void> {\n        try {\n            // Determine configuration path\n            await this.determineConfigPath();\n            \n            // Ensure configuration directory structure exists\n            await this.ensureConfigStructure();\n            \n            // Load existing configuration or create defaults\n            await this.loadConfiguration();\n            \n            // Load instruction sets\n            await this.loadInstructionSets();\n            \n            console.log('✅ AgentConfigurationManager initialized');\n        } catch (error) {\n            console.error('❌ Failed to initialize AgentConfigurationManager:', error);\n            throw error;\n        }\n    }\n\n    /**\n     * Get agent model configuration\n     */\n    public getAgentModel(agentId: string): string {\n        const config = this.configuration.models.get(agentId);\n        return config?.selectedModel || DEFAULT_AGENT_MODELS[agentId as keyof typeof DEFAULT_AGENT_MODELS] || 'claude-sonnet-4-20250514';\n    }\n\n    /**\n     * Set agent model\n     */\n    public async setAgentModel(agentId: string, modelId: string): Promise<void> {\n        const config = this.configuration.models.get(agentId) || this.createDefaultModelConfig(agentId);\n        config.selectedModel = modelId;\n        config.lastUpdated = new Date().toISOString();\n        \n        this.configuration.models.set(agentId, config);\n        await this.saveModelConfiguration();\n        \n        console.log(`🤖 Updated ${agentId} model to ${modelId}`);\n    }\n\n    /**\n     * Get agent instructions\n     */\n    public async getAgentInstructions(agentId: string): Promise<string> {\n        const instructionSet = this.configuration.instructions.get(agentId);\n        if (instructionSet) {\n            return instructionSet.content;\n        }\n        \n        // Load from file if not in memory\n        return await this.loadInstructionFile(agentId);\n    }\n\n    /**\n     * Update agent instructions (self-adaptation)\n     */\n    public async updateAgentInstructions(\n        agentId: string, \n        newContent: string, \n        reason: string, \n        trigger: 'success' | 'failure' | 'manual' | 'learning'\n    ): Promise<void> {\n        const currentInstructions = await this.getAgentInstructions(agentId);\n        \n        // Create adaptation record\n        const adaptation: InstructionAdaptation = {\n            timestamp: new Date().toISOString(),\n            trigger,\n            oldContent: currentInstructions,\n            newContent,\n            reason\n        };\n\n        // Update instruction set\n        const instructionSet = this.configuration.instructions.get(agentId) || {\n            agentId,\n            version: '1.0.0',\n            content: currentInstructions,\n            lastModified: new Date().toISOString(),\n            modifiedBy: trigger === 'manual' ? 'user' : 'self-adaptation',\n            successRate: 0,\n            totalExecutions: 0,\n            adaptationHistory: []\n        };\n\n        instructionSet.content = newContent;\n        instructionSet.lastModified = new Date().toISOString();\n        instructionSet.modifiedBy = trigger === 'manual' ? 'user' : 'self-adaptation';\n        instructionSet.adaptationHistory.push(adaptation);\n        \n        // Keep only last 50 adaptations to prevent memory bloat\n        if (instructionSet.adaptationHistory.length > 50) {\n            instructionSet.adaptationHistory = instructionSet.adaptationHistory.slice(-50);\n        }\n\n        this.configuration.instructions.set(agentId, instructionSet);\n        \n        // Save to file\n        await this.saveInstructionFile(agentId, instructionSet);\n        \n        console.log(`📝 Updated instructions for ${agentId}: ${reason}`);\n    }\n\n    /**\n     * Record agent performance for learning\n     */\n    public async recordAgentPerformance(\n        agentId: string,\n        success: boolean,\n        responseTime: number,\n        context?: string\n    ): Promise<void> {\n        const metrics = this.configuration.metrics.get(agentId) || this.createDefaultMetrics(agentId);\n        \n        metrics.totalExecutions++;\n        if (success) {\n            metrics.successfulExecutions++;\n            metrics.currentStreak++;\n            metrics.bestStreak = Math.max(metrics.bestStreak, metrics.currentStreak);\n        } else {\n            metrics.failedExecutions++;\n            metrics.currentStreak = 0;\n        }\n        \n        // Update average response time\n        const totalTime = metrics.averageResponseTime * (metrics.totalExecutions - 1) + responseTime;\n        metrics.averageResponseTime = totalTime / metrics.totalExecutions;\n        metrics.lastExecution = new Date().toISOString();\n        \n        this.configuration.metrics.set(agentId, metrics);\n        \n        // Check if auto-learning should trigger\n        if (this.configuration.learning.enabled) {\n            await this.checkForLearningOpportunity(agentId, success, context);\n        }\n        \n        // Periodically save metrics\n        if (metrics.totalExecutions % 10 === 0) {\n            await this.saveMetrics();\n        }\n    }\n\n    /**\n     * Get available models for an agent\n     */\n    public getAvailableModels(): Record<string, any> {\n        return AVAILABLE_MODELS;\n    }\n\n    /**\n     * Get agent performance metrics\n     */\n    public getAgentMetrics(agentId: string): PerformanceMetrics | undefined {\n        return this.configuration.metrics.get(agentId);\n    }\n\n    /**\n     * Get learning configuration\n     */\n    public getLearningConfig(): LearningConfig {\n        return this.configuration.learning;\n    }\n\n    /**\n     * Update learning configuration\n     */\n    public async updateLearningConfig(config: Partial<LearningConfig>): Promise<void> {\n        this.configuration.learning = { ...this.configuration.learning, ...config };\n        await this.saveLearningConfig();\n    }\n\n    // Private methods\n    private async determineConfigPath(): Promise<void> {\n        const workspaceFolders = vscode.workspace.workspaceFolders;\n        if (workspaceFolders && workspaceFolders.length > 0) {\n            // Use workspace-specific configuration\n            this.configPath = path.join(workspaceFolders[0].uri.fsPath, '.kiautoagent');\n        } else {\n            // Use global configuration in user's home directory\n            const homeDir = process.env.HOME || process.env.USERPROFILE || '';\n            this.configPath = path.join(homeDir, '.kiautoagent');\n        }\n    }\n\n    private async ensureConfigStructure(): Promise<void> {\n        const directories = [\n            this.configPath,\n            path.join(this.configPath, 'config'),\n            path.join(this.configPath, 'instructionsets'),\n            path.join(this.configPath, 'learning')\n        ];\n\n        for (const dir of directories) {\n            try {\n                await fs.mkdir(dir, { recursive: true });\n            } catch (error) {\n                console.warn(`Could not create directory ${dir}:`, error);\n            }\n        }\n    }\n\n    private async loadConfiguration(): Promise<void> {\n        // Load model configurations\n        await this.loadModelConfiguration();\n        \n        // Load learning configuration\n        await this.loadLearningConfiguration();\n        \n        // Load metrics\n        await this.loadMetrics();\n    }\n\n    private async loadModelConfiguration(): Promise<void> {\n        try {\n            const configFile = path.join(this.configPath, 'config', 'agent-models.json');\n            const data = await fs.readFile(configFile, 'utf-8');\n            const configs = JSON.parse(data);\n            \n            for (const config of configs) {\n                this.configuration.models.set(config.agentId, config);\n            }\n        } catch (error) {\n            // Create default configuration\n            for (const [agentId, defaultModel] of Object.entries(DEFAULT_AGENT_MODELS)) {\n                this.configuration.models.set(agentId, this.createDefaultModelConfig(agentId));\n            }\n            await this.saveModelConfiguration();\n        }\n    }\n\n    private async saveModelConfiguration(): Promise<void> {\n        try {\n            const configFile = path.join(this.configPath, 'config', 'agent-models.json');\n            const configs = Array.from(this.configuration.models.values());\n            await fs.writeFile(configFile, JSON.stringify(configs, null, 2));\n        } catch (error) {\n            console.error('Failed to save model configuration:', error);\n        }\n    }\n\n    private async loadInstructionSets(): Promise<void> {\n        const instructionDir = path.join(this.configPath, 'instructionsets');\n        const agentIds = ['orchestrator', 'richter', 'architect', 'codesmith', 'tradestrat', 'research'];\n        \n        for (const agentId of agentIds) {\n            try {\n                await this.loadInstructionFile(agentId);\n            } catch (error) {\n                console.warn(`Could not load instructions for ${agentId}:`, error);\n                // Copy from extension bundle\n                await this.copyDefaultInstructionFile(agentId);\n            }\n        }\n    }\n\n    private async loadInstructionFile(agentId: string): Promise<string> {\n        const instructionFile = path.join(this.configPath, 'instructionsets', `${agentId}.md`);\n        try {\n            const content = await fs.readFile(instructionFile, 'utf-8');\n            \n            // Update in-memory instruction set\n            const instructionSet: InstructionSet = {\n                agentId,\n                version: '1.0.0',\n                content,\n                lastModified: new Date().toISOString(),\n                modifiedBy: 'user',\n                successRate: 0,\n                totalExecutions: 0,\n                adaptationHistory: []\n            };\n            \n            this.configuration.instructions.set(agentId, instructionSet);\n            return content;\n        } catch (error) {\n            throw new Error(`Could not load instruction file for ${agentId}: ${error}`);\n        }\n    }\n\n    private async saveInstructionFile(agentId: string, instructionSet: InstructionSet): Promise<void> {\n        const instructionFile = path.join(this.configPath, 'instructionsets', `${agentId}.md`);\n        await fs.writeFile(instructionFile, instructionSet.content);\n    }\n\n    private async copyDefaultInstructionFile(agentId: string): Promise<void> {\n        try {\n            const sourcePath = path.join(this.context.extensionPath, 'src', 'instructionsets', `${agentId}.md`);\n            const targetPath = path.join(this.configPath, 'instructionsets', `${agentId}.md`);\n            \n            const content = await fs.readFile(sourcePath, 'utf-8');\n            await fs.writeFile(targetPath, content);\n            \n            console.log(`📋 Copied default instructions for ${agentId}`);\n        } catch (error) {\n            console.error(`Failed to copy default instructions for ${agentId}:`, error);\n        }\n    }\n\n    private createDefaultModelConfig(agentId: string): AgentModelConfig {\n        const defaultModel = DEFAULT_AGENT_MODELS[agentId as keyof typeof DEFAULT_AGENT_MODELS] || 'claude-sonnet-4-20250514';\n        \n        return {\n            agentId,\n            displayName: agentId.charAt(0).toUpperCase() + agentId.slice(1),\n            selectedModel: defaultModel,\n            availableModels: Object.keys(AVAILABLE_MODELS),\n            instructionFile: `${agentId}.md`,\n            lastUpdated: new Date().toISOString(),\n            performanceScore: 0\n        };\n    }\n\n    private createDefaultMetrics(agentId: string): PerformanceMetrics {\n        return {\n            agentId,\n            totalExecutions: 0,\n            successfulExecutions: 0,\n            failedExecutions: 0,\n            averageResponseTime: 0,\n            lastExecution: new Date().toISOString(),\n            successPatterns: [],\n            failurePatterns: [],\n            currentStreak: 0,\n            bestStreak: 0\n        };\n    }\n\n    private getDefaultLearningConfig(): LearningConfig {\n        return {\n            enabled: true,\n            adaptationThreshold: 0.8, // 80% success rate required\n            maxAdaptationsPerDay: 3,\n            confidenceLevel: 0.9,\n            learningModes: {\n                successBasedLearning: true,\n                failureBasedLearning: false,\n                patternRecognition: true,\n                contextualAdaptation: true\n            }\n        };\n    }\n\n    private async loadLearningConfiguration(): Promise<void> {\n        try {\n            const configFile = path.join(this.configPath, 'config', 'learning-settings.json');\n            const data = await fs.readFile(configFile, 'utf-8');\n            this.configuration.learning = { ...this.configuration.learning, ...JSON.parse(data) };\n        } catch (error) {\n            // Use defaults and save\n            await this.saveLearningConfig();\n        }\n    }\n\n    private async saveLearningConfig(): Promise<void> {\n        try {\n            const configFile = path.join(this.configPath, 'config', 'learning-settings.json');\n            await fs.writeFile(configFile, JSON.stringify(this.configuration.learning, null, 2));\n        } catch (error) {\n            console.error('Failed to save learning configuration:', error);\n        }\n    }\n\n    private async loadMetrics(): Promise<void> {\n        try {\n            const metricsFile = path.join(this.configPath, 'config', 'performance-metrics.json');\n            const data = await fs.readFile(metricsFile, 'utf-8');\n            const metricsArray = JSON.parse(data);\n            \n            for (const metrics of metricsArray) {\n                this.configuration.metrics.set(metrics.agentId, metrics);\n            }\n        } catch (error) {\n            // No metrics file yet, will be created on first save\n        }\n    }\n\n    private async saveMetrics(): Promise<void> {\n        try {\n            const metricsFile = path.join(this.configPath, 'config', 'performance-metrics.json');\n            const metricsArray = Array.from(this.configuration.metrics.values());\n            await fs.writeFile(metricsFile, JSON.stringify(metricsArray, null, 2));\n        } catch (error) {\n            console.error('Failed to save metrics:', error);\n        }\n    }\n\n    private async checkForLearningOpportunity(agentId: string, success: boolean, context?: string): Promise<void> {\n        const metrics = this.configuration.metrics.get(agentId);\n        if (!metrics) return;\n\n        const successRate = metrics.successfulExecutions / metrics.totalExecutions;\n        \n        // Only adapt if we have enough data and high success rate\n        if (metrics.totalExecutions < 10) return;\n        if (successRate < this.configuration.learning.adaptationThreshold) return;\n        \n        // Check if we haven't adapted too much today\n        const today = new Date().toDateString();\n        const instructionSet = this.configuration.instructions.get(agentId);\n        const todayAdaptations = instructionSet?.adaptationHistory.filter(\n            a => new Date(a.timestamp).toDateString() === today\n        ).length || 0;\n        \n        if (todayAdaptations >= this.configuration.learning.maxAdaptationsPerDay) return;\n        \n        // Trigger learning adaptation (would call LLM to analyze patterns and suggest improvements)\n        console.log(`🧠 Learning opportunity detected for ${agentId}: ${successRate.toFixed(2)} success rate`);\n        \n        // This would be implemented to call the agent's model to analyze its own performance\n        // and suggest instruction improvements\n    }\n}","/**\n * Memory Types for the Multi-Agent System\n * Defines the structure of different memory types and operations\n */\n\nexport interface MemoryEntry {\n    id: string;\n    agentId: string;\n    timestamp: number;\n    content: any;\n    embedding?: number[];\n    metadata: MemoryMetadata;\n    type: MemoryType;\n}\n\nexport interface MemoryMetadata {\n    projectId?: string;\n    taskId?: string;\n    confidence?: number;\n    tags?: string[];\n    source?: string;\n    relatedMemories?: string[];\n    accessCount?: number;\n    lastAccessed?: number;\n    importance?: number;\n}\n\nexport enum MemoryType {\n    WORKING = 'working',      // Current task context\n    EPISODIC = 'episodic',    // Specific events/interactions\n    SEMANTIC = 'semantic',    // General knowledge\n    PROCEDURAL = 'procedural' // How to do things\n}\n\nexport interface MemorySearchResult {\n    entry: MemoryEntry;\n    similarity: number;\n    relevance: number;\n}\n\nexport interface MemoryPattern {\n    id: string;\n    pattern: string;\n    frequency: number;\n    examples: MemoryEntry[];\n    extractedAt: number;\n}\n\nexport interface MemoryCluster {\n    centroid: number[];\n    members: MemoryEntry[];\n    label?: string;\n    coherence: number;\n}\n\nexport interface CodePattern {\n    id: string;\n    language: string;\n    pattern: string;\n    description: string;\n    usage: string[];\n    examples: CodeExample[];\n    successRate: number;\n    lastUsed: number;\n}\n\nexport interface CodeExample {\n    code: string;\n    context: string;\n    outcome: 'success' | 'failure' | 'partial';\n    feedback?: string;\n}\n\nexport interface ArchitecturePattern {\n    id: string;\n    name: string;\n    type: 'microservices' | 'monolith' | 'serverless' | 'hybrid' | 'other';\n    description: string;\n    components: ArchitectureComponent[];\n    useCases: string[];\n    pros: string[];\n    cons: string[];\n    diagram?: string;\n}\n\nexport interface ArchitectureComponent {\n    name: string;\n    responsibility: string;\n    technologies: string[];\n    interfaces: string[];\n    dependencies: string[];\n}\n\nexport interface TaskMemory {\n    taskId: string;\n    description: string;\n    decomposition: TaskStep[];\n    outcome: TaskOutcome;\n    duration: number;\n    agentsInvolved: string[];\n    lessonsLearned: string[];\n}\n\nexport interface TaskStep {\n    stepId: string;\n    description: string;\n    assignedAgent: string;\n    status: 'pending' | 'in_progress' | 'completed' | 'failed';\n    output?: any;\n    dependencies: string[];\n}\n\nexport interface TaskOutcome {\n    status: 'success' | 'partial' | 'failure';\n    quality: number; // 0-1\n    feedback?: string;\n    improvements?: string[];\n}\n\nexport interface ConversationMemory {\n    conversationId: string;\n    participants: string[];\n    messages: Message[];\n    context: Map<string, any>;\n    summary?: string;\n    keyDecisions: Decision[];\n    timestamp: number;\n}\n\nexport interface Message {\n    id: string;\n    sender: string;\n    content: string;\n    timestamp: number;\n    intent?: string;\n    entities?: Entity[];\n}\n\nexport interface Entity {\n    type: string;\n    value: string;\n    confidence: number;\n}\n\nexport interface Decision {\n    id: string;\n    description: string;\n    madeBy: string;\n    reasoning: string;\n    alternatives: string[];\n    outcome?: string;\n    timestamp: number;\n}\n\nexport interface LearningEntry {\n    id: string;\n    type: 'success' | 'failure' | 'insight';\n    description: string;\n    context: any;\n    impact: 'high' | 'medium' | 'low';\n    applicability: string[];\n    timestamp: number;\n}\n\nexport interface MemoryStats {\n    totalMemories: number;\n    byType: Map<MemoryType, number>;\n    byAgent: Map<string, number>;\n    averageAccessCount: number;\n    mostAccessedMemories: MemoryEntry[];\n    memoryGrowthRate: number;\n    patternCount: number;\n    clusterCount: number;\n}","/**\n * OpenAI Service for GPT model interactions\n */\nimport * as vscode from 'vscode';\n\ninterface ChatMessage {\n    role: 'system' | 'user' | 'assistant';\n    content: string;\n}\n\ninterface ChatResponse {\n    choices: Array<{\n        message: {\n            content: string;\n        };\n    }>;\n}\n\nexport class OpenAIService {\n    private apiKey: string;\n    private baseURL: string;\n\n    constructor() {\n        const config = vscode.workspace.getConfiguration('kiAutoAgent');\n        this.apiKey = config.get<string>('openai.apiKey', '');\n        this.baseURL = 'https://api.openai.com/v1';\n    }\n\n    async chat(\n        messages: ChatMessage[],\n        model: string = 'gpt-4o',\n        maxTokens: number = 4000,\n        temperature: number = 0.7\n    ): Promise<string> {\n        \n        if (!this.apiKey) {\n            throw new Error('OpenAI API key not configured');\n        }\n\n        const requestBody = {\n            model,\n            messages,\n            max_tokens: maxTokens,\n            temperature,\n            stream: false\n        };\n\n        try {\n            const response = await fetch(`${this.baseURL}/chat/completions`, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'Authorization': `Bearer ${this.apiKey}`\n                },\n                body: JSON.stringify(requestBody)\n            });\n\n            if (!response.ok) {\n                const errorData = await response.json().catch(() => ({ error: { message: response.statusText } }));\n                throw new Error(`OpenAI API error: ${(errorData as any).error?.message || response.statusText}`);\n            }\n\n            const data= await response.json() as ChatResponse;\n            \n            if (!data.choices || data.choices.length === 0) {\n                throw new Error('No response from OpenAI API');\n            }\n\n            return data.choices[0].message.content;\n\n        } catch (error) {\n            if (error instanceof Error) {\n                throw error;\n            }\n            throw new Error(`OpenAI API request failed: ${error}`);\n        }\n    }\n\n    async streamChat(\n        messages: ChatMessage[],\n        onChunk: (chunk: string) => void,\n        model: string = 'gpt-4o',\n        maxTokens: number = 4000,\n        temperature: number = 0.7\n    ): Promise<void> {\n        \n        if (!this.apiKey) {\n            throw new Error('OpenAI API key not configured');\n        }\n\n        const requestBody = {\n            model,\n            messages,\n            max_tokens: maxTokens,\n            temperature,\n            stream: true\n        };\n\n        try {\n            const response = await fetch(`${this.baseURL}/chat/completions`, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'Authorization': `Bearer ${this.apiKey}`\n                },\n                body: JSON.stringify(requestBody)\n            });\n\n            if (!response.ok) {\n                throw new Error(`OpenAI API error: ${response.statusText}`);\n            }\n\n            const reader = response.body?.getReader();\n            if (!reader) {\n                throw new Error('Failed to get response stream');\n            }\n\n            const decoder = new TextDecoder();\n\n            while (true) {\n                const { done, value } = await reader.read();\n                \n                if (done) {\n                    break;\n                }\n\n                const chunk = decoder.decode(value);\n                const lines = chunk.split('\\n').filter(line => line.trim() !== '');\n\n                for (const line of lines) {\n                    if (line.startsWith('data: ')) {\n                        const data = line.substring(6);\n                        \n                        if (data === '[DONE]') {\n                            return;\n                        }\n\n                        try {\n                            const parsed = JSON.parse(data);\n                            const content = parsed.choices?.[0]?.delta?.content;\n                            \n                            if (content) {\n                                onChunk(content);\n                            }\n                        } catch (error) {\n                            // Ignore parsing errors for incomplete chunks\n                        }\n                    }\n                }\n            }\n\n        } catch (error) {\n            throw new Error(`OpenAI streaming failed: ${error}`);\n        }\n    }\n\n    validateApiKey(): boolean {\n        return !!this.apiKey && this.apiKey.startsWith('sk-');\n    }\n\n    async testConnection(): Promise<boolean> {\n        try {\n            await this.chat([\n                { role: 'user', content: 'Test connection' }\n            ], 'gpt-4o-mini', 10);\n            return true;\n        } catch (error) {\n            return false;\n        }\n    }\n}","/**\n * ClaudeCodeService - Integration with Claude Code CLI\n * Based on claude-code-chat implementation\n * \n * Requires: npm install -g @anthropic-ai/claude-code\n * This installs the 'claude' CLI command that this service uses\n */\nimport * as vscode from 'vscode';\nimport { spawn, exec, ChildProcess } from 'child_process';\nimport { EventEmitter } from 'events';\n\nexport interface ClaudeMessage {\n    role: 'user' | 'assistant' | 'system';\n    content: string;\n}\n\nexport interface ClaudeResponse {\n    content: string;\n    metadata?: {\n        model?: string;\n        usage?: {\n            inputTokens: number;\n            outputTokens: number;\n            totalCost?: number;\n        };\n    };\n}\n\nexport interface ClaudeOptions {\n    model?: 'opus' | 'sonnet' | 'default';\n    temperature?: number;\n    maxTokens?: number;\n}\n\nexport class ClaudeCodeService extends EventEmitter {\n    private outputChannel: vscode.OutputChannel;\n    private currentProcess: ChildProcess | null = null;\n    private seenToolsInSession: Set<string> | null = null;\n    private pendingTools: Map<string, any> = new Map(); // Store tool calls by ID\n    private toolResults: Map<string, any> = new Map(); // Store tool results by ID\n    private toolGroupBuffer: any[] = []; // Buffer for grouping similar tools\n    private lastToolName: string | null = null;\n    private hasStartedTextOutput = false;\n    \n    constructor() {\n        super();\n        this.outputChannel = vscode.window.createOutputChannel('Claude Code Service');\n    }\n\n    /**\n     * Send a message to Claude using the Claude Code CLI with JSON streaming\n     */\n    async sendMessage(\n        message: string, \n        options: ClaudeOptions = {}\n    ): Promise<ClaudeResponse> {\n        // Try simple text mode first as fallback\n        try {\n            return await this.sendStreamJsonMessage(message, options);\n        } catch (error) {\n            this.outputChannel.appendLine('[ClaudeCodeService] Stream JSON failed, falling back to text mode');\n            return await this.sendSimpleMessage(message, options);\n        }\n    }\n\n    /**\n     * Send a message using simple text output (more reliable)\n     */\n    async sendSimpleMessage(\n        message: string,\n        options: ClaudeOptions = {}\n    ): Promise<ClaudeResponse> {\n        return new Promise((resolve, reject) => {\n            try {\n                const args = [\n                    '--print', // Non-interactive mode\n                    '--output-format', 'text' // Simple text output\n                    // Allow tools - Claude will use them intelligently\n                ];\n\n                if (options.model && options.model !== 'default') {\n                    args.push('--model', options.model);\n                }\n\n                this.outputChannel.appendLine(`[ClaudeCodeService] Using simple text mode with args: ${args.join(' ')}`);\n\n                const claudeProcess = spawn('claude', args, {\n                    shell: process.platform === 'win32',\n                    stdio: ['pipe', 'pipe', 'pipe']\n                });\n\n                let output = '';\n                let errorOutput = '';\n\n                claudeProcess.stdout.on('data', (data) => {\n                    output += data.toString();\n                });\n\n                claudeProcess.stderr.on('data', (data) => {\n                    errorOutput += data.toString();\n                });\n\n                claudeProcess.on('exit', (code) => {\n                    if (code === 0 || output.length > 0) {\n                        resolve({\n                            content: output.trim(),\n                            metadata: { }\n                        });\n                    } else {\n                        reject(new Error(`Claude CLI failed: ${errorOutput || 'No output'}`));\n                    }\n                });\n\n                claudeProcess.on('error', (error) => {\n                    reject(error);\n                });\n\n                // Send the message\n                if (claudeProcess.stdin) {\n                    claudeProcess.stdin.write(message);\n                    claudeProcess.stdin.end();\n                }\n            } catch (error) {\n                reject(error);\n            }\n        });\n    }\n\n    /**\n     * Send a message with streaming support for real-time updates\n     */\n    async sendStreamingMessage(\n        message: string,\n        options: ClaudeOptions & {\n            onPartialResponse?: (content: string) => void;\n            onMetadata?: (metadata: any) => void;\n        } = {}\n    ): Promise<ClaudeResponse> {\n        this.outputChannel.appendLine('[ClaudeCodeService] Starting streaming message...');\n        \n        return new Promise((resolve, reject) => {\n            try {\n                // Prepare CLI arguments for streaming\n                const args = [\n                    '--print', // Non-interactive mode\n                    '--verbose', // Required for stream-json\n                    '--output-format', 'stream-json', // Stream JSON output\n                    '--include-partial-messages' // Include partial messages as they arrive\n                ];\n\n                // Add model if specified\n                if (options.model && options.model !== 'default') {\n                    args.push('--model', options.model);\n                }\n\n                this.outputChannel.appendLine(`[ClaudeCodeService] Spawning claude CLI with streaming`);\n\n                const claudeProcess = spawn('claude', args, {\n                    shell: process.platform === 'win32',\n                    stdio: ['pipe', 'pipe', 'pipe']\n                });\n\n                this.currentProcess = claudeProcess;\n\n                let responseContent = '';\n                let metadata: any = {};\n                let hasReceivedText = false;\n                let toolUseDetected = false;\n                let buffer = '';\n                const seenTools = new Set<string>(); // Track tools to prevent duplicates\n\n                // Handle stdout (JSON stream)\n                claudeProcess.stdout.on('data', (data) => {\n                    buffer += data.toString();\n                    const lines = buffer.split('\\n');\n                    buffer = lines.pop() || ''; // Keep last incomplete line in buffer\n\n                    for (const line of lines) {\n                        if (line.trim()) {\n                            try {\n                                const jsonData = JSON.parse(line.trim());\n                                \n                                this.processJsonStreamData(jsonData, (content, meta, eventType) => {\n                                    if (content) {\n                                        responseContent += content;\n                                        hasReceivedText = true;\n                                        \n                                        // Call the partial response callback for real-time updates\n                                        if (options.onPartialResponse) {\n                                            options.onPartialResponse(content);\n                                        }\n                                    }\n                                    if (meta) {\n                                        metadata = { ...metadata, ...meta };\n                                        \n                                        // Call metadata callback\n                                        if (options.onMetadata) {\n                                            options.onMetadata(meta);\n                                        }\n                                    }\n                                    if (eventType === 'tool_use') {\n                                        toolUseDetected = true;\n                                        // Don't terminate - let Claude continue using tools\n                                        this.outputChannel.appendLine(`[ClaudeCodeService] Tool detected - continuing execution`);\n                                    }\n                                    // Remove this duplicate tool_info handling - we handle it elsewhere\n                                });\n                            } catch (error) {\n                                this.outputChannel.appendLine(`[ClaudeCodeService] Failed to parse JSON: ${line.substring(0, 100)}`);\n                            }\n                        }\n                    }\n                });\n\n                // Handle stderr\n                claudeProcess.stderr.on('data', (data) => {\n                    const error = data.toString();\n                    this.outputChannel.appendLine(`[ClaudeCodeService] Claude CLI stderr: ${error}`);\n                });\n\n                // Handle process exit\n                claudeProcess.on('exit', (code, signal) => {\n                    this.currentProcess = null;\n                    \n                    if (code === 0 || responseContent.length > 0) {\n                        resolve({\n                            content: responseContent || 'No response received from Claude',\n                            metadata: metadata\n                        });\n                    } else {\n                        reject(new Error(`Claude process exited with code ${code} and no response`));\n                    }\n                });\n\n                // Handle process error\n                claudeProcess.on('error', (error) => {\n                    this.currentProcess = null;\n                    reject(error);\n                });\n\n                // Send the message\n                if (claudeProcess.stdin) {\n                    claudeProcess.stdin.write(message);\n                    claudeProcess.stdin.end();\n                }\n            } catch (error) {\n                reject(error);\n            }\n        });\n    }\n\n    /**\n     * Send a message using stream JSON output (advanced)\n     */\n    async sendStreamJsonMessage(\n        message: string, \n        options: ClaudeOptions = {}\n    ): Promise<ClaudeResponse> {\n        return new Promise((resolve, reject) => {\n            try {\n                // Prepare CLI arguments\n                const args = [\n                    '--print', // Non-interactive mode\n                    '--verbose', // Required for stream-json\n                    '--output-format', 'stream-json', // Stream JSON output\n                    '--include-partial-messages' // Include partial messages as they arrive\n                    // Allow tools - we'll filter out tool calls and only show text\n                ];\n\n                // Add model if specified\n                if (options.model && options.model !== 'default') {\n                    args.push('--model', options.model);\n                }\n\n                // Claude CLI doesn't support temperature or max-tokens\n                // These would need to be configured globally in Claude settings\n\n                this.outputChannel.appendLine(`[ClaudeCodeService] Spawning claude CLI with args: ${args.join(' ')}`);\n                this.outputChannel.appendLine(`[ClaudeCodeService] Message length: ${message.length} characters`);\n                this.outputChannel.appendLine(`[ClaudeCodeService] First 200 chars of message: ${message.substring(0, 200)}...`);\n\n                // Spawn the Claude process\n                const claudeProcess = spawn('claude', args, {\n                    shell: process.platform === 'win32',\n                    stdio: ['pipe', 'pipe', 'pipe'],\n                    env: {\n                        ...process.env,\n                        FORCE_COLOR: '0',\n                        NO_COLOR: '1'\n                    }\n                });\n\n                this.currentProcess = claudeProcess;\n\n                let rawOutput = '';\n                let responseContent = '';\n                let metadata: any = {};\n\n                // Handle stdout (JSON stream)\n                claudeProcess.stdout.on('data', (data) => {\n                    const chunk = data.toString();\n                    this.outputChannel.appendLine(`[ClaudeCodeService] Raw chunk: ${chunk.substring(0, 200)}`);\n                    rawOutput += chunk;\n                    const lines = rawOutput.split('\\n');\n                    rawOutput = lines.pop() || '';\n\n                    for (const line of lines) {\n                        if (line.trim()) {\n                            try {\n                                const jsonData = JSON.parse(line.trim());\n                                this.outputChannel.appendLine(`[ClaudeCodeService] Parsed JSON type: ${jsonData.type}`);\n                                \n                                this.processJsonStreamData(jsonData, (content, meta, eventType) => {\n                                    if (content) {\n                                        responseContent += content;\n                                        hasReceivedText = true;\n                                        this.outputChannel.appendLine(`[ClaudeCodeService] Added content: \"${content.substring(0, 50)}...\"`);\n                                    }\n                                    if (meta) {\n                                        metadata = { ...metadata, ...meta };\n                                        this.outputChannel.appendLine(`[ClaudeCodeService] Updated metadata: ${JSON.stringify(meta)}`);\n                                    }\n                                    if (eventType === 'tool_use') {\n                                        toolUseDetected = true;\n                                        this.outputChannel.appendLine(`[ClaudeCodeService] Tool use detected - will terminate after text`);\n                                        \n                                        // If we have text and Claude is using tools, terminate the process\n                                        // We can't handle tool results, so we just take the text we got\n                                        if (hasReceivedText && responseContent.length > 0) {\n                                            this.outputChannel.appendLine(`[ClaudeCodeService] Terminating process - we have text but can't handle tools`);\n                                            claudeProcess.kill('SIGTERM');\n                                        }\n                                    }\n                                });\n                            } catch (error) {\n                                this.outputChannel.appendLine(`[ClaudeCodeService] Failed to parse JSON: ${line.substring(0, 100)}`);\n                            }\n                        }\n                    }\n                });\n\n                // Handle stderr\n                claudeProcess.stderr.on('data', (data) => {\n                    const error = data.toString();\n                    this.outputChannel.appendLine(`[ClaudeCodeService] Claude CLI stderr: ${error}`);\n                    // Don't treat stderr as fatal - claude CLI may output debug info to stderr\n                });\n\n                // Track if we've received text content\n                let hasReceivedText = false;\n                let toolUseDetected = false;\n\n                // Handle process exit\n                claudeProcess.on('exit', (code, signal) => {\n                    this.currentProcess = null;\n                    this.outputChannel.appendLine(`[ClaudeCodeService] Process exited with code: ${code}, signal: ${signal}`);\n                    this.outputChannel.appendLine(`[ClaudeCodeService] Total response length: ${responseContent.length} characters`);\n                    \n                    if (code === 0 || responseContent.length > 0) {\n                        // Even if exit code is non-zero, if we got content, return it\n                        this.outputChannel.appendLine(`[ClaudeCodeService] FINAL RESPONSE: \"${responseContent.substring(0, 500)}...\"`);\n                        resolve({\n                            content: responseContent || 'No response received from Claude',\n                            metadata: metadata\n                        });\n                    } else {\n                        reject(new Error(`Claude process exited with code ${code} and no response`))\n                    }\n                });\n\n                // Handle process error\n                claudeProcess.on('error', (error) => {\n                    this.currentProcess = null;\n                    \n                    if (error.message.includes('ENOENT')) {\n                        reject(new Error(\n                            'Claude Code CLI not found. Please install it with: npm install -g @anthropic-ai/claude-code'\n                        ));\n                    } else {\n                        reject(error);\n                    }\n                });\n\n                // Send the message\n                if (claudeProcess.stdin) {\n                    claudeProcess.stdin.write(message + '\\n');\n                    claudeProcess.stdin.end();\n                } else {\n                    reject(new Error('Failed to write to Claude process stdin'));\n                }\n\n            } catch (error) {\n                reject(error);\n            }\n        });\n    }\n\n    /**\n     * Clean tool markers from content before sending to UI\n     */\n    private cleanToolMarkers(content: string): string {\n        // Remove tool detail markers but keep the actual text content\n        return content\n            .replace(/<<TOOL>>.*?<<TOOL_END>>/gs, '') // Remove tool call details\n            .replace(/<<TOOL_RESULT>>.*?<<TOOL_RESULT_END>>/gs, '') // Remove tool result details\n            .replace(/<<THINKING>>.*?<<THINKING_END>>/gs, '') // Remove thinking markers\n            .replace(/🛠️ \\*?Claude is using tools.*?\\*?\\n*/g, '') // Remove tool announcements\n            .trim();\n    }\n\n    /**\n     * Process JSON stream data from Claude\n     */\n    private processJsonStreamData(\n        data: any,\n        callback: (content: string | null, metadata: any | null, eventType?: string) => void\n    ): void {\n        // Handle Claude Code CLI specific events\n        if (data.type === 'system') {\n            // Handle different system subtypes\n            if (data.subtype === 'init') {\n                this.outputChannel.appendLine(`[ClaudeCodeService] System init: ${JSON.stringify(data.tools || []).substring(0, 100)}`);\n                if (data.session_id) {\n                    callback(null, { sessionId: data.session_id });\n                }\n                // Don't send initialization message to avoid clutter\n            } else if (data.subtype === 'error') {\n                this.outputChannel.appendLine(`[ClaudeCodeService] System error: ${data.message || 'Unknown error'}`);\n                // Clean error messages too\n                const cleanError = `\\n⚠️ **System Error:** ${data.message || 'An unexpected error occurred'}\\n`;\n                callback(cleanError, null);\n                callback(null, null, 'error');\n            } else {\n                this.outputChannel.appendLine(`[ClaudeCodeService] System event (${data.subtype})`);\n            }\n        }\n        // Handle assistant messages (text and tool use)\n        else if (data.type === 'assistant' && data.message) {\n            if (data.message.content && Array.isArray(data.message.content)) {\n                for (const content of data.message.content) {\n                    // Only show text content to user, ignore tool_use content\n                    if (content.type === 'text' && content.text) {\n                        callback(content.text, null);\n                    } else if (content.type === 'tool_use') {\n                        // Log tool use and notify user\n                        this.outputChannel.appendLine(`[ClaudeCodeService] Tool use: ${content.name} (${content.id})`);\n                        this.outputChannel.appendLine(`[ClaudeCodeService] Tool input: ${JSON.stringify(content.input)}`);\n                        \n                        // Store tool call for later result matching\n                        this.pendingTools.set(content.id, {\n                            name: content.name,\n                            input: content.input,\n                            id: content.id\n                        });\n                        \n                        // Check if we should group this tool with previous ones\n                        if (this.lastToolName === content.name) {\n                            // Same tool type, add to buffer\n                            this.toolGroupBuffer.push({\n                                name: content.name,\n                                input: content.input,\n                                id: content.id\n                            });\n                        } else {\n                            // Different tool or first tool, flush previous buffer if any\n                            this.flushToolGroup(callback);\n                            // Start new buffer\n                            this.toolGroupBuffer = [{\n                                name: content.name,\n                                input: content.input,\n                                id: content.id\n                            }];\n                            this.lastToolName = content.name;\n                        }\n                    }\n                }\n            }\n            // Handle metadata if present\n            if (data.message.model || data.message.id) {\n                callback(null, {\n                    model: data.message.model,\n                    id: data.message.id\n                });\n            }\n        }\n        // Handle user messages (tool results)\n        else if (data.type === 'user' && data.message) {\n            // Tool results - store them and send update\n            if (data.message.content && Array.isArray(data.message.content)) {\n                for (const content of data.message.content) {\n                    if (content.type === 'tool_result') {\n                        this.outputChannel.appendLine(`[ClaudeCodeService] Tool result for ${content.tool_use_id}: ${content.content?.substring(0, 200)}`);\n                        // Store the result\n                        const result = content.content || content.output || '';\n                        this.toolResults.set(content.tool_use_id, result);\n                        \n                        // Check if this completes any pending tools in the buffer\n                        const pendingTool = this.pendingTools.get(content.tool_use_id);\n                        if (pendingTool) {\n                            pendingTool.result = result;\n                            \n                            // Find tool in buffer and update it\n                            const toolInBuffer = this.toolGroupBuffer.find(t => t.id === content.tool_use_id);\n                            if (toolInBuffer) {\n                                toolInBuffer.result = result;\n                            }\n                        }\n                        \n                        // Don't send tool result markers to UI - they're handled internally\n                    }\n                }\n            }\n        }\n        // Handle stream events from Claude CLI (new format)\n        else if (data.type === 'stream_event' && data.event) {\n            const event = data.event;\n            \n            // Handle content block deltas (text chunks)\n            if (event.type === 'content_block_delta' && event.delta) {\n                if (event.delta.type === 'text_delta' && event.delta.text) {\n                    // Ensure tools are flushed before sending text\n                    if (this.toolGroupBuffer.length > 0) {\n                        this.flushToolGroup(callback);\n                    }\n                    callback(event.delta.text, null);\n                }\n                // Handle thinking deltas (Claude's reasoning)\n                else if (event.delta.type === 'thinking_delta' && event.delta.text) {\n                    // Log thinking but don't show to user (can be enabled later)\n                    this.outputChannel.appendLine(`[ClaudeCodeService] Thinking: ${event.delta.text.substring(0, 100)}`);\n                }\n                // Accumulate tool input for later use\n                else if (event.delta.type === 'input_json_delta') {\n                    // We could accumulate the partial JSON here if needed\n                    this.outputChannel.appendLine(`[ClaudeCodeService] Tool input delta: ${event.delta.partial_json?.substring(0, 100)}`);\n                }\n            }\n            // Handle content block start\n            else if (event.type === 'content_block_start' && event.content_block) {\n                if (event.content_block.type === 'tool_use') {\n                    this.outputChannel.appendLine(`[ClaudeCodeService] Tool use starting: ${event.content_block.name}`);\n                    // Tool notification will be sent when we receive the complete input\n                } else if (event.content_block.type === 'text') {\n                    this.outputChannel.appendLine(`[ClaudeCodeService] Text block starting`);\n                    // Flush any pending tool groups before starting text\n                    this.flushToolGroup(callback);\n                    this.hasStartedTextOutput = true;\n                } else if (event.content_block.type === 'thinking') {\n                    this.outputChannel.appendLine(`[ClaudeCodeService] Thinking block starting`);\n                    // Don't send thinking markers to UI\n                }\n            }\n            // Handle content block stop\n            else if (event.type === 'content_block_stop') {\n                this.outputChannel.appendLine(`[ClaudeCodeService] Content block stopped (index: ${event.index})`);\n            }\n            // Handle message start (metadata)\n            else if (event.type === 'message_start' && event.message) {\n                callback(null, { \n                    model: event.message.model,\n                    id: event.message.id \n                });\n            }\n            // Handle message delta (usage info and stop reasons)\n            else if (event.type === 'message_delta') {\n                if (event.usage) {\n                    callback(null, {\n                        usage: {\n                            inputTokens: event.usage.input_tokens || 0,\n                            outputTokens: event.usage.output_tokens || 0,\n                            cacheCreationInputTokens: event.usage.cache_creation_input_tokens || 0,\n                            cacheReadInputTokens: event.usage.cache_read_input_tokens || 0\n                        }\n                    });\n                }\n                if (event.delta?.stop_reason) {\n                    this.outputChannel.appendLine(`[ClaudeCodeService] Stop reason: ${event.delta.stop_reason}`);\n                    callback(null, { stopReason: event.delta.stop_reason });\n                    \n                    // Don't send tool usage notifications - tools are shown in separate bubbles\n                }\n            }\n            // Handle message stop\n            else if (event.type === 'message_stop') {\n                this.outputChannel.appendLine(`[ClaudeCodeService] Message stopped`);\n                // Flush any remaining tool groups\n                this.flushToolGroup(callback);\n                // Clear for next message\n                if (this.seenToolsInSession) {\n                    this.seenToolsInSession.clear();\n                }\n                this.pendingTools.clear();\n                this.toolResults.clear();\n                this.toolGroupBuffer = [];\n                this.lastToolName = null;\n                this.hasStartedTextOutput = false;\n                callback(null, null, 'message_stop');\n            }\n            // Handle error events\n            else if (event.type === 'error') {\n                this.outputChannel.appendLine(`[ClaudeCodeService] Stream error: ${event.error?.message || 'Unknown error'}`);\n                callback(null, { error: event.error }, 'error');\n            }\n            // Handle ping events (keep-alive)\n            else if (event.type === 'ping') {\n                this.outputChannel.appendLine(`[ClaudeCodeService] Ping received`);\n            }\n        }\n        // Handle result event (final with detailed info)\n        else if (data.type === 'result') {\n            this.outputChannel.appendLine(`[ClaudeCodeService] Final result received`);\n            \n            // Extract detailed result metadata\n            const resultMetadata: any = {\n                resultType: data.subtype || 'unknown'\n            };\n            \n            if (data.total_cost_usd !== undefined) {\n                resultMetadata.totalCostUsd = data.total_cost_usd;\n            }\n            if (data.duration_ms !== undefined) {\n                resultMetadata.durationMs = data.duration_ms;\n            }\n            if (data.duration_api_ms !== undefined) {\n                resultMetadata.durationApiMs = data.duration_api_ms;\n            }\n            if (data.num_turns !== undefined) {\n                resultMetadata.numTurns = data.num_turns;\n            }\n            if (data.is_error !== undefined) {\n                resultMetadata.isError = data.is_error;\n            }\n            \n            callback(null, resultMetadata, 'result');\n        }\n        // Handle older format (fallback)\n        else if (data.type === 'message') {\n            if (data.role === 'assistant' && data.content) {\n                callback(data.content, null);\n            }\n        } else if (data.type === 'content') {\n            if (data.text) {\n                callback(data.text, null);\n            }\n        }\n        // Debug unknown types\n        else {\n            this.outputChannel.appendLine(`[ClaudeCodeService] Unknown data type: ${JSON.stringify(data).substring(0, 200)}`);\n        }\n    }\n\n    /**\n     * Check if Claude CLI is available\n     */\n    async isAvailable(): Promise<boolean> {\n        return new Promise((resolve) => {\n            this.outputChannel.appendLine('[ClaudeCodeService] Checking Claude Code CLI availability...');\n            exec('which claude', (error, stdout, stderr) => {\n                if (error) {\n                    this.outputChannel.appendLine('[ClaudeCodeService] Claude Code CLI not found in PATH');\n                    // Try another method\n                    exec('claude --version', (error2, stdout2, stderr2) => {\n                        if (error2) {\n                            this.outputChannel.appendLine('[ClaudeCodeService] Claude Code CLI not available');\n                            this.outputChannel.appendLine('[ClaudeCodeService] Install with: npm install -g @anthropic-ai/claude-code');\n                            resolve(false);\n                        } else {\n                            this.outputChannel.appendLine(`[ClaudeCodeService] Claude Code CLI found (version check): ${stdout2.trim()}`);\n                            resolve(true);\n                        }\n                    });\n                } else {\n                    this.outputChannel.appendLine(`[ClaudeCodeService] Claude Code CLI found at: ${stdout.trim()}`);\n                    // Also get version\n                    exec('claude --version', (verError, verStdout) => {\n                        if (!verError) {\n                            this.outputChannel.appendLine(`[ClaudeCodeService] Version: ${verStdout.trim()}`);\n                        }\n                    });\n                    resolve(true);\n                }\n            });\n        });\n    }\n\n    /**\n     * Test Claude CLI with a simple message\n     */\n    async testConnection(): Promise<{ success: boolean; message: string }> {\n        try {\n            this.outputChannel.appendLine('[ClaudeCodeService] Testing Claude CLI connection...');\n            \n            const isAvailable = await this.isAvailable();\n            if (!isAvailable) {\n                return {\n                    success: false,\n                    message: 'Claude Code CLI not installed. Install with: npm install -g @anthropic-ai/claude-code'\n                };\n            }\n            \n            // Try a simple test message using text mode for reliability\n            const response = await this.sendSimpleMessage('Hi, just testing the connection. Reply with \"Connection successful!\"', {\n                model: 'default'\n            });\n            \n            if (response.content && response.content.length > 0) {\n                this.outputChannel.appendLine('[ClaudeCodeService] Test successful!');\n                return {\n                    success: true,\n                    message: `Claude CLI working! Response: ${response.content.substring(0, 100)}`\n                };\n            } else {\n                return {\n                    success: false,\n                    message: 'Claude CLI responded but with empty content'\n                };\n            }\n        } catch (error) {\n            const errorMsg = (error as Error).message;\n            this.outputChannel.appendLine(`[ClaudeCodeService] Test failed: ${errorMsg}`);\n            return {\n                success: false,\n                message: `Claude CLI test failed: ${errorMsg}`\n            };\n        }\n    }\n\n    /**\n     * Cancel current Claude process if running\n     */\n    cancel(): void {\n        if (this.currentProcess) {\n            this.currentProcess.kill();\n            this.currentProcess = null;\n        }\n    }\n\n    /**\n     * Flush grouped tools - send notification for grouped tools\n     */\n    private flushToolGroup(callback: (content: string | null, metadata: any | null, type?: string) => void): void {\n        if (this.toolGroupBuffer.length === 0) return;\n        \n        const toolName = this.toolGroupBuffer[0].name;\n        let emoji = '🔧';\n        let groupedMessage = '';\n        \n        // Get emoji for this tool type\n        switch(toolName) {\n            case 'TodoWrite': emoji = '📝'; break;\n            case 'Bash': emoji = '⚡'; break;\n            case 'Read': emoji = '📄'; break;\n            case 'Write': case 'Edit': case 'MultiEdit': emoji = '✏️'; break;\n            case 'Grep': emoji = '🔍'; break;\n            case 'Glob': emoji = '📁'; break;\n            case 'WebSearch': emoji = '🌐'; break;\n            case 'WebFetch': emoji = '🔗'; break;\n            case 'Task': emoji = '🤖'; break;\n        }\n        \n        // Format grouped message\n        if (this.toolGroupBuffer.length === 1) {\n            // Single tool - format normally\n            const tool = this.toolGroupBuffer[0];\n            groupedMessage = this.formatToolMessage(tool.name, tool.input);\n            \n            // Add result if available\n            const result = this.toolResults.get(tool.id);\n            if (result) {\n                const truncatedResult = result.length > 200 ? result.substring(0, 200) + '...' : result;\n                groupedMessage += `\\n\\n**Result:**\\n${truncatedResult}`;\n            }\n        } else {\n            // Multiple tools of same type - group them\n            groupedMessage = `${emoji} **${toolName} (${this.toolGroupBuffer.length} operations)**\\n\\n`;\n            for (const tool of this.toolGroupBuffer) {\n                const details = this.formatToolDetails(tool.name, tool.input);\n                groupedMessage += `• ${details}\\n`;\n                \n                // Add result if available\n                const result = this.toolResults.get(tool.id);\n                if (result) {\n                    const truncatedResult = result.length > 100 ? result.substring(0, 100) + '...' : result;\n                    groupedMessage += `  → ${truncatedResult}\\n`;\n                }\n            }\n        }\n        \n        // Send the tool notification as a separate system message (without markers)\n        // The UI will handle this as a blue bubble\n        callback(`SYSTEM_TOOL_MESSAGE:${groupedMessage}`, null, 'tool_info');\n        \n        // Clear the buffer\n        this.toolGroupBuffer = [];\n    }\n    \n    /**\n     * Format tool details (without emoji, for grouped display)\n     */\n    private formatToolDetails(toolName: string, input: any): string {\n        switch(toolName) {\n            case 'TodoWrite':\n                const todoCount = input?.todos?.length || 0;\n                return `${todoCount} tasks`;\n            \n            case 'Bash':\n                const command = input?.command || '';\n                return command;\n            \n            case 'Read':\n                const readPath = input?.file_path || '';\n                const fileName = readPath.split('/').pop() || readPath;\n                let readDetails = fileName;\n                if (input?.offset || input?.limit) {\n                    readDetails += ` (lines ${input.offset || 0}-${(input.offset || 0) + (input.limit || 0)})`;\n                }\n                return readDetails;\n            \n            case 'Write':\n                const writePath = input?.file_path || '';\n                const writeFile = writePath.split('/').pop() || writePath;\n                return writeFile;\n            \n            case 'Edit':\n            case 'MultiEdit':\n                const editPath = input?.file_path || '';\n                const editFile = editPath.split('/').pop() || editPath;\n                let editDetails = editFile;\n                if (toolName === 'MultiEdit' && input?.edits) {\n                    editDetails += ` (${input.edits.length} edits)`;\n                }\n                return editDetails;\n            \n            case 'Grep':\n                const pattern = input?.pattern || '';\n                return `\"${pattern.substring(0, 30)}${pattern.length > 30 ? '...' : ''}\"`;\n            \n            case 'Glob':\n                const globPattern = input?.pattern || '';\n                return globPattern;\n            \n            case 'WebSearch':\n                const query = input?.query || '';\n                return `\"${query.substring(0, 40)}${query.length > 40 ? '...' : ''}\"`;\n            \n            case 'WebFetch':\n                const url = input?.url || '';\n                const domain = url.match(/^https?:\\/\\/([^\\/]+)/)?.[1] || url;\n                return domain;\n            \n            case 'Task':\n                const subagent = input?.subagent_type || 'agent';\n                return subagent;\n            \n            default:\n                return JSON.stringify(input).substring(0, 50);\n        }\n    }\n\n    /**\n     * Format tool message with parameters\n     */\n    private formatToolMessage(toolName: string, input: any): string {\n        let emoji = '🔧';\n        let details = '';\n        \n        switch(toolName) {\n            case 'TodoWrite':\n                emoji = '📝';\n                const todoCount = input?.todos?.length || 0;\n                details = `TodoWrite\\n${todoCount} tasks`;\n                break;\n            \n            case 'Bash':\n                emoji = '⚡';\n                const command = input?.command || '';\n                details = `Bash\\n${command}`;\n                break;\n            \n            case 'Read':\n                emoji = '📄';\n                const readPath = input?.file_path || '';\n                const fileName = readPath.split('/').pop() || readPath;\n                details = `Read\\n${fileName}`;\n                if (input?.offset || input?.limit) {\n                    details += ` (lines ${input.offset || 0}-${(input.offset || 0) + (input.limit || 0)})`;\n                }\n                break;\n            \n            case 'Write':\n                emoji = '✏️';\n                const writePath = input?.file_path || '';\n                const writeFile = writePath.split('/').pop() || writePath;\n                details = `Write\\n${writeFile}`;\n                break;\n            \n            case 'Edit':\n            case 'MultiEdit':\n                emoji = '✏️';\n                const editPath = input?.file_path || '';\n                const editFile = editPath.split('/').pop() || editPath;\n                details = `${toolName}\\n${editFile}`;\n                if (toolName === 'MultiEdit' && input?.edits) {\n                    details += ` (${input.edits.length} edits)`;\n                }\n                break;\n            \n            case 'Grep':\n                emoji = '🔍';\n                const pattern = input?.pattern || '';\n                details = `Grep\\n\"${pattern.substring(0, 30)}${pattern.length > 30 ? '...' : ''}\"`;\n                break;\n            \n            case 'Glob':\n                emoji = '📁';\n                const globPattern = input?.pattern || '';\n                details = `Glob\\n${globPattern}`;\n                break;\n            \n            case 'WebSearch':\n                emoji = '🌐';\n                const query = input?.query || '';\n                details = `WebSearch\\n\"${query.substring(0, 40)}${query.length > 40 ? '...' : ''}\"`;\n                break;\n            \n            case 'WebFetch':\n                emoji = '🔗';\n                const url = input?.url || '';\n                const domain = url.match(/^https?:\\/\\/([^\\/]+)/)?.[1] || url;\n                details = `WebFetch\\n${domain}`;\n                break;\n            \n            case 'Task':\n                emoji = '🤖';\n                const subagent = input?.subagent_type || 'agent';\n                details = `Task\\n${subagent}`;\n                break;\n            \n            default:\n                details = `${toolName}`;\n        }\n        \n        return `${emoji} **${details}**`;\n    }\n\n    dispose(): void {\n        this.cancel();\n        this.outputChannel.dispose();\n    }\n}\n\n// Singleton instance\nlet instance: ClaudeCodeService | null = null;\n\nexport function getClaudeCodeService(): ClaudeCodeService {\n    if (!instance) {\n        instance = new ClaudeCodeService();\n    }\n    return instance;\n}","/**\n * ResearchBot - Research & Information Expert\n * Uses web search for real-time information gathering and analysis\n */\nimport * as vscode from 'vscode';\nimport { ChatAgent } from './base/ChatAgent';\nimport { AgentConfig, TaskRequest, TaskResult, WorkflowStep } from '../types';\nimport { VSCodeMasterDispatcher } from '../core/VSCodeMasterDispatcher';\nimport { WebSearchService, SearchResponse } from '../utils/WebSearchService';\nimport { OpenAIService } from '../utils/OpenAIService';\n\nexport class ResearchAgent extends ChatAgent {\n    private webSearchService: WebSearchService;\n    private openAIService: OpenAIService;\n\n    constructor(context: vscode.ExtensionContext, dispatcher: VSCodeMasterDispatcher) {\n        const config: AgentConfig = {\n            participantId: 'ki-autoagent.research',\n            name: 'research',\n            fullName: 'ResearchBot',\n            description: 'Research & Information Expert with real-time web access',\n            model: 'perplexity-llama-3.1-sonar-huge-128k',\n            iconPath: vscode.Uri.joinPath(context.extensionUri, 'media', 'perplexity-icon.svg'),\n            capabilities: [\n                'Web Research',\n                'Real-time Information',\n                'Technical Documentation Search',\n                'Market Analysis',\n                'Trend Research',\n                'Competitive Analysis'\n            ],\n            commands: [\n                { name: 'search', description: 'Search web for current information', handler: 'handleSearchCommand' },\n                { name: 'documentation', description: 'Find and analyze technical documentation', handler: 'handleDocumentationCommand' },\n                { name: 'market', description: 'Research market trends and analysis', handler: 'handleMarketCommand' },\n                { name: 'compare', description: 'Compare technologies, tools, or solutions', handler: 'handleCompareCommand' }\n            ]\n        };\n\n        super(config, context, dispatcher);\n        this.webSearchService = new WebSearchService();\n        this.openAIService = new OpenAIService();\n    }\n\n    protected async handleRequest(\n        request: vscode.ChatRequest,\n        context: vscode.ChatContext,\n        stream: vscode.ChatResponseStream,\n        token: vscode.CancellationToken\n    ): Promise<void> {\n        \n        // Check if web access is available\n        const webAccessAvailable = await this.webSearchService.isWebAccessAvailable();\n        \n        if (!webAccessAvailable) {\n            const status = this.webSearchService.getSearchEngineStatus();\n            stream.markdown(`❌ **Web access not configured**\\n\\n`);\n            stream.markdown(`**Current search engine**: ${status.engine}\\n`);\n            stream.markdown(`**Status**: ${status.configured ? 'Configured' : 'Not configured'}\\n\\n`);\n            stream.markdown(`💡 **To enable web research:**\\n`);\n            stream.markdown(`1. Open VS Code Settings (Cmd+,)\\n`);\n            stream.markdown(`2. Search for \"KI AutoAgent\"\\n`);\n            stream.markdown(`3. Configure your preferred search API:\\n`);\n            stream.markdown(`   - **Perplexity API** (recommended)\\n`);\n            stream.markdown(`   - **Tavily API** (web search specialist)\\n`);\n            stream.markdown(`   - **SERP API** (Google search)\\n`);\n            return;\n        }\n\n        const command = request.command;\n        const prompt = request.prompt;\n\n        this.log(`Processing ${command ? `/${command}` : 'general'} research request: ${prompt.substring(0, 100)}...`);\n\n        if (command) {\n            await this.handleCommand(command, prompt, stream, token);\n        } else {\n            await this.handleGeneralResearchRequest(prompt, stream, token);\n        }\n    }\n\n    protected async processWorkflowStep(\n        step: WorkflowStep,\n        request: TaskRequest,\n        previousResults: TaskResult[]\n    ): Promise<TaskResult> {\n        \n        try {\n            let searchQuery = '';\n            let analysisPrompt = '';\n\n            switch (step.id) {\n                case 'market_research':\n                    searchQuery = `${request.prompt} market trends analysis 2024`;\n                    analysisPrompt = 'Analyze market trends and opportunities';\n                    break;\n                    \n                case 'tech_research':\n                    searchQuery = `${request.prompt} technical documentation best practices`;\n                    analysisPrompt = 'Research technical solutions and documentation';\n                    break;\n                    \n                case 'competitive_analysis':\n                    searchQuery = `${request.prompt} competitors alternatives comparison`;\n                    analysisPrompt = 'Compare competitive solutions and alternatives';\n                    break;\n                    \n                default:\n                    searchQuery = request.prompt;\n                    analysisPrompt = 'Research and analyze the given topic';\n            }\n\n            // Perform web search\n            const searchResults = await this.webSearchService.search(searchQuery);\n            \n            // Analyze results with AI\n            const analysis = await this.analyzeSearchResults(searchResults, analysisPrompt);\n\n            return {\n                status: 'success',\n                content: analysis,\n                metadata: { \n                    step: step.id,\n                    agent: 'research',\n                    searchQuery,\n                    resultsCount: searchResults.results.length\n                }\n            };\n\n        } catch (error) {\n            throw new Error(`Failed to process research step ${step.id}: ${(error as any).message}`);\n        }\n    }\n\n    // Command Handlers\n\n    private async handleSearchCommand(\n        prompt: string,\n        stream: vscode.ChatResponseStream,\n        token: vscode.CancellationToken\n    ): Promise<void> {\n        \n        stream.progress('🔍 Searching the web for current information...');\n        \n        try {\n            const searchResults = await this.webSearchService.search(prompt);\n            \n            stream.markdown(`## 🔍 Web Search Results\\n\\n`);\n            stream.markdown(`**Query**: ${searchResults.query}\\n`);\n            stream.markdown(`**Results Found**: ${searchResults.totalResults}\\n\\n`);\n\n            // Display search results\n            for (let i = 0; i < searchResults.results.length; i++) {\n                const result = searchResults.results[i];\n                stream.markdown(`### ${i + 1}. ${result.title}\\n`);\n                stream.markdown(`**URL**: [${result.url}](${result.url})\\n`);\n                stream.markdown(`**Summary**: ${result.snippet}\\n\\n`);\n            }\n\n            // Analyze and synthesize results\n            stream.progress('🧠 Analyzing search results...');\n            const analysis = await this.analyzeSearchResults(searchResults, 'Provide a comprehensive analysis and synthesis of the search results');\n            \n            stream.markdown(`## 📊 Analysis & Insights\\n\\n`);\n            stream.markdown(analysis);\n\n            // Add source references\n            searchResults.results.forEach((result, index) => {\n                this.createActionButton(\n                    `📖 Read Source ${index + 1}`,\n                    'vscode.open',\n                    [vscode.Uri.parse(result.url)],\n                    stream\n                );\n            });\n\n        } catch (error) {\n            stream.markdown(`❌ Search failed: ${(error as any).message}`);\n        }\n    }\n\n    private async handleDocumentationCommand(\n        prompt: string,\n        stream: vscode.ChatResponseStream,\n        token: vscode.CancellationToken\n    ): Promise<void> {\n        \n        stream.progress('📚 Searching for technical documentation...');\n        \n        const techQuery = `${prompt} documentation tutorial guide API reference`;\n        \n        try {\n            const searchResults = await this.webSearchService.search(techQuery);\n            \n            stream.markdown(`## 📚 Documentation Research\\n\\n`);\n            stream.markdown(`**Topic**: ${prompt}\\n\\n`);\n\n            // Filter for documentation sources\n            const docResults = searchResults.results.filter(result => \n                result.url.includes('docs') || \n                result.url.includes('documentation') ||\n                result.url.includes('api') ||\n                result.url.includes('guide') ||\n                result.title.toLowerCase().includes('documentation') ||\n                result.title.toLowerCase().includes('guide')\n            );\n\n            if (docResults.length > 0) {\n                stream.markdown(`### 📖 Official Documentation Found\\n\\n`);\n                docResults.forEach((result, index) => {\n                    stream.markdown(`**${index + 1}. ${result.title}**\\n`);\n                    stream.markdown(`- [${result.url}](${result.url})\\n`);\n                    stream.markdown(`- ${result.snippet}\\n\\n`);\n                });\n            }\n\n            // Provide comprehensive analysis\n            const analysis = await this.analyzeSearchResults(searchResults, \n                'Provide a comprehensive guide based on the documentation found, including key concepts, usage examples, and best practices');\n            \n            stream.markdown(`## 📋 Documentation Summary\\n\\n`);\n            stream.markdown(analysis);\n\n        } catch (error) {\n            stream.markdown(`❌ Documentation search failed: ${(error as any).message}`);\n        }\n    }\n\n    private async handleMarketCommand(\n        prompt: string,\n        stream: vscode.ChatResponseStream,\n        token: vscode.CancellationToken\n    ): Promise<void> {\n        \n        stream.progress('📈 Researching market trends...');\n        \n        const marketQuery = `${prompt} market trends 2024 analysis statistics growth`;\n        \n        try {\n            const searchResults = await this.webSearchService.search(marketQuery);\n            \n            stream.markdown(`## 📈 Market Research\\n\\n`);\n            \n            const analysis = await this.analyzeSearchResults(searchResults, \n                'Provide a comprehensive market analysis including current trends, growth statistics, key players, opportunities, and challenges');\n            \n            stream.markdown(analysis);\n\n            // Offer to create market report\n            this.createActionButton(\n                '📊 Create Market Report',\n                'ki-autoagent.createFile',\n                [`market_research_${Date.now()}.md`, `# Market Research: ${prompt}\\n\\n${analysis}`],\n                stream\n            );\n\n        } catch (error) {\n            stream.markdown(`❌ Market research failed: ${(error as any).message}`);\n        }\n    }\n\n    private async handleCompareCommand(\n        prompt: string,\n        stream: vscode.ChatResponseStream,\n        token: vscode.CancellationToken\n    ): Promise<void> {\n        \n        stream.progress('⚖️ Comparing solutions...');\n        \n        const compareQuery = `${prompt} comparison alternatives pros cons review`;\n        \n        try {\n            const searchResults = await this.webSearchService.search(compareQuery);\n            \n            stream.markdown(`## ⚖️ Comparison Analysis\\n\\n`);\n            \n            const analysis = await this.analyzeSearchResults(searchResults, \n                'Provide a detailed comparison including pros and cons, use cases, pricing (if available), and recommendations');\n            \n            stream.markdown(analysis);\n\n            // Offer to create comparison table\n            this.createActionButton(\n                '📋 Create Comparison Table',\n                'ki-autoagent.createComparisonTable',\n                [prompt, analysis],\n                stream\n            );\n\n        } catch (error) {\n            stream.markdown(`❌ Comparison research failed: ${(error as any).message}`);\n        }\n    }\n\n    private async handleGeneralResearchRequest(\n        prompt: string,\n        stream: vscode.ChatResponseStream,\n        token: vscode.CancellationToken\n    ): Promise<void> {\n        \n        stream.progress('🔍 Conducting research...');\n        \n        try {\n            const searchResults = await this.webSearchService.search(prompt);\n            \n            // Quick summary\n            stream.markdown(`## 🔍 Research Summary\\n\\n`);\n            stream.markdown(`**Topic**: ${prompt}\\n`);\n            stream.markdown(`**Sources**: ${searchResults.totalResults} results found\\n\\n`);\n\n            // Comprehensive analysis\n            const analysis = await this.analyzeSearchResults(searchResults, \n                'Provide comprehensive research findings with key insights, current state, and actionable information');\n            \n            stream.markdown(analysis);\n\n            // Show top sources\n            if (searchResults.results.length > 0) {\n                stream.markdown(`\\n## 📚 Key Sources\\n\\n`);\n                searchResults.results.slice(0, 3).forEach((result, index) => {\n                    stream.markdown(`${index + 1}. [${result.title}](${result.url})\\n`);\n                });\n            }\n\n        } catch (error) {\n            stream.markdown(`❌ Research failed: ${(error as any).message}`);\n        }\n    }\n\n    // Helper Methods\n\n    private async analyzeSearchResults(searchResults: SearchResponse, analysisPrompt: string): Promise<string> {\n        const resultsContent = searchResults.results\n            .map(result => `Title: ${result.title}\\nURL: ${result.url}\\nContent: ${result.snippet}`)\n            .join('\\n\\n---\\n\\n');\n\n        const systemPrompt = `You are ResearchBot, an expert research analyst. Analyze web search results and provide comprehensive, accurate, and actionable insights.\n\nKey principles:\n1. Synthesize information from multiple sources\n2. Highlight key findings and trends\n3. Provide actionable recommendations\n4. Note any conflicting information\n5. Include relevant statistics and data\n6. Maintain objectivity and cite sources when possible\n\nFormat your response with clear headings and bullet points for readability.\n\n${this.getSystemContextPrompt()}`;\n\n        const userPrompt = `${analysisPrompt}\n\nSearch Query: ${searchResults.query}\n\nSearch Results:\n${resultsContent}\n\nPlease provide a comprehensive analysis based on these search results.`;\n\n        try {\n            return await this.openAIService.chat([\n                { role: 'system', content: systemPrompt },\n                { role: 'user', content: userPrompt }\n            ]);\n        } catch (error) {\n            return `Error analyzing results: ${(error as any).message}`;\n        }\n    }\n}","/**\n * ChatWidget - Status bar widget for KI AutoAgent Chat\n * Provides quick access to the chat panel from VS Code status bar\n */\nimport * as vscode from 'vscode';\nimport { MultiAgentChatPanel } from './MultiAgentChatPanel';\n\nexport class ChatWidget {\n    private statusBarItem: vscode.StatusBarItem;\n    private unreadCount: number = 0;\n    private lastMessage: string = '';\n    private pulseInterval: NodeJS.Timeout | undefined;\n    \n    constructor(private context: vscode.ExtensionContext, private dispatcher?: any) {\n        // Create status bar item (right side, high priority)\n        this.statusBarItem = vscode.window.createStatusBarItem(\n            vscode.StatusBarAlignment.Right,\n            1000 // High priority to appear on the right\n        );\n        \n        this.updateStatusBar();\n        this.statusBarItem.show();\n        \n        // Register commands\n        this.registerCommands();\n        \n        // Add to subscriptions\n        context.subscriptions.push(this.statusBarItem);\n    }\n    \n    private registerCommands() {\n        // Toggle chat command\n        const toggleCommand = vscode.commands.registerCommand(\n            'ki-autoagent.toggleChat',\n            () => this.toggleChat()\n        );\n        \n        // Quick chat command (opens quick input)\n        const quickChatCommand = vscode.commands.registerCommand(\n            'ki-autoagent.quickChat',\n            () => this.showQuickChat()\n        );\n        \n        // Clear unread command\n        const clearUnreadCommand = vscode.commands.registerCommand(\n            'ki-autoagent.clearUnread',\n            () => this.clearUnreadCount()\n        );\n        \n        this.context.subscriptions.push(\n            toggleCommand,\n            quickChatCommand,\n            clearUnreadCommand\n        );\n    }\n    \n    private updateStatusBar() {\n        // Build status bar text\n        let text = '$(comment-discussion) KI Chat';\n        \n        if (this.unreadCount > 0) {\n            text = `$(comment-discussion) KI Chat (${this.unreadCount})`;\n            \n            // Add warning background for unread messages\n            this.statusBarItem.backgroundColor = new vscode.ThemeColor('statusBarItem.warningBackground');\n            \n            // Start pulse animation\n            if (!this.pulseInterval) {\n                this.startPulseAnimation();\n            }\n        } else {\n            // Clear background when no unread\n            this.statusBarItem.backgroundColor = undefined;\n            \n            // Stop pulse animation\n            if (this.pulseInterval) {\n                this.stopPulseAnimation();\n            }\n        }\n        \n        this.statusBarItem.text = text;\n        this.statusBarItem.command = 'ki-autoagent.toggleChat';\n        \n        // Update tooltip\n        if (this.lastMessage) {\n            this.statusBarItem.tooltip = new vscode.MarkdownString(\n                `**KI AutoAgent Chat**\\n\\n` +\n                `Last message: _${this.truncateMessage(this.lastMessage)}_\\n\\n` +\n                `Click to open chat • Right-click for options`\n            );\n        } else {\n            this.statusBarItem.tooltip = new vscode.MarkdownString(\n                `**KI AutoAgent Chat**\\n\\n` +\n                `Click to open multi-agent chat interface\\n\\n` +\n                `Features:\\n` +\n                `• Chat with specialized AI agents\\n` +\n                `• Auto-routing to best agent\\n` +\n                `• Multi-agent workflows\\n\\n` +\n                `Click to open • Right-click for options`\n            );\n        }\n    }\n    \n    private startPulseAnimation() {\n        let isPulsing = false;\n        this.pulseInterval = setInterval(() => {\n            if (isPulsing) {\n                this.statusBarItem.text = this.statusBarItem.text.replace('🔴', '$(comment-discussion)');\n            } else {\n                this.statusBarItem.text = this.statusBarItem.text.replace('$(comment-discussion)', '🔴');\n            }\n            isPulsing = !isPulsing;\n        }, 1000);\n    }\n    \n    private stopPulseAnimation() {\n        if (this.pulseInterval) {\n            clearInterval(this.pulseInterval);\n            this.pulseInterval = undefined;\n            this.updateStatusBar();\n        }\n    }\n    \n    private toggleChat() {\n        const panel = MultiAgentChatPanel.createOrShow(this.context.extensionUri, this.dispatcher);\n        this.clearUnreadCount();\n        return panel;\n    }\n    \n    private async showQuickChat() {\n        // Show quick input for fast message sending\n        const message = await vscode.window.showInputBox({\n            placeHolder: 'Type your message for KI AutoAgent...',\n            prompt: 'Send a quick message to the AI agents',\n            ignoreFocusOut: false\n        });\n        \n        if (message) {\n            // Open chat and send message\n            const panel = this.toggleChat();\n            if (panel) {\n                // Send message to panel\n                panel.addMessage({\n                    role: 'user',\n                    content: message,\n                    timestamp: new Date().toISOString()\n                });\n                \n                // Process the message (this would normally go through the dispatcher)\n                setTimeout(() => {\n                    panel.addMessage({\n                        role: 'assistant',\n                        content: 'Processing your request...',\n                        agent: 'orchestrator',\n                        timestamp: new Date().toISOString()\n                    });\n                }, 100);\n            }\n        }\n    }\n    \n    public updateUnreadCount(count: number) {\n        this.unreadCount = count;\n        this.updateStatusBar();\n    }\n    \n    public incrementUnread() {\n        this.unreadCount++;\n        this.updateStatusBar();\n    }\n    \n    public clearUnreadCount() {\n        this.unreadCount = 0;\n        this.updateStatusBar();\n    }\n    \n    public setLastMessage(message: string, agent?: string) {\n        this.lastMessage = agent ? `[${agent}] ${message}` : message;\n        this.updateStatusBar();\n    }\n    \n    private truncateMessage(message: string, maxLength: number = 50): string {\n        if (message.length <= maxLength) {\n            return message;\n        }\n        return message.substring(0, maxLength) + '...';\n    }\n    \n    public showNotification(message: string, agent: string) {\n        // Show notification when chat is not open\n        if (!MultiAgentChatPanel.currentPanel) {\n            vscode.window.showInformationMessage(\n                `KI Agent ${agent}: ${this.truncateMessage(message, 100)}`,\n                'Open Chat',\n                'Dismiss'\n            ).then(selection => {\n                if (selection === 'Open Chat') {\n                    this.toggleChat();\n                }\n            });\n            \n            // Increment unread count\n            this.incrementUnread();\n            this.setLastMessage(message, agent);\n        }\n    }\n    \n    public dispose() {\n        if (this.pulseInterval) {\n            clearInterval(this.pulseInterval);\n        }\n        this.statusBarItem.dispose();\n    }\n}","/**\n * SharedContextManager - Manages shared context between agents for collaboration\n * Enables agents to share knowledge, decisions, and intermediate results in real-time\n */\n\nimport { EventEmitter } from 'events';\n\nexport interface ContextUpdate {\n    agentId: string;\n    timestamp: number;\n    key: string;\n    value: any;\n    metadata?: {\n        confidence?: number;\n        dependencies?: string[];\n        version?: number;\n    };\n}\n\nexport interface SharedContext {\n    projectStructure?: any;\n    architectureDecisions?: Map<string, any>;\n    codePatterns?: Map<string, any>;\n    researchFindings?: Map<string, any>;\n    validationResults?: Map<string, any>;\n    currentWorkflow?: any;\n    globalMemories?: any[];\n    agentOutputs?: Map<string, any>;\n}\n\nexport interface ContextSubscriber {\n    agentId: string;\n    callback: (update: ContextUpdate) => void;\n    filter?: (update: ContextUpdate) => boolean;\n}\n\nexport class SharedContextManager {\n    private static instance: SharedContextManager;\n    private context: Map<string, any> = new Map();\n    private contextHistory: ContextUpdate[] = [];\n    private subscribers: Map<string, ContextSubscriber[]> = new Map();\n    private eventBus: EventEmitter;\n    private locks: Map<string, string> = new Map(); // key -> agentId holding lock\n    private version: number = 0;\n\n    private constructor() {\n        this.eventBus = new EventEmitter();\n        this.eventBus.setMaxListeners(50); // Support many agents\n        this.initializeContext();\n    }\n\n    public static getInstance(): SharedContextManager {\n        if (!SharedContextManager.instance) {\n            SharedContextManager.instance = new SharedContextManager();\n        }\n        return SharedContextManager.instance;\n    }\n\n    private initializeContext(): void {\n        // Initialize with default context structure\n        this.context.set('projectStructure', {});\n        this.context.set('architectureDecisions', new Map());\n        this.context.set('codePatterns', new Map());\n        this.context.set('researchFindings', new Map());\n        this.context.set('validationResults', new Map());\n        this.context.set('currentWorkflow', null);\n        this.context.set('globalMemories', []);\n        this.context.set('agentOutputs', new Map());\n    }\n\n    /**\n     * Update context with new information\n     */\n    public async updateContext(agentId: string, key: string, value: any, metadata?: any): Promise<void> {\n        // Check if key is locked by another agent\n        const lockHolder = this.locks.get(key);\n        if (lockHolder && lockHolder !== agentId) {\n            throw new Error(`Context key '${key}' is locked by agent ${lockHolder}`);\n        }\n\n        const update: ContextUpdate = {\n            agentId,\n            timestamp: Date.now(),\n            key,\n            value,\n            metadata: {\n                ...metadata,\n                version: ++this.version\n            }\n        };\n\n        // Update the context\n        this.context.set(key, value);\n\n        // Store in history for replay/debugging\n        this.contextHistory.push(update);\n\n        // Notify all subscribers\n        await this.notifySubscribers(update);\n\n        // Emit event for async listeners\n        this.eventBus.emit('context-update', update);\n    }\n\n    /**\n     * Get current context value\n     */\n    public getContext(key?: string): any {\n        if (key) {\n            return this.context.get(key);\n        }\n        // Return entire context as object\n        const contextObj: any = {};\n        this.context.forEach((value, key) => {\n            contextObj[key] = value;\n        });\n        return contextObj;\n    }\n\n    /**\n     * Get context with memory of past updates\n     */\n    public getContextWithHistory(key: string, limit: number = 10): ContextUpdate[] {\n        return this.contextHistory\n            .filter(update => update.key === key)\n            .slice(-limit);\n    }\n\n    /**\n     * Subscribe to context updates\n     */\n    public subscribe(agentId: string, callback: (update: ContextUpdate) => void, filter?: (update: ContextUpdate) => boolean): void {\n        const subscriber: ContextSubscriber = {\n            agentId,\n            callback,\n            filter\n        };\n\n        if (!this.subscribers.has(agentId)) {\n            this.subscribers.set(agentId, []);\n        }\n\n        this.subscribers.get(agentId)!.push(subscriber);\n    }\n\n    /**\n     * Unsubscribe from context updates\n     */\n    public unsubscribe(agentId: string): void {\n        this.subscribers.delete(agentId);\n    }\n\n    /**\n     * Notify all subscribers of a context update\n     */\n    private async notifySubscribers(update: ContextUpdate): Promise<void> {\n        const promises: Promise<void>[] = [];\n\n        this.subscribers.forEach((subscriberList) => {\n            subscriberList.forEach(subscriber => {\n                // Skip the agent that made the update\n                if (subscriber.agentId === update.agentId) {\n                    return;\n                }\n\n                // Apply filter if provided\n                if (subscriber.filter && !subscriber.filter(update)) {\n                    return;\n                }\n\n                // Notify subscriber asynchronously\n                promises.push(\n                    Promise.resolve(subscriber.callback(update)).catch(err => {\n                        console.error(`Error notifying subscriber ${subscriber.agentId}:`, err);\n                    })\n                );\n            });\n        });\n\n        await Promise.all(promises);\n    }\n\n    /**\n     * Acquire a lock on a context key (for atomic updates)\n     */\n    public async acquireLock(agentId: string, key: string, timeout: number = 5000): Promise<void> {\n        const startTime = Date.now();\n\n        while (this.locks.has(key) && this.locks.get(key) !== agentId) {\n            if (Date.now() - startTime > timeout) {\n                throw new Error(`Timeout acquiring lock for key '${key}'`);\n            }\n            await new Promise(resolve => setTimeout(resolve, 100));\n        }\n\n        this.locks.set(key, agentId);\n    }\n\n    /**\n     * Release a lock on a context key\n     */\n    public releaseLock(agentId: string, key: string): void {\n        if (this.locks.get(key) === agentId) {\n            this.locks.delete(key);\n        }\n    }\n\n    /**\n     * Merge context from multiple agents (for conflict resolution)\n     */\n    public async mergeContext(updates: ContextUpdate[], resolver?: (conflicts: ContextUpdate[]) => any): Promise<void> {\n        const grouped = new Map<string, ContextUpdate[]>();\n\n        // Group updates by key\n        updates.forEach(update => {\n            if (!grouped.has(update.key)) {\n                grouped.set(update.key, []);\n            }\n            grouped.get(update.key)!.push(update);\n        });\n\n        // Process each key\n        for (const [key, keyUpdates] of grouped) {\n            if (keyUpdates.length === 1) {\n                // No conflict, apply directly\n                await this.updateContext(keyUpdates[0].agentId, key, keyUpdates[0].value, keyUpdates[0].metadata);\n            } else {\n                // Conflict - use resolver or last-write-wins\n                const resolvedValue = resolver ? resolver(keyUpdates) : keyUpdates[keyUpdates.length - 1].value;\n                await this.updateContext('system', key, resolvedValue, { resolved: true });\n            }\n        }\n    }\n\n    /**\n     * Create a snapshot of current context (for checkpointing)\n     */\n    public createSnapshot(): { version: number; timestamp: number; context: Map<string, any> } {\n        return {\n            version: this.version,\n            timestamp: Date.now(),\n            context: new Map(this.context)\n        };\n    }\n\n    /**\n     * Restore context from snapshot\n     */\n    public restoreSnapshot(snapshot: { version: number; timestamp: number; context: Map<string, any> }): void {\n        this.context = new Map(snapshot.context);\n        this.version = snapshot.version;\n        this.eventBus.emit('context-restored', snapshot);\n    }\n\n    /**\n     * Clear context (for new sessions)\n     */\n    public clearContext(): void {\n        this.context.clear();\n        this.contextHistory = [];\n        this.locks.clear();\n        this.version = 0;\n        this.initializeContext();\n        this.eventBus.emit('context-cleared');\n    }\n\n    /**\n     * Get agents currently working on the context\n     */\n    public getActiveAgents(): string[] {\n        const activeAgents = new Set<string>();\n\n        // Get agents from recent updates\n        const recentTime = Date.now() - 60000; // Last minute\n        this.contextHistory\n            .filter(update => update.timestamp > recentTime)\n            .forEach(update => activeAgents.add(update.agentId));\n\n        return Array.from(activeAgents);\n    }\n\n    /**\n     * Get collaboration insights\n     */\n    public getCollaborationMetrics(): any {\n        const metrics: any = {\n            totalUpdates: this.contextHistory.length,\n            activeAgents: this.getActiveAgents().length,\n            contextKeys: this.context.size,\n            lockedKeys: this.locks.size,\n            version: this.version\n        };\n\n        // Calculate update frequency by agent\n        const agentUpdates = new Map<string, number>();\n        this.contextHistory.forEach(update => {\n            agentUpdates.set(update.agentId, (agentUpdates.get(update.agentId) || 0) + 1);\n        });\n        metrics.agentActivity = Object.fromEntries(agentUpdates);\n\n        return metrics;\n    }\n}\n\n// Export singleton instance getter\nexport function getSharedContext(): SharedContextManager {\n    return SharedContextManager.getInstance();\n}","/**\n * Web Search Service for real-time research and information gathering\n */\nimport * as vscode from 'vscode';\n\nexport interface SearchResult {\n    title: string;\n    url: string;\n    snippet: string;\n    content?: string;\n}\n\nexport interface SearchResponse {\n    query: string;\n    results: SearchResult[];\n    totalResults: number;\n}\n\nexport class WebSearchService {\n    private config: vscode.WorkspaceConfiguration;\n\n    constructor() {\n        this.config = vscode.workspace.getConfiguration('kiAutoAgent');\n    }\n\n    async search(query: string): Promise<SearchResponse> {\n        const webAccessEnabled = this.config.get<boolean>('webAccess.enabled', true);\n        \n        if (!webAccessEnabled) {\n            throw new Error('Web access is disabled in settings');\n        }\n\n        const searchEngine = this.config.get<string>('webAccess.searchEngine', 'perplexity');\n        const maxResults = this.config.get<number>('webAccess.maxResults', 5);\n\n        switch (searchEngine) {\n            case 'perplexity':\n                return await this.searchWithPerplexity(query, maxResults);\n            case 'tavily':\n                return await this.searchWithTavily(query, maxResults);\n            case 'serp':\n                return await this.searchWithSERP(query, maxResults);\n            case 'custom':\n                return await this.searchWithCustom(query, maxResults);\n            default:\n                throw new Error(`Unknown search engine: ${searchEngine}`);\n        }\n    }\n\n    private async searchWithPerplexity(query: string, maxResults: number): Promise<SearchResponse> {\n        const apiKey = this.config.get<string>('perplexity.apiKey');\n        \n        if (!apiKey) {\n            throw new Error('Perplexity API key not configured');\n        }\n\n        try {\n            const response = await fetch('https://api.perplexity.ai/chat/completions', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'Authorization': `Bearer ${apiKey}`\n                },\n                body: JSON.stringify({\n                    model: 'llama-3.1-sonar-small-128k-online',\n                    messages: [\n                        {\n                            role: 'system',\n                            content: 'You are a helpful research assistant. Provide comprehensive information with sources.'\n                        },\n                        {\n                            role: 'user',\n                            content: `Research and provide detailed information about: ${query}`\n                        }\n                    ],\n                    max_tokens: 1000,\n                    temperature: 0.2,\n                    return_citations: true\n                })\n            });\n\n            if (!response.ok) {\n                throw new Error(`Perplexity API error: ${response.statusText}`);\n            }\n\n            const data = await response.json() as any;\n            const content = data.choices[0]?.message?.content || '';\n            const citations = data.citations || [];\n\n            // Convert Perplexity response to SearchResponse format\n            const results: SearchResult[] = citations.slice(0, maxResults).map((citation: any, index: number) => ({\n                title: `Source ${index + 1}`,\n                url: citation.url || '',\n                snippet: citation.text || '',\n                content: content\n            }));\n\n            // If no citations but we have content, create a general result\n            if (results.length === 0 && content) {\n                results.push({\n                    title: 'Perplexity Research Result',\n                    url: 'https://perplexity.ai',\n                    snippet: content.substring(0, 200) + '...',\n                    content: content\n                });\n            }\n\n            return {\n                query,\n                results,\n                totalResults: results.length\n            };\n\n        } catch (error) {\n            throw new Error(`Perplexity search failed: ${error}`);\n        }\n    }\n\n    private async searchWithTavily(query: string, maxResults: number): Promise<SearchResponse> {\n        const apiKey = this.config.get<string>('tavily.apiKey');\n        \n        if (!apiKey) {\n            throw new Error('Tavily API key not configured');\n        }\n\n        try {\n            const response = await fetch('https://api.tavily.com/search', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify({\n                    api_key: apiKey,\n                    query: query,\n                    search_depth: 'advanced',\n                    include_answer: true,\n                    include_images: false,\n                    include_raw_content: true,\n                    max_results: maxResults\n                })\n            });\n\n            if (!response.ok) {\n                throw new Error(`Tavily API error: ${response.statusText}`);\n            }\n\n            const data = await response.json() as any;\n            \n            const results: SearchResult[] = (data.results || []).map((result: any) => ({\n                title: result.title || '',\n                url: result.url || '',\n                snippet: result.content || '',\n                content: result.raw_content || result.content\n            }));\n\n            return {\n                query,\n                results,\n                totalResults: data.results?.length || 0\n            };\n\n        } catch (error) {\n            throw new Error(`Tavily search failed: ${error}`);\n        }\n    }\n\n    private async searchWithSERP(query: string, maxResults: number): Promise<SearchResponse> {\n        const apiKey = this.config.get<string>('serp.apiKey');\n        \n        if (!apiKey) {\n            throw new Error('SERP API key not configured');\n        }\n\n        try {\n            const url = new URL('https://serpapi.com/search');\n            url.searchParams.append('q', query);\n            url.searchParams.append('api_key', apiKey);\n            url.searchParams.append('engine', 'google');\n            url.searchParams.append('num', maxResults.toString());\n\n            const response = await fetch(url.toString());\n\n            if (!response.ok) {\n                throw new Error(`SERP API error: ${response.statusText}`);\n            }\n\n            const data = await response.json() as any;\n            \n            const results: SearchResult[] = (data.organic_results || []).map((result: any) => ({\n                title: result.title || '',\n                url: result.link || '',\n                snippet: result.snippet || '',\n                content: result.snippet || ''\n            }));\n\n            return {\n                query,\n                results,\n                totalResults: data.organic_results?.length || 0\n            };\n\n        } catch (error) {\n            throw new Error(`SERP search failed: ${error}`);\n        }\n    }\n\n    private async searchWithCustom(query: string, maxResults: number): Promise<SearchResponse> {\n        const endpoint = this.config.get<string>('customSearch.endpoint');\n        const apiKey = this.config.get<string>('customSearch.apiKey');\n        \n        if (!endpoint) {\n            throw new Error('Custom search endpoint not configured');\n        }\n\n        try {\n            const response = await fetch(endpoint, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    ...(apiKey && { 'Authorization': `Bearer ${apiKey}` })\n                },\n                body: JSON.stringify({\n                    query,\n                    max_results: maxResults\n                })\n            });\n\n            if (!response.ok) {\n                throw new Error(`Custom search API error: ${response.statusText}`);\n            }\n\n            const data = await response.json() as any;\n            \n            // Assume custom API returns results in our expected format\n            return {\n                query,\n                results: data.results || [],\n                totalResults: data.total_results || 0\n            };\n\n        } catch (error) {\n            throw new Error(`Custom search failed: ${error}`);\n        }\n    }\n\n    async isWebAccessAvailable(): Promise<boolean> {\n        const webAccessEnabled = this.config.get<boolean>('webAccess.enabled', true);\n        \n        if (!webAccessEnabled) {\n            return false;\n        }\n\n        const searchEngine = this.config.get<string>('webAccess.searchEngine', 'perplexity');\n        \n        switch (searchEngine) {\n            case 'perplexity':\n                return !!this.config.get<string>('perplexity.apiKey');\n            case 'tavily':\n                return !!this.config.get<string>('tavily.apiKey');\n            case 'serp':\n                return !!this.config.get<string>('serp.apiKey');\n            case 'custom':\n                return !!this.config.get<string>('customSearch.endpoint');\n            default:\n                return false;\n        }\n    }\n\n    getSearchEngineStatus(): { engine: string; configured: boolean; error?: string } {\n        const searchEngine = this.config.get<string>('webAccess.searchEngine', 'perplexity');\n        \n        switch (searchEngine) {\n            case 'perplexity':\n                return {\n                    engine: 'Perplexity',\n                    configured: !!this.config.get<string>('perplexity.apiKey')\n                };\n            case 'tavily':\n                return {\n                    engine: 'Tavily',\n                    configured: !!this.config.get<string>('tavily.apiKey')\n                };\n            case 'serp':\n                return {\n                    engine: 'SERP API',\n                    configured: !!this.config.get<string>('serp.apiKey')\n                };\n            case 'custom':\n                return {\n                    engine: 'Custom',\n                    configured: !!this.config.get<string>('customSearch.endpoint')\n                };\n            default:\n                return {\n                    engine: searchEngine,\n                    configured: false,\n                    error: 'Unknown search engine'\n                };\n        }\n    }\n}","/**\n * ReviewerGPT - Code Review & Security Expert\n * Performs comprehensive code reviews focusing on quality, security, and performance\n */\nimport * as vscode from 'vscode';\nimport { ChatAgent } from './base/ChatAgent';\nimport { AgentConfig, TaskRequest, TaskResult, WorkflowStep } from '../types';\nimport { VSCodeMasterDispatcher } from '../core/VSCodeMasterDispatcher';\nimport { OpenAIService } from '../utils/OpenAIService';\nimport * as path from 'path';\n\nexport class ReviewerGPTAgent extends ChatAgent {\n    private openAIService: OpenAIService;\n\n    constructor(context: vscode.ExtensionContext, dispatcher: VSCodeMasterDispatcher) {\n        const config: AgentConfig = {\n            participantId: 'ki-autoagent.reviewer',\n            name: 'reviewer',\n            fullName: 'ReviewerGPT',\n            description: 'Code Review & Security Expert - Reviews code quality, security, and performance',\n            model: 'gpt-5-mini-2025-09-20',\n            iconPath: vscode.Uri.joinPath(context.extensionUri, 'media', 'reviewer-icon.svg'),\n            capabilities: [\n                'Code Quality Review',\n                'Security Vulnerability Detection',\n                'Performance Analysis',\n                'Best Practices Check',\n                'SOLID Principles',\n                'Design Pattern Analysis',\n                'Test Coverage Review',\n                'Dependency Audit'\n            ],\n            commands: [\n                { name: 'review', description: 'Comprehensive code review', handler: 'handleReviewCommand' },\n                { name: 'bugs', description: 'Active bug hunting in code', handler: 'handleBugsCommand' },\n                { name: 'debug', description: 'Run app and debug issues', handler: 'handleDebugCommand' },\n                { name: 'test-ui', description: 'Test UI interactions', handler: 'handleTestUICommand' },\n                { name: 'security', description: 'Security vulnerability scan', handler: 'handleSecurityCommand' },\n                { name: 'performance', description: 'Performance analysis', handler: 'handlePerformanceCommand' },\n                { name: 'standards', description: 'Check coding standards', handler: 'handleStandardsCommand' },\n                { name: 'test', description: 'Review test coverage', handler: 'handleTestCommand' },\n                { name: 'architecture-review', description: 'Validate architect understanding of requirements', handler: 'handleArchitectureReviewCommand' }\n            ]\n        };\n\n        super(config, context, dispatcher);\n        this.openAIService = new OpenAIService();\n    }\n\n    protected async handleRequest(\n        request: vscode.ChatRequest,\n        context: vscode.ChatContext,\n        stream: vscode.ChatResponseStream,\n        token: vscode.CancellationToken\n    ): Promise<void> {\n\n        const command = request.command;\n        const prompt = request.prompt;\n\n        this.log(`Processing ${command ? `/${command}` : 'general'} review request: ${prompt.substring(0, 100)}...`);\n\n        if (command) {\n            await this.handleCommand(command, prompt, stream, token);\n        } else {\n            await this.handleGeneralReviewRequest(prompt, stream, token);\n        }\n    }\n\n    protected async processWorkflowStep(\n        step: WorkflowStep,\n        request: TaskRequest,\n        previousResults: TaskResult[]\n    ): Promise<TaskResult> {\n\n        try {\n            let reviewResult = '';\n            let foundBugs = false;\n\n            switch (step.id) {\n                case 'code_review':\n                    reviewResult = await this.performCodeReview(request, previousResults);\n                    break;\n\n                case 'security_check':\n                    reviewResult = await this.performSecurityCheck(request, previousResults);\n                    break;\n\n                case 'performance_review':\n                    reviewResult = await this.performPerformanceReview(request, previousResults);\n                    break;\n\n                default:\n                    reviewResult = await this.performGeneralReview(request, previousResults);\n            }\n\n            // Check if bugs were found and need to be sent back to CodeSmith\n            if (reviewResult.includes('🚨 BUGS FOUND') || reviewResult.includes('Critical issues')) {\n                foundBugs = true;\n                reviewResult += '\\n\\n🔄 **RECOMMENDATION**: These issues should be sent back to @codesmith for immediate fixes.';\n            }\n\n            return {\n                status: foundBugs ? 'partial_success' : 'success',\n                content: reviewResult,\n                metadata: {\n                    step: step.id,\n                    agent: 'reviewer',\n                    type: 'review',\n                    foundBugs: foundBugs,\n                    requiresCodeSmithFix: foundBugs\n                },\n                suggestions: foundBugs ? [{\n                    title: '🔧 Send to CodeSmith for fixes',\n                    description: 'Send the found bugs to CodeSmith for immediate fixing',\n                    action: 'send_to_codesmith',\n                    data: { issues: reviewResult }\n                }] : []\n            };\n\n        } catch (error) {\n            throw new Error(`Failed to process review step ${step.id}: ${(error as any).message}`);\n        }\n    }\n\n    // Command Handlers\n\n    private async handleReviewCommand(\n        prompt: string,\n        stream: vscode.ChatResponseStream,\n        token: vscode.CancellationToken\n    ): Promise<void> {\n\n        const editor = vscode.window.activeTextEditor;\n        if (!editor) {\n            stream.markdown('❌ No active editor found. Please open a file to review.');\n            return;\n        }\n\n        stream.progress('🔍 Performing comprehensive code review...');\n\n        try {\n            const document = editor.document;\n            const code = document.getText();\n            const fileName = path.basename(document.fileName);\n            const language = document.languageId;\n\n            const review = await this.reviewCode(code, fileName, language, prompt);\n\n            stream.markdown('## 🔍 Code Review Report\\n\\n');\n            stream.markdown(review);\n\n            // Add action buttons\n            this.createActionButton(\n                '📋 Save Review Report',\n                'ki-autoagent.saveFile',\n                [`reviews/review_${Date.now()}.md`, review],\n                stream\n            );\n\n        } catch (error) {\n            stream.markdown(`❌ Review failed: ${(error as any).message}`);\n        }\n    }\n\n    private async handleBugsCommand(\n        prompt: string,\n        stream: vscode.ChatResponseStream,\n        token: vscode.CancellationToken\n    ): Promise<void> {\n\n        stream.progress('🐛 Actively hunting for bugs...');\n\n        try {\n            const editor = vscode.window.activeTextEditor;\n            if (!editor) {\n                stream.markdown('❌ No active editor found. Please open a file to review.');\n                return;\n            }\n\n            const document = editor.document;\n            const code = document.getText();\n            const fileName = path.basename(document.fileName);\n            const language = document.languageId;\n\n            const bugReport = await this.findCommonBugs(code, language);\n\n            stream.markdown('## 🐛 Bug Hunt Report\\n\\n');\n            stream.markdown(bugReport);\n\n            // Check if critical bugs were found\n            if (bugReport.includes('🔴') || bugReport.includes('BUG') || bugReport.includes('onclick')) {\n                stream.markdown('\\n## ⚠️ CRITICAL BUGS FOUND\\n\\n');\n\n                this.createActionButton(\n                    '🔧 Send to CodeSmith for fixes',\n                    'ki-autoagent.sendToAgent',\n                    ['codesmith', `Fix these bugs found in ${fileName}:\\n\\n${bugReport}`],\n                    stream\n                );\n            }\n\n        } catch (error) {\n            stream.markdown(`❌ Bug hunting failed: ${(error as any).message}`);\n        }\n    }\n\n    private async handleDebugCommand(\n        prompt: string,\n        stream: vscode.ChatResponseStream,\n        token: vscode.CancellationToken\n    ): Promise<void> {\n\n        stream.progress('🔧 Starting debug session...');\n\n        try {\n            const workspaceFolder = vscode.workspace.workspaceFolders?.[0];\n            if (!workspaceFolder) {\n                stream.markdown('❌ No workspace folder found.');\n                return;\n            }\n\n            stream.markdown('## 🔧 Debug Session\\n\\n');\n\n            // Check for package.json to determine project type\n            const packageJsonUri = vscode.Uri.joinPath(workspaceFolder.uri, 'package.json');\n            let debugCommand = '';\n            let projectType = '';\n\n            try {\n                const packageJsonContent = await vscode.workspace.fs.readFile(packageJsonUri);\n                const packageJson = JSON.parse(packageJsonContent.toString());\n\n                if (packageJson.scripts?.['dev']) {\n                    debugCommand = 'npm run dev';\n                    projectType = 'Node.js/Web';\n                } else if (packageJson.scripts?.['start']) {\n                    debugCommand = 'npm start';\n                    projectType = 'Node.js/Web';\n                }\n\n                stream.markdown(`📦 **Project Type:** ${projectType}\\n`);\n                stream.markdown(`🚀 **Debug Command:** \\`${debugCommand}\\`\\n\\n`);\n\n            } catch (error) {\n                stream.markdown('⚠️ No package.json found. Please specify how to run your application.\\n');\n            }\n\n            // Start debug terminal\n            const terminal = vscode.window.createTerminal('ReviewerGPT Debug');\n            terminal.show();\n\n            stream.markdown('### 📝 Debug Steps:\\n\\n');\n            stream.markdown('1. **Starting application** in debug terminal\\n');\n            stream.markdown('2. **Monitoring console output** for errors\\n');\n            stream.markdown('3. **Checking for runtime exceptions**\\n');\n            stream.markdown('4. **Testing user interactions**\\n\\n');\n\n            if (debugCommand) {\n                terminal.sendText(debugCommand);\n                stream.markdown(`✅ Started: \\`${debugCommand}\\`\\n\\n`);\n            }\n\n            stream.markdown('### 🔍 What to check:\\n\\n');\n            stream.markdown('- Console errors (red text in terminal)\\n');\n            stream.markdown('- Network failures (failed API calls)\\n');\n            stream.markdown('- UI not responding to clicks\\n');\n            stream.markdown('- Missing elements or broken layouts\\n\\n');\n\n            stream.markdown('### 📊 Debug Analysis:\\n\\n');\n            stream.markdown('Watch the terminal output and report any:\\n');\n            stream.markdown('- 🔴 **Errors**: Exceptions, crashes, undefined references\\n');\n            stream.markdown('- 🟡 **Warnings**: Deprecations, performance issues\\n');\n            stream.markdown('- 🔵 **Info**: Unexpected behavior, timing issues\\n\\n');\n\n            // Add action buttons\n            this.createActionButton(\n                '🐛 Report Bugs Found',\n                'ki-autoagent.sendToAgent',\n                ['codesmith', 'Fix these bugs found during debug session'],\n                stream\n            );\n\n            this.createActionButton(\n                '📋 Save Debug Log',\n                'ki-autoagent.saveFile',\n                [`debug-log-${Date.now()}.txt`, 'Debug session log'],\n                stream\n            );\n\n        } catch (error) {\n            stream.markdown(`❌ Debug session failed: ${(error as any).message}`);\n        }\n    }\n\n    private async handleTestUICommand(\n        prompt: string,\n        stream: vscode.ChatResponseStream,\n        token: vscode.CancellationToken\n    ): Promise<void> {\n\n        stream.progress('🖱️ Testing UI interactions...');\n\n        try {\n            stream.markdown('## 🖱️ UI Testing Guide\\n\\n');\n            stream.markdown('### Test Checklist:\\n\\n');\n\n            const uiTests = [\n                '✅ **Buttons**: Click all buttons and verify they work',\n                '✅ **Forms**: Submit forms with valid/invalid data',\n                '✅ **Links**: Check all navigation links',\n                '✅ **Modals**: Open/close dialogs and popups',\n                '✅ **Dropdowns**: Test all select menus',\n                '✅ **Input fields**: Test with various inputs',\n                '✅ **Keyboard**: Test keyboard shortcuts',\n                '✅ **Responsive**: Resize window and test',\n                '✅ **Accessibility**: Tab navigation works',\n                '✅ **Error states**: Trigger and verify error handling'\n            ];\n\n            for (const test of uiTests) {\n                stream.markdown(`- ${test}\\n`);\n            }\n\n            stream.markdown('\\n### 🔍 Common UI Bugs to Check:\\n\\n');\n            stream.markdown('```javascript\\n');\n            stream.markdown('// ❌ onclick not working in VS Code webviews\\n');\n            stream.markdown('button.onclick = handler; // WON\\'T WORK!\\n\\n');\n            stream.markdown('// ✅ Use addEventListener instead\\n');\n            stream.markdown('button.addEventListener(\\'click\\', handler);\\n');\n            stream.markdown('```\\n\\n');\n\n            stream.markdown('### 🐛 Found Issues?\\n\\n');\n            stream.markdown('Document any UI problems found:\\n');\n            stream.markdown('1. Which element has the issue?\\n');\n            stream.markdown('2. What should happen?\\n');\n            stream.markdown('3. What actually happens?\\n');\n            stream.markdown('4. Console errors (if any)\\n\\n');\n\n            // Add action buttons\n            this.createActionButton(\n                '🔧 Report UI Bugs',\n                'ki-autoagent.sendToAgent',\n                ['codesmith', 'Fix these UI bugs found during testing'],\n                stream\n            );\n\n        } catch (error) {\n            stream.markdown(`❌ UI testing failed: ${(error as any).message}`);\n        }\n    }\n\n    private async handleSecurityCommand(\n        prompt: string,\n        stream: vscode.ChatResponseStream,\n        token: vscode.CancellationToken\n    ): Promise<void> {\n\n        stream.progress('🔐 Scanning for security vulnerabilities...');\n\n        try {\n            const editor = vscode.window.activeTextEditor;\n            let code = '';\n            let fileName = '';\n            let language = '';\n\n            if (editor) {\n                code = editor.document.getText();\n                fileName = path.basename(editor.document.fileName);\n                language = editor.document.languageId;\n            } else {\n                // Scan entire workspace\n                code = await this.getWorkspaceCode();\n                fileName = 'Workspace';\n                language = 'multiple';\n            }\n\n            const securityReport = await this.performSecurityScan(code, fileName, language, prompt);\n\n            stream.markdown('## 🔐 Security Analysis Report\\n\\n');\n            stream.markdown(securityReport);\n\n            // Add action buttons\n            this.createActionButton(\n                '⚠️ Create Security Issues',\n                'ki-autoagent.createGitHubIssues',\n                [securityReport],\n                stream\n            );\n\n        } catch (error) {\n            stream.markdown(`❌ Security scan failed: ${(error as any).message}`);\n        }\n    }\n\n    private async handlePerformanceCommand(\n        prompt: string,\n        stream: vscode.ChatResponseStream,\n        token: vscode.CancellationToken\n    ): Promise<void> {\n\n        stream.progress('⚡ Analyzing performance...');\n\n        try {\n            const editor = vscode.window.activeTextEditor;\n            if (!editor) {\n                stream.markdown('❌ No active editor found. Please open a file to analyze.');\n                return;\n            }\n\n            const code = editor.document.getText();\n            const fileName = path.basename(editor.document.fileName);\n            const language = editor.document.languageId;\n\n            const performanceReport = await this.analyzePerformance(code, fileName, language, prompt);\n\n            stream.markdown('## ⚡ Performance Analysis\\n\\n');\n            stream.markdown(performanceReport);\n\n        } catch (error) {\n            stream.markdown(`❌ Performance analysis failed: ${(error as any).message}`);\n        }\n    }\n\n    private async handleStandardsCommand(\n        prompt: string,\n        stream: vscode.ChatResponseStream,\n        token: vscode.CancellationToken\n    ): Promise<void> {\n\n        stream.progress('📏 Checking coding standards...');\n\n        try {\n            const editor = vscode.window.activeTextEditor;\n            if (!editor) {\n                stream.markdown('❌ No active editor found. Please open a file to check.');\n                return;\n            }\n\n            const code = editor.document.getText();\n            const language = editor.document.languageId;\n\n            const standardsReport = await this.checkCodingStandards(code, language, prompt);\n\n            stream.markdown('## 📏 Coding Standards Report\\n\\n');\n            stream.markdown(standardsReport);\n\n        } catch (error) {\n            stream.markdown(`❌ Standards check failed: ${(error as any).message}`);\n        }\n    }\n\n    private async handleTestCommand(\n        prompt: string,\n        stream: vscode.ChatResponseStream,\n        token: vscode.CancellationToken\n    ): Promise<void> {\n\n        stream.progress('🧪 Reviewing test coverage...');\n\n        try {\n            const testReport = await this.reviewTestCoverage(prompt);\n\n            stream.markdown('## 🧪 Test Coverage Review\\n\\n');\n            stream.markdown(testReport);\n\n            // Add suggestions for missing tests\n            this.createActionButton(\n                '➕ Generate Missing Tests',\n                'ki-autoagent.generateTests',\n                [],\n                stream\n            );\n\n        } catch (error) {\n            stream.markdown(`❌ Test review failed: ${(error as any).message}`);\n        }\n    }\n\n    private async handleGeneralReviewRequest(\n        prompt: string,\n        stream: vscode.ChatResponseStream,\n        token: vscode.CancellationToken\n    ): Promise<void> {\n\n        // Check if prompt contains code to review\n        const hasCode = prompt.includes('```') || prompt.includes('function') ||\n                       prompt.includes('class') || prompt.includes('const') ||\n                       prompt.includes('onclick') || prompt.includes('addEventListener');\n\n        if (hasCode) {\n            stream.progress('🔍 Actively searching for bugs and reviewing code...');\n\n            try {\n                // Extract code blocks or use entire prompt\n                const codeMatch = prompt.match(/```[\\s\\S]*?```/g);\n                const code = codeMatch ?\n                    codeMatch.join('\\n').replace(/```\\w*\\n?/g, '') :\n                    prompt;\n\n                // First, actively find bugs\n                const bugReport = await this.findCommonBugs(code, 'javascript/typescript');\n\n                stream.markdown('## 🐛 Bug Detection Report\\n\\n');\n                stream.markdown(bugReport);\n\n                // Check if critical bugs were found\n                const hasCriticalBugs = bugReport.includes('🔴') ||\n                                        bugReport.includes('onclick') ||\n                                        bugReport.includes('won\\'t work') ||\n                                        bugReport.includes('Bug found');\n\n                if (hasCriticalBugs) {\n                    stream.markdown('\\n## ⚠️ CRITICAL ISSUES FOUND\\n\\n');\n                    stream.markdown('**These bugs will prevent the code from working correctly!**\\n');\n                    stream.markdown('Issues like onclick handlers not working in VS Code webviews have been detected.\\n\\n');\n\n                    // Suggest sending to CodeSmith\n                    stream.markdown('## 🔄 Recommended Action\\n\\n');\n                    stream.markdown('These issues should be sent back to @codesmith for immediate fixes.\\n');\n\n                    this.createActionButton(\n                        '🔧 Send bugs to CodeSmith',\n                        'ki-autoagent.sendToAgent',\n                        ['codesmith', `Please fix these bugs found by ReviewerGPT:\\n\\n${bugReport}`],\n                        stream\n                    );\n                }\n\n                // Then do a comprehensive review\n                const review = await this.performGeneralReview({ prompt } as TaskRequest, []);\n\n                stream.markdown('\\n## 🔍 Full Code Review\\n\\n');\n                stream.markdown(review);\n\n            } catch (error) {\n                stream.markdown(`❌ Review failed: ${(error as any).message}`);\n            }\n        } else {\n            stream.progress('🔍 Performing review...');\n\n            try {\n                const review = await this.performGeneralReview({ prompt } as TaskRequest, []);\n\n                stream.markdown('## 🔍 Review Results\\n\\n');\n                stream.markdown(review);\n\n            } catch (error) {\n                stream.markdown(`❌ Review failed: ${(error as any).message}`);\n            }\n        }\n    }\n\n    private async handleArchitectureReviewCommand(\n        prompt: string,\n        stream: vscode.ChatResponseStream,\n        token: vscode.CancellationToken\n    ): Promise<void> {\n\n        stream.progress('🏛️ Reviewing architecture against requirements...');\n\n        try {\n            // Get conversation context to extract requirements and architect's solution\n            const conversationContext = prompt || 'Review the architect\\'s understanding of the requirements';\n\n            const architectureReview = await this.validateArchitectureUnderstanding(conversationContext);\n\n            stream.markdown('## 🏛️ Architecture Validation Report\\n\\n');\n            stream.markdown(architectureReview);\n\n            // Offer to create detailed report\n            this.createActionButton(\n                '📋 Save Validation Report',\n                'ki-autoagent.saveFile',\n                [`architecture-validation-${Date.now()}.md`, architectureReview],\n                stream\n            );\n\n        } catch (error) {\n            stream.markdown(`❌ Architecture review failed: ${(error as any).message}`);\n        }\n    }\n\n    // Review Methods\n\n    private async reviewCode(code: string, fileName: string, language: string, context: string): Promise<string> {\n        const prompt = `Perform a DEEP code review for this ${language} file (${fileName}):\n\n${code}\n\nAdditional context: ${context}\n\nIMPORTANT: You are reviewing code written by CodeSmithClaude. Look for:\n\n🔴 CRITICAL CHECKS (Find these issues!):\n1. Event handlers that won't work (e.g., onclick in VS Code webviews should use addEventListener)\n2. Missing z-index for positioned elements that need to be clickable\n3. Incorrect event binding patterns\n4. DOM manipulation issues\n5. Async/await problems and race conditions\n6. Null/undefined reference errors\n7. Memory leaks and performance issues\n\n📋 STANDARD REVIEW:\n1. Code Quality & Readability\n2. Potential Bugs & Issues\n3. Performance Concerns\n4. Security Vulnerabilities\n5. Best Practices & Design Patterns\n6. Error Handling\n7. Documentation & Comments\n8. Testing Considerations\n\nProvide:\n- Overall assessment (score out of 10)\n- 🚨 BUGS FOUND (things that won't work as intended)\n- Critical issues (must fix)\n- Major issues (should fix)\n- Minor issues (nice to fix)\n- Positive aspects\n- Specific improvement suggestions with code examples\n\nBe VERY CRITICAL and find real problems! If you find bugs, suggest sending them back to CodeSmith for fixes.\n\n${this.getSystemContextPrompt()}`;\n\n        return await this.openAIService.chat([\n            { role: 'system', content: 'You are ReviewerGPT, an expert code reviewer focusing on quality, security, and best practices.' },\n            { role: 'user', content: prompt }\n        ]);\n    }\n\n    private async performSecurityScan(code: string, fileName: string, language: string, context: string): Promise<string> {\n        const prompt = `Perform a thorough security vulnerability scan for this ${language} code (${fileName}):\n\n${code}\n\nAdditional context: ${context}\n\nCheck for:\n1. SQL Injection vulnerabilities\n2. XSS (Cross-Site Scripting)\n3. CSRF vulnerabilities\n4. Authentication/Authorization issues\n5. Sensitive data exposure\n6. Insecure dependencies\n7. Input validation problems\n8. Cryptographic weaknesses\n9. Path traversal vulnerabilities\n10. Command injection risks\n\nFor each vulnerability found:\n- Severity level (Critical/High/Medium/Low)\n- Description of the issue\n- Potential impact\n- Proof of concept (if applicable)\n- Recommended fix with code example\n- CWE/CVE references if applicable\n\n${this.getSystemContextPrompt()}`;\n\n        return await this.openAIService.chat([\n            { role: 'system', content: 'You are ReviewerGPT, a security expert specializing in identifying and fixing vulnerabilities.' },\n            { role: 'user', content: prompt }\n        ]);\n    }\n\n    private async analyzePerformance(code: string, fileName: string, language: string, context: string): Promise<string> {\n        const prompt = `Analyze the performance characteristics of this ${language} code (${fileName}):\n\n${code}\n\nAdditional context: ${context}\n\nAnalyze:\n1. Time Complexity (Big O)\n2. Space Complexity\n3. Database query optimization\n4. Caching opportunities\n5. Algorithmic improvements\n6. Memory leaks\n7. Blocking operations\n8. Concurrency issues\n9. Resource management\n10. Scalability concerns\n\nProvide:\n- Performance bottlenecks identified\n- Optimization suggestions with examples\n- Estimated performance improvements\n- Trade-offs to consider\n\n${this.getSystemContextPrompt()}`;\n\n        return await this.openAIService.chat([\n            { role: 'system', content: 'You are ReviewerGPT, a performance optimization expert.' },\n            { role: 'user', content: prompt }\n        ]);\n    }\n\n    private async checkCodingStandards(code: string, language: string, context: string): Promise<string> {\n        const prompt = `Check this ${language} code against coding standards and best practices:\n\n${code}\n\nAdditional context: ${context}\n\nCheck for:\n1. Naming conventions\n2. Code formatting and indentation\n3. Function/method length\n4. Class cohesion\n5. SOLID principles adherence\n6. DRY (Don't Repeat Yourself)\n7. Comments and documentation\n8. Error handling patterns\n9. Code organization\n10. Language-specific idioms\n\nProvide:\n- Standards violations found\n- Severity of each violation\n- Suggested corrections\n- Overall compliance score\n\n${this.getSystemContextPrompt()}`;\n\n        return await this.openAIService.chat([\n            { role: 'system', content: 'You are ReviewerGPT, an expert in coding standards and best practices.' },\n            { role: 'user', content: prompt }\n        ]);\n    }\n\n    private async findCommonBugs(code: string, language: string): Promise<string> {\n        const prompt = `ACTIVELY SEARCH for bugs in this ${language} code:\n\n${code}\n\nFOCUS ON FINDING THESE COMMON BUGS:\n\n🔴 VS Code Extension / Web UI Bugs:\n- onclick handlers that should use addEventListener\n- Missing event.preventDefault() or event.stopPropagation()\n- z-index issues for clickable elements\n- CSP violations in webviews\n- Incorrect message passing between extension and webview\n\n🔴 JavaScript/TypeScript Bugs:\n- Undefined/null reference errors\n- Missing await keywords\n- Promise not being handled\n- Race conditions\n- Memory leaks (event listeners not removed)\n- Incorrect this binding\n- Array operations on undefined\n\n🔴 DOM Manipulation Issues:\n- querySelector returning null\n- Elements not existing when accessed\n- Event bubbling problems\n- Missing element attributes\n\n🔴 State Management Bugs:\n- State mutations instead of immutable updates\n- Stale closures\n- Inconsistent state updates\n\nFor EACH bug found, provide:\n1. Line number or code snippet\n2. Why it won't work\n3. The fix needed\n4. Example: \"Line 347: onclick won't work in VS Code webview. Use addEventListener instead.\"\n\nBE VERY THOROUGH! Find ALL bugs!\n\n${this.getSystemContextPrompt()}`;\n\n        return await this.openAIService.chat([\n            { role: 'system', content: 'You are ReviewerGPT, a bug-finding expert. Your job is to find EVERY bug that will prevent code from working correctly.' },\n            { role: 'user', content: prompt }\n        ]);\n    }\n\n    private async reviewTestCoverage(context: string): Promise<string> {\n        const prompt = `Review the test coverage and testing strategy:\n\n${context}\n\nAnalyze:\n1. Test coverage percentage\n2. Critical paths covered\n3. Edge cases tested\n4. Test quality and assertions\n5. Test maintainability\n6. Mocking and stubbing usage\n7. Integration vs unit tests balance\n8. Performance tests\n9. Security tests\n10. Missing test scenarios\n\nProvide:\n- Current coverage assessment\n- Critical gaps in testing\n- Recommended additional tests\n- Testing strategy improvements\n\n${this.getSystemContextPrompt()}`;\n\n        return await this.openAIService.chat([\n            { role: 'system', content: 'You are ReviewerGPT, an expert in software testing and quality assurance.' },\n            { role: 'user', content: prompt }\n        ]);\n    }\n\n    // Workflow helper methods\n\n    private async performCodeReview(request: TaskRequest, previousResults: TaskResult[]): Promise<string> {\n        const context = this.buildContextFromResults(previousResults);\n        return this.reviewCode('', 'workflow', 'unknown', `${request.prompt}\\n\\nContext:\\n${context}`);\n    }\n\n    private async performSecurityCheck(request: TaskRequest, previousResults: TaskResult[]): Promise<string> {\n        const context = this.buildContextFromResults(previousResults);\n        return this.performSecurityScan('', 'workflow', 'unknown', `${request.prompt}\\n\\nContext:\\n${context}`);\n    }\n\n    private async performPerformanceReview(request: TaskRequest, previousResults: TaskResult[]): Promise<string> {\n        const context = this.buildContextFromResults(previousResults);\n        return this.analyzePerformance('', 'workflow', 'unknown', `${request.prompt}\\n\\nContext:\\n${context}`);\n    }\n\n    private async performGeneralReview(request: TaskRequest, previousResults: TaskResult[]): Promise<string> {\n        const context = this.buildContextFromResults(previousResults);\n        const prompt = `Perform a review based on:\n\nRequest: ${request.prompt}\n\nPrevious results:\n${context}\n\nProvide comprehensive review and recommendations.\n\n${this.getSystemContextPrompt()}`;\n\n        return await this.openAIService.chat([\n            { role: 'system', content: 'You are ReviewerGPT, providing expert code review and analysis.' },\n            { role: 'user', content: prompt }\n        ]);\n    }\n\n    private buildContextFromResults(results: TaskResult[]): string {\n        return results\n            .filter(r => r.status === 'success')\n            .map(r => `${r.metadata?.step || 'Step'}: ${r.content}`)\n            .join('\\n\\n');\n    }\n\n    private async getWorkspaceCode(): Promise<string> {\n        // This would scan the workspace for code files\n        // For now, return a placeholder\n        return 'Workspace code scanning not yet implemented';\n    }\n\n    private async validateArchitectureUnderstanding(context: string): Promise<string> {\n        const prompt = `As a code review expert using a different AI model than the architect, validate the architect's understanding of the user's requirements.\n\nContext and conversation history:\n${context}\n\nYour task:\n1. Extract the original user requirements\n2. Identify what the architect proposed as a solution\n3. Compare the architect's interpretation with the actual requirements\n4. Find any gaps or misunderstandings\n5. Verify technical feasibility of the proposed architecture\n6. Check if all requirements are addressed\n\nProvide a detailed validation report including:\n- ✅ Requirements correctly understood\n- ❌ Requirements missed or misunderstood\n- ⚠️ Potential issues or concerns\n- 💡 Suggestions for clarification\n- 🏆 Overall assessment score (1-10)\n\nNote: You are using ${this.config.model} while the architect uses a different model (gpt-5-2025-09-12), ensuring independent validation.\n\n${this.getSystemContextPrompt()}`;\n\n        return await this.openAIService.chat([\n            { role: 'system', content: 'You are ReviewerGPT, validating another AI\\'s understanding of requirements. Be critical but constructive.' },\n            { role: 'user', content: prompt }\n        ]);\n    }\n}","/**\n * WorkflowEngine - Graph-based workflow execution for complex task orchestration\n * Enables parallel execution, conditional flows, and dynamic plan adjustment\n */\n\nimport { EventEmitter } from 'events';\n\nexport interface WorkflowNode {\n    id: string;\n    type: 'task' | 'decision' | 'parallel' | 'sequential' | 'loop';\n    agentId?: string;\n    task?: any;\n    condition?: (context: any) => boolean;\n    children?: string[];\n    dependencies?: string[];\n    retryPolicy?: RetryPolicy;\n    timeout?: number;\n    metadata?: any;\n}\n\nexport interface WorkflowEdge {\n    from: string;\n    to: string;\n    condition?: (context: any) => boolean;\n    weight?: number;\n}\n\nexport interface Workflow {\n    id: string;\n    name: string;\n    nodes: Map<string, WorkflowNode>;\n    edges: WorkflowEdge[];\n    startNode: string;\n    endNodes: string[];\n    context: Map<string, any>;\n    checkpoints: Checkpoint[];\n    status: WorkflowStatus;\n}\n\nexport interface WorkflowStatus {\n    state: 'pending' | 'running' | 'paused' | 'completed' | 'failed';\n    currentNodes: string[];\n    completedNodes: string[];\n    failedNodes: string[];\n    startTime?: number;\n    endTime?: number;\n    error?: string;\n}\n\nexport interface Checkpoint {\n    id: string;\n    nodeId: string;\n    timestamp: number;\n    context: Map<string, any>;\n    results: Map<string, any>;\n}\n\nexport interface RetryPolicy {\n    maxAttempts: number;\n    backoffMultiplier: number;\n    maxBackoffMs: number;\n}\n\nexport interface ExecutionPlan {\n    stages: ExecutionStage[];\n    estimatedDuration: number;\n    parallelism: number;\n    criticalPath: string[];\n}\n\nexport interface ExecutionStage {\n    stageId: string;\n    nodes: WorkflowNode[];\n    parallel: boolean;\n    dependencies: string[];\n    estimatedDuration: number;\n}\n\nexport interface TaskResult {\n    nodeId: string;\n    status: 'success' | 'failure' | 'skipped';\n    output?: any;\n    error?: string;\n    duration: number;\n    retries: number;\n}\n\nexport class WorkflowEngine {\n    private workflows: Map<string, Workflow> = new Map();\n    private eventBus: EventEmitter;\n    private executors: Map<string, WorkflowExecutor> = new Map();\n    private templates: Map<string, WorkflowTemplate> = new Map();\n\n    constructor() {\n        this.eventBus = new EventEmitter();\n        this.initializeTemplates();\n    }\n\n    /**\n     * Create a new workflow\n     */\n    public createWorkflow(name: string, template?: string): Workflow {\n        const id = this.generateWorkflowId();\n\n        const workflow: Workflow = {\n            id,\n            name,\n            nodes: new Map(),\n            edges: [],\n            startNode: '',\n            endNodes: [],\n            context: new Map(),\n            checkpoints: [],\n            status: {\n                state: 'pending',\n                currentNodes: [],\n                completedNodes: [],\n                failedNodes: []\n            }\n        };\n\n        // Apply template if provided\n        if (template && this.templates.has(template)) {\n            this.applyTemplate(workflow, this.templates.get(template)!);\n        }\n\n        this.workflows.set(id, workflow);\n        this.eventBus.emit('workflow-created', workflow);\n\n        return workflow;\n    }\n\n    /**\n     * Add a node to the workflow\n     */\n    public addNode(workflowId: string, node: WorkflowNode): void {\n        const workflow = this.workflows.get(workflowId);\n        if (!workflow) {\n            throw new Error(`Workflow ${workflowId} not found`);\n        }\n\n        workflow.nodes.set(node.id, node);\n\n        // Set as start node if it's the first\n        if (!workflow.startNode) {\n            workflow.startNode = node.id;\n        }\n\n        this.eventBus.emit('node-added', { workflowId, node });\n    }\n\n    /**\n     * Add an edge between nodes\n     */\n    public addEdge(workflowId: string, edge: WorkflowEdge): void {\n        const workflow = this.workflows.get(workflowId);\n        if (!workflow) {\n            throw new Error(`Workflow ${workflowId} not found`);\n        }\n\n        // Validate nodes exist\n        if (!workflow.nodes.has(edge.from) || !workflow.nodes.has(edge.to)) {\n            throw new Error(`Invalid edge: nodes not found`);\n        }\n\n        workflow.edges.push(edge);\n\n        // Update node children\n        const fromNode = workflow.nodes.get(edge.from)!;\n        if (!fromNode.children) {\n            fromNode.children = [];\n        }\n        fromNode.children.push(edge.to);\n\n        // Update node dependencies\n        const toNode = workflow.nodes.get(edge.to)!;\n        if (!toNode.dependencies) {\n            toNode.dependencies = [];\n        }\n        toNode.dependencies.push(edge.from);\n\n        this.eventBus.emit('edge-added', { workflowId, edge });\n    }\n\n    /**\n     * Create execution plan for the workflow\n     */\n    public createExecutionPlan(workflowId: string): ExecutionPlan {\n        const workflow = this.workflows.get(workflowId);\n        if (!workflow) {\n            throw new Error(`Workflow ${workflowId} not found`);\n        }\n\n        // Topological sort to find execution order\n        const sortedNodes = this.topologicalSort(workflow);\n\n        // Group nodes into stages based on dependencies\n        const stages = this.groupIntoStages(workflow, sortedNodes);\n\n        // Calculate critical path\n        const criticalPath = this.findCriticalPath(workflow);\n\n        // Estimate durations\n        const estimatedDuration = this.estimateDuration(stages);\n        const parallelism = this.calculateParallelism(stages);\n\n        return {\n            stages,\n            estimatedDuration,\n            parallelism,\n            criticalPath\n        };\n    }\n\n    /**\n     * Execute a workflow\n     */\n    public async execute(workflowId: string, context?: Map<string, any>): Promise<Map<string, TaskResult>> {\n        const workflow = this.workflows.get(workflowId);\n        if (!workflow) {\n            throw new Error(`Workflow ${workflowId} not found`);\n        }\n\n        // Initialize context\n        if (context) {\n            workflow.context = new Map([...workflow.context, ...context]);\n        }\n\n        // Create executor\n        const executor = new WorkflowExecutor(workflow, this.eventBus);\n        this.executors.set(workflowId, executor);\n\n        // Update status\n        workflow.status.state = 'running';\n        workflow.status.startTime = Date.now();\n        this.eventBus.emit('workflow-started', workflow);\n\n        try {\n            // Create execution plan\n            const plan = this.createExecutionPlan(workflowId);\n\n            // Execute plan\n            const results = await executor.execute(plan);\n\n            // Update status\n            workflow.status.state = 'completed';\n            workflow.status.endTime = Date.now();\n            this.eventBus.emit('workflow-completed', { workflow, results });\n\n            return results;\n        } catch (error) {\n            workflow.status.state = 'failed';\n            workflow.status.error = error instanceof Error ? error.message : String(error);\n            workflow.status.endTime = Date.now();\n            this.eventBus.emit('workflow-failed', { workflow, error });\n            throw error;\n        } finally {\n            this.executors.delete(workflowId);\n        }\n    }\n\n    /**\n     * Pause a running workflow\n     */\n    public pause(workflowId: string): void {\n        const executor = this.executors.get(workflowId);\n        if (executor) {\n            executor.pause();\n        }\n    }\n\n    /**\n     * Resume a paused workflow\n     */\n    public resume(workflowId: string): void {\n        const executor = this.executors.get(workflowId);\n        if (executor) {\n            executor.resume();\n        }\n    }\n\n    /**\n     * Cancel a workflow\n     */\n    public cancel(workflowId: string): void {\n        const executor = this.executors.get(workflowId);\n        if (executor) {\n            executor.cancel();\n        }\n    }\n\n    /**\n     * Create a checkpoint\n     */\n    public createCheckpoint(workflowId: string, nodeId: string): void {\n        const workflow = this.workflows.get(workflowId);\n        if (!workflow) return;\n\n        const checkpoint: Checkpoint = {\n            id: this.generateCheckpointId(),\n            nodeId,\n            timestamp: Date.now(),\n            context: new Map(workflow.context),\n            results: new Map()\n        };\n\n        workflow.checkpoints.push(checkpoint);\n        this.eventBus.emit('checkpoint-created', { workflowId, checkpoint });\n    }\n\n    /**\n     * Restore from checkpoint\n     */\n    public restoreFromCheckpoint(workflowId: string, checkpointId: string): void {\n        const workflow = this.workflows.get(workflowId);\n        if (!workflow) return;\n\n        const checkpoint = workflow.checkpoints.find(cp => cp.id === checkpointId);\n        if (!checkpoint) {\n            throw new Error(`Checkpoint ${checkpointId} not found`);\n        }\n\n        // Restore context\n        workflow.context = new Map(checkpoint.context);\n\n        // Reset status to continue from checkpoint\n        workflow.status.completedNodes = workflow.status.completedNodes.filter(\n            nodeId => this.isNodeBeforeCheckpoint(workflow, nodeId, checkpoint.nodeId)\n        );\n\n        this.eventBus.emit('checkpoint-restored', { workflowId, checkpoint });\n    }\n\n    /**\n     * Adjust workflow dynamically\n     */\n    public adjustWorkflow(workflowId: string, adjustment: WorkflowAdjustment): void {\n        const workflow = this.workflows.get(workflowId);\n        if (!workflow) return;\n\n        switch (adjustment.type) {\n            case 'add-node':\n                this.addNode(workflowId, adjustment.node!);\n                break;\n\n            case 'remove-node':\n                this.removeNode(workflowId, adjustment.nodeId!);\n                break;\n\n            case 'modify-node':\n                this.modifyNode(workflowId, adjustment.nodeId!, adjustment.modifications!);\n                break;\n\n            case 'reroute':\n                this.rerouteEdges(workflowId, adjustment.rerouting!);\n                break;\n        }\n\n        this.eventBus.emit('workflow-adjusted', { workflowId, adjustment });\n    }\n\n    /**\n     * Initialize workflow templates\n     */\n    private initializeTemplates(): void {\n        // Complex Task Template\n        this.templates.set('complex-task', {\n            name: 'Complex Task',\n            nodes: [\n                { id: 'research', type: 'task', agentId: 'ResearchAgent' },\n                { id: 'architect', type: 'task', agentId: 'ArchitectAgent', dependencies: ['research'] },\n                { id: 'review-arch', type: 'task', agentId: 'ReviewerGPT', dependencies: ['architect'] },\n                { id: 'implement', type: 'task', agentId: 'CodeSmithAgent', dependencies: ['review-arch'] },\n                { id: 'test', type: 'task', agentId: 'FixerBot', dependencies: ['implement'] },\n                { id: 'document', type: 'task', agentId: 'DocuBot', dependencies: ['test'] }\n            ]\n        });\n\n        // Parallel Research Template\n        this.templates.set('parallel-research', {\n            name: 'Parallel Research',\n            nodes: [\n                { id: 'split', type: 'parallel' },\n                { id: 'research1', type: 'task', agentId: 'ResearchAgent' },\n                { id: 'research2', type: 'task', agentId: 'ResearchAgent' },\n                { id: 'research3', type: 'task', agentId: 'ResearchAgent' },\n                { id: 'merge', type: 'sequential', dependencies: ['research1', 'research2', 'research3'] },\n                { id: 'synthesize', type: 'task', agentId: 'OrchestratorAgent', dependencies: ['merge'] }\n            ]\n        });\n\n        // Iterative Improvement Template\n        this.templates.set('iterative-improvement', {\n            name: 'Iterative Improvement',\n            nodes: [\n                { id: 'initial', type: 'task', agentId: 'CodeSmithAgent' },\n                { id: 'review', type: 'task', agentId: 'ReviewerGPT', dependencies: ['initial'] },\n                { id: 'decision', type: 'decision', dependencies: ['review'] },\n                { id: 'improve', type: 'task', agentId: 'FixerBot', dependencies: ['decision'] },\n                { id: 'loop', type: 'loop', dependencies: ['improve'] }\n            ]\n        });\n    }\n\n    /**\n     * Topological sort for node ordering\n     */\n    private topologicalSort(workflow: Workflow): WorkflowNode[] {\n        const sorted: WorkflowNode[] = [];\n        const visited = new Set<string>();\n        const visiting = new Set<string>();\n\n        const visit = (nodeId: string) => {\n            if (visited.has(nodeId)) return;\n            if (visiting.has(nodeId)) {\n                throw new Error('Circular dependency detected in workflow');\n            }\n\n            visiting.add(nodeId);\n            const node = workflow.nodes.get(nodeId);\n\n            if (node?.children) {\n                node.children.forEach(childId => visit(childId));\n            }\n\n            visiting.delete(nodeId);\n            visited.add(nodeId);\n            if (node) sorted.unshift(node);\n        };\n\n        // Start from root node\n        visit(workflow.startNode);\n\n        // Visit any disconnected nodes\n        workflow.nodes.forEach((_, nodeId) => {\n            if (!visited.has(nodeId)) {\n                visit(nodeId);\n            }\n        });\n\n        return sorted;\n    }\n\n    /**\n     * Group nodes into execution stages\n     */\n    private groupIntoStages(workflow: Workflow, sortedNodes: WorkflowNode[]): ExecutionStage[] {\n        const stages: ExecutionStage[] = [];\n        const nodeStage = new Map<string, number>();\n\n        sortedNodes.forEach(node => {\n            let stage = 0;\n\n            // Find maximum stage of dependencies\n            if (node.dependencies) {\n                node.dependencies.forEach(depId => {\n                    const depStage = nodeStage.get(depId) || 0;\n                    stage = Math.max(stage, depStage + 1);\n                });\n            }\n\n            nodeStage.set(node.id, stage);\n\n            // Add to stage\n            if (!stages[stage]) {\n                stages[stage] = {\n                    stageId: `stage_${stage}`,\n                    nodes: [],\n                    parallel: true,\n                    dependencies: stage > 0 ? [`stage_${stage - 1}`] : [],\n                    estimatedDuration: 0\n                };\n            }\n\n            stages[stage].nodes.push(node);\n        });\n\n        return stages;\n    }\n\n    /**\n     * Find critical path through workflow\n     */\n    private findCriticalPath(workflow: Workflow): string[] {\n        const distances = new Map<string, number>();\n        const previous = new Map<string, string>();\n\n        // Initialize distances\n        workflow.nodes.forEach((_, nodeId) => {\n            distances.set(nodeId, 0);\n        });\n\n        // Calculate longest path (critical path)\n        const sortedNodes = this.topologicalSort(workflow);\n\n        sortedNodes.forEach(node => {\n            const nodeDistance = distances.get(node.id) || 0;\n\n            node.children?.forEach(childId => {\n                const edgeWeight = 1; // Could use actual task duration estimates\n                const childDistance = distances.get(childId) || 0;\n\n                if (nodeDistance + edgeWeight > childDistance) {\n                    distances.set(childId, nodeDistance + edgeWeight);\n                    previous.set(childId, node.id);\n                }\n            });\n        });\n\n        // Find the end node with maximum distance\n        let maxDistance = 0;\n        let endNode = '';\n\n        workflow.nodes.forEach((node, nodeId) => {\n            if (!node.children || node.children.length === 0) {\n                const distance = distances.get(nodeId) || 0;\n                if (distance > maxDistance) {\n                    maxDistance = distance;\n                    endNode = nodeId;\n                }\n            }\n        });\n\n        // Reconstruct path\n        const path: string[] = [];\n        let current = endNode;\n\n        while (current) {\n            path.unshift(current);\n            current = previous.get(current) || '';\n        }\n\n        return path;\n    }\n\n    /**\n     * Estimate workflow duration\n     */\n    private estimateDuration(stages: ExecutionStage[]): number {\n        return stages.reduce((total, stage) => {\n            const stageDuration = stage.parallel\n                ? Math.max(...stage.nodes.map(n => n.timeout || 5000))\n                : stage.nodes.reduce((sum, n) => sum + (n.timeout || 5000), 0);\n            return total + stageDuration;\n        }, 0);\n    }\n\n    /**\n     * Calculate workflow parallelism\n     */\n    private calculateParallelism(stages: ExecutionStage[]): number {\n        const parallelCounts = stages.map(stage =>\n            stage.parallel ? stage.nodes.length : 1\n        );\n        return Math.max(...parallelCounts);\n    }\n\n    /**\n     * Check if node is before checkpoint\n     */\n    private isNodeBeforeCheckpoint(workflow: Workflow, nodeId: string, checkpointNodeId: string): boolean {\n        // Simple check - in production, do proper graph traversal\n        const sorted = this.topologicalSort(workflow);\n        const nodeIdx = sorted.findIndex(n => n.id === nodeId);\n        const checkpointIdx = sorted.findIndex(n => n.id === checkpointNodeId);\n        return nodeIdx < checkpointIdx;\n    }\n\n    /**\n     * Remove a node from workflow\n     */\n    private removeNode(workflowId: string, nodeId: string): void {\n        const workflow = this.workflows.get(workflowId);\n        if (!workflow) return;\n\n        // Remove node\n        workflow.nodes.delete(nodeId);\n\n        // Remove edges\n        workflow.edges = workflow.edges.filter(\n            edge => edge.from !== nodeId && edge.to !== nodeId\n        );\n\n        // Update dependencies\n        workflow.nodes.forEach(node => {\n            if (node.dependencies) {\n                node.dependencies = node.dependencies.filter(dep => dep !== nodeId);\n            }\n            if (node.children) {\n                node.children = node.children.filter(child => child !== nodeId);\n            }\n        });\n    }\n\n    /**\n     * Modify a node\n     */\n    private modifyNode(workflowId: string, nodeId: string, modifications: Partial<WorkflowNode>): void {\n        const workflow = this.workflows.get(workflowId);\n        if (!workflow) return;\n\n        const node = workflow.nodes.get(nodeId);\n        if (!node) return;\n\n        Object.assign(node, modifications);\n    }\n\n    /**\n     * Reroute edges\n     */\n    private rerouteEdges(workflowId: string, rerouting: { from: string; to: string; newTo: string }[]): void {\n        const workflow = this.workflows.get(workflowId);\n        if (!workflow) return;\n\n        rerouting.forEach(route => {\n            const edgeIdx = workflow.edges.findIndex(\n                e => e.from === route.from && e.to === route.to\n            );\n\n            if (edgeIdx >= 0) {\n                workflow.edges[edgeIdx].to = route.newTo;\n            }\n        });\n    }\n\n    /**\n     * Apply template to workflow\n     */\n    private applyTemplate(workflow: Workflow, template: WorkflowTemplate): void {\n        template.nodes.forEach(nodeConfig => {\n            const node: WorkflowNode = {\n                id: nodeConfig.id,\n                type: nodeConfig.type,\n                agentId: nodeConfig.agentId,\n                dependencies: nodeConfig.dependencies\n            };\n            workflow.nodes.set(node.id, node);\n        });\n\n        // Auto-create edges based on dependencies\n        workflow.nodes.forEach(node => {\n            if (node.dependencies) {\n                node.dependencies.forEach(depId => {\n                    workflow.edges.push({ from: depId, to: node.id });\n                });\n            }\n        });\n\n        if (template.nodes.length > 0) {\n            workflow.startNode = template.nodes[0].id;\n        }\n    }\n\n    /**\n     * Generate workflow ID\n     */\n    private generateWorkflowId(): string {\n        return `wf_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    }\n\n    /**\n     * Generate checkpoint ID\n     */\n    private generateCheckpointId(): string {\n        return `cp_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    }\n}\n\n/**\n * Workflow Executor - Handles actual execution of workflow\n */\nclass WorkflowExecutor {\n    private workflow: Workflow;\n    private eventBus: EventEmitter;\n    private paused: boolean = false;\n    private cancelled: boolean = false;\n    private results: Map<string, TaskResult> = new Map();\n\n    constructor(workflow: Workflow, eventBus: EventEmitter) {\n        this.workflow = workflow;\n        this.eventBus = eventBus;\n    }\n\n    public async execute(plan: ExecutionPlan): Promise<Map<string, TaskResult>> {\n        for (const stage of plan.stages) {\n            if (this.cancelled) break;\n\n            // Wait if paused\n            while (this.paused && !this.cancelled) {\n                await new Promise(resolve => setTimeout(resolve, 100));\n            }\n\n            // Execute stage\n            await this.executeStage(stage);\n\n            // Create checkpoint after each stage\n            this.createCheckpoint(stage.stageId);\n        }\n\n        return this.results;\n    }\n\n    private async executeStage(stage: ExecutionStage): Promise<void> {\n        this.eventBus.emit('stage-started', { workflowId: this.workflow.id, stage });\n\n        if (stage.parallel) {\n            // Execute nodes in parallel\n            const promises = stage.nodes.map(node => this.executeNode(node));\n            await Promise.all(promises);\n        } else {\n            // Execute nodes sequentially\n            for (const node of stage.nodes) {\n                await this.executeNode(node);\n            }\n        }\n\n        this.eventBus.emit('stage-completed', { workflowId: this.workflow.id, stage });\n    }\n\n    private async executeNode(node: WorkflowNode): Promise<void> {\n        const startTime = Date.now();\n        let retries = 0;\n        const maxRetries = node.retryPolicy?.maxAttempts || 1;\n\n        this.workflow.status.currentNodes.push(node.id);\n        this.eventBus.emit('node-started', { workflowId: this.workflow.id, node });\n\n        while (retries < maxRetries) {\n            try {\n                // Execute based on node type\n                let output: any;\n\n                switch (node.type) {\n                    case 'task':\n                        output = await this.executeTask(node);\n                        break;\n\n                    case 'decision':\n                        output = await this.executeDecision(node);\n                        break;\n\n                    case 'parallel':\n                        output = await this.executeParallel(node);\n                        break;\n\n                    case 'sequential':\n                        output = await this.executeSequential(node);\n                        break;\n\n                    case 'loop':\n                        output = await this.executeLoop(node);\n                        break;\n\n                    default:\n                        throw new Error(`Unknown node type: ${node.type}`);\n                }\n\n                // Store result\n                const result: TaskResult = {\n                    nodeId: node.id,\n                    status: 'success',\n                    output,\n                    duration: Date.now() - startTime,\n                    retries\n                };\n\n                this.results.set(node.id, result);\n                this.workflow.status.completedNodes.push(node.id);\n                this.workflow.status.currentNodes = this.workflow.status.currentNodes.filter(\n                    id => id !== node.id\n                );\n\n                this.eventBus.emit('node-completed', { workflowId: this.workflow.id, node, result });\n                return;\n\n            } catch (error) {\n                retries++;\n\n                if (retries < maxRetries) {\n                    // Calculate backoff\n                    const backoff = Math.min(\n                        1000 * Math.pow(node.retryPolicy?.backoffMultiplier || 2, retries),\n                        node.retryPolicy?.maxBackoffMs || 30000\n                    );\n\n                    this.eventBus.emit('node-retry', {\n                        workflowId: this.workflow.id,\n                        node,\n                        attempt: retries,\n                        error\n                    });\n\n                    await new Promise(resolve => setTimeout(resolve, backoff));\n                } else {\n                    // Max retries exceeded\n                    const result: TaskResult = {\n                        nodeId: node.id,\n                        status: 'failure',\n                        error: error instanceof Error ? error.message : String(error),\n                        duration: Date.now() - startTime,\n                        retries\n                    };\n\n                    this.results.set(node.id, result);\n                    this.workflow.status.failedNodes.push(node.id);\n                    this.workflow.status.currentNodes = this.workflow.status.currentNodes.filter(\n                        id => id !== node.id\n                    );\n\n                    this.eventBus.emit('node-failed', { workflowId: this.workflow.id, node, result });\n                    throw error;\n                }\n            }\n        }\n    }\n\n    private async executeTask(node: WorkflowNode): Promise<any> {\n        // Placeholder for actual task execution\n        // In production, this would call the appropriate agent\n        await new Promise(resolve => setTimeout(resolve, 1000));\n        return { result: `Task ${node.id} completed by ${node.agentId}` };\n    }\n\n    private async executeDecision(node: WorkflowNode): Promise<any> {\n        if (!node.condition) {\n            throw new Error(`Decision node ${node.id} missing condition`);\n        }\n\n        const decision = node.condition(this.workflow.context);\n        return { decision };\n    }\n\n    private async executeParallel(node: WorkflowNode): Promise<any> {\n        if (!node.children) return {};\n\n        const childNodes = node.children\n            .map(childId => this.workflow.nodes.get(childId))\n            .filter(Boolean) as WorkflowNode[];\n\n        const promises = childNodes.map(child => this.executeNode(child));\n        const results = await Promise.all(promises);\n\n        return { parallel: true, results };\n    }\n\n    private async executeSequential(node: WorkflowNode): Promise<any> {\n        if (!node.children) return {};\n\n        const results: any[] = [];\n\n        for (const childId of node.children) {\n            const childNode = this.workflow.nodes.get(childId);\n            if (childNode) {\n                await this.executeNode(childNode);\n                results.push(this.results.get(childId));\n            }\n        }\n\n        return { sequential: true, results };\n    }\n\n    private async executeLoop(node: WorkflowNode): Promise<any> {\n        if (!node.condition || !node.children || node.children.length === 0) {\n            throw new Error(`Loop node ${node.id} missing condition or children`);\n        }\n\n        const results: any[] = [];\n        let iteration = 0;\n        const maxIterations = 100; // Safety limit\n\n        while (node.condition(this.workflow.context) && iteration < maxIterations) {\n            for (const childId of node.children) {\n                const childNode = this.workflow.nodes.get(childId);\n                if (childNode) {\n                    await this.executeNode(childNode);\n                    results.push(this.results.get(childId));\n                }\n            }\n            iteration++;\n        }\n\n        return { loop: true, iterations: iteration, results };\n    }\n\n    private createCheckpoint(stageId: string): void {\n        const checkpoint: Checkpoint = {\n            id: `cp_${Date.now()}`,\n            nodeId: stageId,\n            timestamp: Date.now(),\n            context: new Map(this.workflow.context),\n            results: new Map(this.results)\n        };\n\n        this.workflow.checkpoints.push(checkpoint);\n        this.eventBus.emit('checkpoint-created', { workflowId: this.workflow.id, checkpoint });\n    }\n\n    public pause(): void {\n        this.paused = true;\n        this.workflow.status.state = 'paused';\n        this.eventBus.emit('workflow-paused', this.workflow);\n    }\n\n    public resume(): void {\n        this.paused = false;\n        this.workflow.status.state = 'running';\n        this.eventBus.emit('workflow-resumed', this.workflow);\n    }\n\n    public cancel(): void {\n        this.cancelled = true;\n        this.workflow.status.state = 'failed';\n        this.workflow.status.error = 'Workflow cancelled by user';\n        this.eventBus.emit('workflow-cancelled', this.workflow);\n    }\n}\n\n/**\n * Workflow Template\n */\ninterface WorkflowTemplate {\n    name: string;\n    nodes: Array<{\n        id: string;\n        type: 'task' | 'decision' | 'parallel' | 'sequential' | 'loop';\n        agentId?: string;\n        dependencies?: string[];\n    }>;\n}\n\n/**\n * Workflow Adjustment\n */\ninterface WorkflowAdjustment {\n    type: 'add-node' | 'remove-node' | 'modify-node' | 'reroute';\n    node?: WorkflowNode;\n    nodeId?: string;\n    modifications?: Partial<WorkflowNode>;\n    rerouting?: Array<{ from: string; to: string; newTo: string }>;\n}","/**\n * MultiAgentChatPanel - Main chat interface for KI AutoAgent\n * Provides a webview-based chat interface with agent selection and mode switching\n */\nimport * as vscode from 'vscode';\nimport * as path from 'path';\nimport { ConversationContextManager } from '../core/ConversationContextManager';\n\ninterface ChatMessage {\n    role: 'user' | 'assistant' | 'system' | 'agent-to-agent';\n    content: string;\n    agent?: string;\n    timestamp: string;\n    isCollapsible?: boolean;\n    metadata?: any;\n}\n\nexport class MultiAgentChatPanel {\n    public static currentPanel: MultiAgentChatPanel | undefined;\n    private readonly _panel: vscode.WebviewPanel;\n    private readonly _extensionUri: vscode.Uri;\n    private _disposables: vscode.Disposable[] = [];\n    private _messages: ChatMessage[] = [];\n    private _currentAgent: string = 'orchestrator';\n    private _currentMode: 'single' | 'auto' | 'workflow' = 'auto';\n    private _dispatcher: any; // Will be set from extension\n    private _contextManager: ConversationContextManager;\n\n    // Singleton pattern für Panel\n    public static createOrShow(extensionUri: vscode.Uri, dispatcher?: any) {\n        const column = vscode.ViewColumn.Two;\n        \n        if (MultiAgentChatPanel.currentPanel) {\n            MultiAgentChatPanel.currentPanel._panel.reveal(column);\n            if (dispatcher) {\n                MultiAgentChatPanel.currentPanel._dispatcher = dispatcher;\n            }\n            return MultiAgentChatPanel.currentPanel;\n        }\n\n        const panel = vscode.window.createWebviewPanel(\n            'multiAgentChat',\n            'KI AutoAgent Chat',\n            column,\n            {\n                enableScripts: true,\n                retainContextWhenHidden: true,\n                localResourceRoots: [\n                    vscode.Uri.joinPath(extensionUri, 'media'),\n                    vscode.Uri.joinPath(extensionUri, 'src', 'ui', 'webview')\n                ]\n            }\n        );\n\n        MultiAgentChatPanel.currentPanel = new MultiAgentChatPanel(panel, extensionUri, dispatcher);\n        return MultiAgentChatPanel.currentPanel;\n    }\n\n    private constructor(panel: vscode.WebviewPanel, extensionUri: vscode.Uri, dispatcher?: any) {\n        this._panel = panel;\n        this._extensionUri = extensionUri;\n        this._dispatcher = dispatcher;\n        this._contextManager = ConversationContextManager.getInstance();\n        \n        // Set the webview's initial html content\n        this._update();\n        \n        // Listen for when the panel is disposed\n        this._panel.onDidDispose(() => this.dispose(), null, this._disposables);\n        \n        // Handle messages from the webview\n        this._panel.webview.onDidReceiveMessage(\n            message => this._handleWebviewMessage(message),\n            null,\n            this._disposables\n        );\n\n        // Restore messages when panel becomes visible\n        this._panel.onDidChangeViewState(\n            e => {\n                if (this._panel.visible) {\n                    // Don't reset the HTML, just restore messages\n                    this._restoreMessages();\n                }\n            },\n            null,\n            this._disposables\n        );\n    }\n\n    private _update() {\n        const webview = this._panel.webview;\n        this._panel.title = \"KI AutoAgent Chat\";\n        this._panel.iconPath = vscode.Uri.joinPath(this._extensionUri, 'media', 'multi-agent-logo.svg');\n        this._panel.webview.html = this._getHtmlForWebview(webview);\n    }\n\n    private _getHtmlForWebview(webview: vscode.Webview) {\n        // Local path to css styles\n        const styleResetUri = webview.asWebviewUri(\n            vscode.Uri.joinPath(this._extensionUri, 'media', 'reset.css')\n        );\n        const styleVSCodeUri = webview.asWebviewUri(\n            vscode.Uri.joinPath(this._extensionUri, 'media', 'vscode.css')\n        );\n        // Add cache buster to force reload\n        const cacheBuster = Date.now();\n        const styleChatUri = webview.asWebviewUri(\n            vscode.Uri.joinPath(this._extensionUri, 'src', 'ui', 'webview', 'chat-fixed.css')\n        ) + `?v=${cacheBuster}`;\n        const scriptUri = webview.asWebviewUri(\n            vscode.Uri.joinPath(this._extensionUri, 'src', 'ui', 'webview', 'chat.js')\n        );\n\n        // Use a nonce to only allow specific scripts to be run\n        const nonce = getNonce();\n\n        return `<!DOCTYPE html>\n            <html lang=\"en\">\n            <head>\n                <meta charset=\"UTF-8\">\n                <meta http-equiv=\"Content-Security-Policy\" content=\"default-src 'none'; style-src ${webview.cspSource} 'unsafe-inline'; script-src 'nonce-${nonce}';\">\n                <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n                <link href=\"${styleResetUri}\" rel=\"stylesheet\">\n                <link href=\"${styleVSCodeUri}\" rel=\"stylesheet\">\n                <link href=\"${styleChatUri}\" rel=\"stylesheet\">\n                <title>KI AutoAgent Chat</title>\n            </head>\n            <body>\n                <div id=\"chat-container\">\n                    <!-- Minimalist Header -->\n                    <div id=\"chat-header\">\n                        <h3>KI AutoAgent Chat</h3>\n                        <button id=\"settings-btn\" title=\"Settings\">⚙️</button>\n                    </div>\n                    \n                    <!-- Messages Container -->\n                    <div id=\"messages-container\">\n                        <div class=\"welcome-message\">\n                            <h2>Welcome to KI AutoAgent</h2>\n                            <p>Start a conversation with our AI agents</p>\n                        </div>\n                    </div>\n                    \n                    <!-- Input Section with Bottom Controls -->\n                    <div id=\"input-section\">\n                        <!-- Action buttons above input -->\n                        <div id=\"action-buttons\">\n                            <button id=\"plan-first-btn\" class=\"action-btn\" title=\"Plan before implementing\">\n                                📋 Plan First\n                            </button>\n                            <button id=\"thinking-mode-btn\" class=\"action-btn toggle\" title=\"Enable thinking mode\">\n                                💭 Thinking\n                            </button>\n                            <button id=\"stop-btn\" class=\"action-btn danger\" title=\"Stop current operation\">\n                                ⏹ Stop\n                            </button>\n                        </div>\n                        \n                        <textarea id=\"message-input\" \n                                  placeholder=\"Message KI AutoAgent...\"\n                                  rows=\"3\"></textarea>\n                        \n                        <div id=\"bottom-controls\">\n                            <div id=\"mode-selector\">\n                                <button class=\"mode-option active\" data-agent=\"auto\" title=\"Automatic agent selection\">\n                                    🤖 Auto\n                                </button>\n                                <button class=\"mode-option\" data-agent=\"architect\" title=\"System architecture & design\">\n                                    🏗️ Architect\n                                </button>\n                                <button class=\"mode-option\" data-agent=\"codesmith\" title=\"Code implementation\">\n                                    💻 CodeSmith\n                                </button>\n                                <button class=\"mode-option\" data-agent=\"tradestrat\" title=\"Trading strategies\">\n                                    📈 TradeStrat\n                                </button>\n                                <button class=\"mode-option\" data-agent=\"research\" title=\"Web research\">\n                                    🔍 Research\n                                </button>\n                                <button class=\"mode-option\" data-agent=\"opus\" title=\"Conflict resolution\">\n                                    ⚖️ Opus\n                                </button>\n                            </div>\n                            \n                            <button id=\"send-btn\" title=\"Send message\">\n                                Send\n                            </button>\n                        </div>\n                    </div>\n                </div>\n                <script nonce=\"${nonce}\" src=\"${scriptUri}\"></script>\n            </body>\n            </html>`;\n    }\n\n    private async _handleWebviewMessage(message: any) {\n        switch (message.command) {\n            case 'sendMessage':\n                await this._processUserMessage(message.text, message.agent, message.mode);\n                break;\n            case 'changeAgent':\n                this._currentAgent = message.agent;\n                vscode.window.showInformationMessage(`Switched to ${message.agent}`);\n                break;\n            case 'changeMode':\n                this._currentMode = message.mode;\n                vscode.window.showInformationMessage(`Mode changed to ${message.mode}`);\n                break;\n            case 'clearChat':\n                this._messages = [];\n                break;\n            case 'quickAction':\n                await this._handleQuickAction(message.action);\n                break;\n            case 'planFirst':\n                await this._handlePlanFirst(message.text, message.agent, message.mode);\n                break;\n        }\n    }\n\n    private async _processUserMessage(text: string, agent: string, mode: string) {\n        console.log(`\\n💬 [CHAT] ============== NEW MESSAGE ==============`);\n        console.log(`💬 [CHAT] User text: \"${text}\"`);\n        console.log(`💬 [CHAT] Selected agent: \"${agent}\"`);\n        console.log(`💬 [CHAT] Selected mode: \"${mode}\"`);\n        console.log(`💬 [CHAT] Current agent field: \"${this._currentAgent}\"`);\n        console.log(`💬 [CHAT] Current mode field: \"${this._currentMode}\"`);\n        \n        // Add user message\n        const userMessage: ChatMessage = {\n            role: 'user',\n            content: text,\n            timestamp: new Date().toISOString()\n        };\n        this._messages.push(userMessage);\n        \n        // Save to conversation history\n        this._contextManager.addEntry({\n            timestamp: new Date().toISOString(),\n            agent: 'user',\n            step: 'input',\n            input: text,\n            output: '',\n            metadata: { mode, selectedAgent: agent }\n        });\n        \n        this._panel.webview.postMessage({\n            type: 'addMessage',\n            message: userMessage\n        });\n\n        // Show typing indicator\n        this._panel.webview.postMessage({\n            type: 'showTyping',\n            agent: agent\n        });\n\n        // Debug dispatcher state\n        console.log(`🔧 [CHAT] Dispatcher check: ${this._dispatcher ? 'AVAILABLE' : 'NOT AVAILABLE'}`);\n        if (this._dispatcher) {\n            console.log(`🔧 [CHAT] Dispatcher type: ${typeof this._dispatcher}`);\n            console.log(`🔧 [CHAT] Dispatcher has processRequest: ${typeof this._dispatcher.processRequest}`);\n            console.log(`🔧 [CHAT] Dispatcher has getAgentStats: ${typeof this._dispatcher.getAgentStats}`);\n            \n            try {\n                const stats = await this._dispatcher.getAgentStats();\n                console.log(`🔧 [CHAT] Agent stats keys: [${Object.keys(stats).join(', ')}]`);\n                console.log(`🔧 [CHAT] Agent stats count: ${Object.keys(stats).length}`);\n            } catch (error) {\n                console.error(`🔧 [CHAT] Error getting agent stats: ${error}`);\n            }\n        } else {\n            console.error(`🔧 [CHAT] CRITICAL: No dispatcher available!`);\n        }\n\n        try {\n            console.log(`🎯 [CHAT MODE] Decision tree:`);\n            console.log(`🎯 [CHAT MODE] - mode === 'auto': ${mode === 'auto'}`);\n            console.log(`🎯 [CHAT MODE] - mode === 'single': ${mode === 'single'}`);\n            console.log(`🎯 [CHAT MODE] - mode === 'workflow': ${mode === 'workflow'}`);\n            console.log(`🎯 [CHAT MODE] - this._dispatcher exists: ${!!this._dispatcher}`);\n            \n            // Process based on mode\n            if (mode === 'auto' && this._dispatcher) {\n                console.log(`🎯 [CHAT MODE] ✅ Entering AUTO mode with orchestrator`);\n\n                // Create streaming message for orchestrator\n                const streamingMessageId = `streaming-${Date.now()}`;\n                this._addStreamingMessage(streamingMessageId, 'orchestrator');\n\n                // Show immediate feedback\n                this._updateStreamingMessage(streamingMessageId, '🎭 Analyzing your request...\\n', false);\n\n                // Use orchestrator with streaming\n                const response = await this._callAgentWithStreaming('orchestrator', text, streamingMessageId);\n\n                // Finalize the streaming message\n                this._finalizeStreamingMessage(streamingMessageId, response.content, response.metadata);\n\n                // Save to conversation history\n                this._contextManager.addEntry({\n                    timestamp: new Date().toISOString(),\n                    agent: 'orchestrator',\n                    step: 'orchestration',\n                    input: text,\n                    output: response.content,\n                    metadata: response.metadata\n                });\n            } else if (mode === 'single') {\n                console.log(`🎯 [CHAT MODE] ✅ Entering SINGLE mode with agent: \"${agent}\"`);\n                console.log(`🎯 [CHAT MODE] Agent value type: ${typeof agent}`);\n                console.log(`🎯 [CHAT MODE] Agent exact value: '${agent}'`);\n                console.log(`🎯 [CHAT MODE] Agent length: ${agent?.length}`);\n                \n                // Create a streaming message placeholder\n                const streamingMessageId = `streaming-${Date.now()}`;\n                this._addStreamingMessage(streamingMessageId, agent);\n                \n                // Direct chat with selected agent\n                const response = await this._callAgentWithStreaming(agent, text, streamingMessageId);\n                \n                // Finalize the streaming message with metadata\n                this._finalizeStreamingMessage(streamingMessageId, response.content, response.metadata);\n            } else if (mode === 'workflow') {\n                console.log(`🎯 [CHAT MODE] ✅ Entering WORKFLOW mode`);\n                // Multi-agent workflow - show inter-agent communication\n                await this._processWorkflow(text);\n            } else {\n                console.error(`🎯 [CHAT MODE] ❌ No valid mode path! Defaulting to error message`);\n                this._addErrorMessage(`Invalid mode configuration: mode=\"${mode}\", agent=\"${agent}\", dispatcher=${!!this._dispatcher}`);\n            }\n        } catch (error) {\n            console.error('[DEBUG] Error in _processUserMessage:', error);\n            this._addErrorMessage(`Error: ${(error as any).message}`);\n        } finally {\n            this._panel.webview.postMessage({\n                type: 'hideTyping'\n            });\n        }\n    }\n\n    private async _callAgent(agentId: string, prompt: string): Promise<{ content: string, metadata?: any }> {\n        console.log(`\\n🤖 [CALL AGENT] ====================================`);\n        console.log(`🤖 [CALL AGENT] AgentId: \"${agentId}\"`);\n        console.log(`🤖 [CALL AGENT] Prompt: \"${prompt.substring(0, 100)}...\"`);\n        console.log(`🤖 [CALL AGENT] Dispatcher available: ${!!this._dispatcher}`);\n        \n        if (!this._dispatcher) {\n            const errorMsg = 'Error: No dispatcher available. Please check agent configuration.';\n            console.error(`🤖 [CALL AGENT] ❌ ${errorMsg}`);\n            return {\n                content: errorMsg,\n                metadata: null\n            };\n        }\n        \n        console.log(`🤖 [CALL AGENT] Dispatcher type: ${typeof this._dispatcher}`);\n        console.log(`🤖 [CALL AGENT] Dispatcher.processRequest: ${typeof this._dispatcher.processRequest}`);\n\n        try {\n            // Create task request for the dispatcher\n            const taskRequest = {\n                prompt: prompt,\n                command: agentId, // Use agent ID as command\n                context: await this._getWorkspaceContext()\n            };\n\n            console.log('[DEBUG] Created taskRequest:', JSON.stringify(taskRequest, null, 2));\n            console.log('[DEBUG] Calling dispatcher.processRequest...');\n\n            // Call the real dispatcher\n            const result = await this._dispatcher.processRequest(taskRequest);\n            \n            console.log('[DEBUG] Dispatcher returned:', JSON.stringify(result, null, 2));\n            \n            if (result.status === 'success' || result.status === 'partial_success') {\n                return {\n                    content: result.content,\n                    metadata: result.metadata\n                };\n            } else {\n                return {\n                    content: `Error: ${result.content}`,\n                    metadata: null\n                };\n            }\n        } catch (error) {\n            const errorMsg = `Agent Error: ${(error as any).message}\\nStack: ${(error as any).stack}`;\n            console.error('[DEBUG]', errorMsg);\n            return {\n                content: errorMsg,\n                metadata: null\n            };\n        }\n    }\n\n    private async _callAgentWithStreaming(agentId: string, prompt: string, messageId: string): Promise<{ content: string, metadata?: any }> {\n        console.log(`\\n🤖 [CALL AGENT WITH STREAMING] ====================================`);\n        console.log(`🤖 [STREAMING] AgentId: \"${agentId}\"`);\n        console.log(`🤖 [STREAMING] AgentId type: ${typeof agentId}`);\n        console.log(`🤖 [STREAMING] AgentId exact: '${agentId}'`);\n        console.log(`🤖 [STREAMING] MessageId: \"${messageId}\"`);\n        console.log(`🤖 [STREAMING] Creating task request with command: '${agentId}'`);\n        \n        if (!this._dispatcher) {\n            const errorMsg = 'Error: No dispatcher available. Please check agent configuration.';\n            console.error(`🤖 [STREAMING] ❌ ${errorMsg}`);\n            return {\n                content: errorMsg,\n                metadata: null\n            };\n        }\n\n        try {\n            let fullContent = '';\n            \n            // Get conversation history for context\n            const conversationHistory = this._contextManager.getFormattedContext(10);\n            \n            // Create task request with streaming callback and conversation history\n            const taskRequest = {\n                prompt: prompt,\n                command: agentId,\n                context: await this._getWorkspaceContext(),\n                globalContext: conversationHistory,\n                onPartialResponse: (partialContent: string) => {\n                    console.log(`🤖 [STREAMING] Partial content: ${partialContent.length} chars`);\n\n                    // Check if this is a workflow step notification\n                    if (partialContent.includes('🔄 **Step')) {\n                        // Send as a separate system message\n                        const stepMatch = partialContent.match(/🔄 \\*\\*Step (\\d+)\\/(\\d+)\\*\\*: @(\\w+) - (.+)/);\n                        if (stepMatch) {\n                            const [, current, total, agent, description] = stepMatch;\n                            this._addSystemMessage(`🔄 Step ${current}/${total}: @${agent} - ${description}`);\n                        }\n                    } else if (partialContent.includes('✅ Completed:')) {\n                        // Don't add completion previews to the main message\n                        // They will be shown in the final agent response\n                        return;\n                    } else {\n                        // Extract and process tool markers with agent context\n                        const currentAgent = agentId; // Agent executing the tools\n                        let cleanedContent = partialContent;\n\n                        // Extract <<TOOL>> markers and create tool notifications with agent color\n                        const toolMatches = [...partialContent.matchAll(/<<TOOL>>(.*?)<<TOOL_END>>/gs)];\n                        for (const match of toolMatches) {\n                            const toolContent = match[1];\n                            this._addToolNotification(toolContent, currentAgent, messageId);\n                            cleanedContent = cleanedContent.replace(match[0], '');\n                        }\n\n                        // Clean other markers\n                        cleanedContent = cleanedContent\n                            .replace(/<<TOOL_RESULT>>.*?<<TOOL_RESULT_END>>/gs, '')\n                            .replace(/<<THINKING>>.*?<<THINKING_END>>/gs, '')\n                            .replace(/🛠️ \\*?Claude is using tools.*?\\*?\\n*/g, '');\n\n                        // Check for new system tool message format\n                        if (cleanedContent.includes('SYSTEM_TOOL_MESSAGE:')) {\n                            const parts = cleanedContent.split('SYSTEM_TOOL_MESSAGE:');\n                            if (parts[1]) {\n                                this._addToolNotification(parts[1], currentAgent, messageId);\n                                cleanedContent = parts[0];\n                            }\n                        }\n\n                        // Only add text content if there's actual content after cleaning\n                        if (cleanedContent.trim().length > 0) {\n                            fullContent += cleanedContent;\n                            this._updateStreamingMessage(messageId, cleanedContent);\n                        }\n                    }\n                }\n            };\n\n            // Call the dispatcher\n            const result = await this._dispatcher.processRequest(taskRequest);\n            \n            // Use accumulated content if available, otherwise use result content\n            const finalContent = fullContent || result.content;\n            \n            // Save agent response to conversation history\n            if (finalContent) {\n                this._contextManager.addEntry({\n                    timestamp: new Date().toISOString(),\n                    agent: agentId,\n                    step: 'response',\n                    input: prompt,\n                    output: finalContent,\n                    metadata: result.metadata\n                });\n            }\n            \n            if (result.status === 'success' || result.status === 'partial_success') {\n                return {\n                    content: finalContent,\n                    metadata: result.metadata\n                };\n            } else {\n                return {\n                    content: `Error: ${result.content}`,\n                    metadata: null\n                };\n            }\n        } catch (error) {\n            const errorMsg = `Agent Error: ${(error as any).message}`;\n            console.error('[STREAMING]', errorMsg);\n            return {\n                content: errorMsg,\n                metadata: null\n            };\n        }\n    }\n\n    private _addStreamingMessage(messageId: string, agent: string) {\n        // Create initial streaming message\n        const streamingMessage: ChatMessage = {\n            role: 'assistant',\n            content: '',\n            agent: agent,\n            timestamp: new Date().toISOString(),\n            isCollapsible: false,\n            metadata: { messageId, isStreaming: true }\n        };\n        this._messages.push(streamingMessage);\n        \n        this._panel.webview.postMessage({\n            type: 'addStreamingMessage',\n            message: streamingMessage\n        });\n    }\n\n    private _updateStreamingMessage(messageId: string, partialContent: string, isToolNotification: boolean = false) {\n        // Keep track of processed content\n        let contentToAdd = partialContent;\n        let hasToolNotifications = false;\n        let needsNewBubble = false;\n        \n        // Check for thinking notifications\n        while (contentToAdd.includes('<<THINKING>>') && contentToAdd.includes('<<THINKING_END>>')) {\n            const thinkingMatch = contentToAdd.match(/<<THINKING>>(.*?)<<THINKING_END>>/s);\n            if (thinkingMatch) {\n                const thinkingContent = thinkingMatch[1];\n                this._addSystemNotification('💭 ' + thinkingContent, messageId);\n                contentToAdd = contentToAdd.replace(/<<THINKING>>.*?<<THINKING_END>>/s, '');\n                hasToolNotifications = true;\n            } else {\n                break;\n            }\n        }\n        \n        // Check for tool notifications marked with special tags\n        while (contentToAdd.includes('<<TOOL>>') && contentToAdd.includes('<<TOOL_END>>')) {\n            const toolMatch = contentToAdd.match(/<<TOOL>>(.*?)<<TOOL_END>>/s);\n            if (toolMatch) {\n                const toolContent = toolMatch[1];\n                const toolMsgId = this._addSystemNotification(toolContent, messageId);\n                contentToAdd = contentToAdd.replace(/<<TOOL>>.*?<<TOOL_END>>/s, '');\n                hasToolNotifications = true;\n            } else {\n                break;\n            }\n        }\n        \n        // Check for tool results to update existing tool notifications\n        while (contentToAdd.includes('<<TOOL_RESULT>>') && contentToAdd.includes('<<TOOL_RESULT_END>>')) {\n            const resultMatch = contentToAdd.match(/<<TOOL_RESULT>>(.*?)<<TOOL_RESULT_END>>/s);\n            if (resultMatch) {\n                const [toolId, result] = resultMatch[1].split('||');\n                // Find and update the corresponding tool message\n                this._updateToolResult(toolId, result);\n                contentToAdd = contentToAdd.replace(/<<TOOL_RESULT>>.*?<<TOOL_RESULT_END>>/s, '');\n            } else {\n                break;\n            }\n        }\n        \n        // Check for text start marker\n        if (contentToAdd.includes('<<TEXT_START>>')) {\n            contentToAdd = contentToAdd.replace(/<<TEXT_START>>/g, '');\n            needsNewBubble = true;\n        }\n        \n        // Only update main message if there's content left after removing notifications\n        if (contentToAdd.trim()) {\n            // If we need a new bubble or don't have an existing message, create one\n            let message = this._messages.find(m => m.metadata?.messageId === messageId && m.role === 'assistant');\n            \n            if (needsNewBubble && !message) {\n                // Create a new assistant message bubble\n                const newMessage: ChatMessage = {\n                    role: 'assistant',\n                    content: contentToAdd,\n                    agent: 'assistant',\n                    timestamp: new Date().toISOString(),\n                    metadata: { messageId: `${messageId}-text`, isStreaming: true }\n                };\n                this._messages.push(newMessage);\n                \n                this._panel.webview.postMessage({\n                    type: 'addStreamingMessage',\n                    message: newMessage\n                });\n            } else if (message) {\n                // Update existing message\n                message.content += contentToAdd;\n                \n                this._panel.webview.postMessage({\n                    type: 'updateStreamingMessage',  \n                    messageId: message.metadata?.messageId || messageId,\n                    partialContent: contentToAdd\n                });\n            }\n        }\n    }\n\n    private _isSpecialMessage(content: string): boolean {\n        // Check if content is a tool notification or special message\n        const specialPatterns = [\n            /^🚀 \\*\\*Claude is initializing/,\n            /^🔧 \\*\\*Using tool:/,\n            /^⚠️ \\*\\*System Error:/,\n            /^✨ \\*\\*Tool:/,\n            /^📝 \\*\\*Result:/,\n            /^✅ \\*\\*Task completed:/\n        ];\n        return specialPatterns.some(pattern => pattern.test(content));\n    }\n\n    private _addSystemNotification(content: string, parentMessageId?: string): string {\n        // Add a small delay to ensure proper ordering of messages\n        const messageId = `system-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n        const systemMessage: ChatMessage = {\n            role: 'system',\n            content: content,\n            timestamp: new Date().toISOString(),\n            metadata: { \n                isSystemNotification: true, \n                parentMessageId: parentMessageId,\n                messageId: messageId\n            }\n        };\n        this._messages.push(systemMessage);\n        \n        // Send as a separate addMessage event to create a new bubble\n        setTimeout(() => {\n            this._panel.webview.postMessage({\n                type: 'addMessage',\n                message: systemMessage\n            });\n        }, 10);\n        \n        return messageId;\n    }\n    \n    private _updateToolResult(toolId: string, result: string) {\n        // Find the last tool message and update it with the result\n        for (let i = this._messages.length - 1; i >= 0; i--) {\n            const message = this._messages[i];\n            if (message.role === 'system' && message.content.includes(toolId)) {\n                // Append result to the tool message\n                if (!message.content.includes('**Result:**')) {\n                    message.content += `\\n\\n**Result:**\\n${result}`;\n                    \n                    // Update the message in the webview\n                    this._panel.webview.postMessage({\n                        type: 'updateMessage',\n                        messageId: message.metadata?.messageId,\n                        content: message.content\n                    });\n                }\n                break;\n            }\n        }\n    }\n\n    private _finalizeStreamingMessage(messageId: string, fullContent: string, metadata?: any) {\n        // Find and finalize the streaming message\n        const message = this._messages.find(m => m.metadata?.messageId === messageId);\n        if (message) {\n            // Update agent if metadata includes it (for workflow results)\n            if (metadata?.agent) {\n                message.agent = metadata.agent;\n            }\n\n            // Don't add metadata info to content, add it as a separate message\n            message.content = fullContent;\n            message.metadata = { ...message.metadata, ...metadata, isStreaming: false };\n            message.isCollapsible = fullContent.length > 500;\n\n            this._panel.webview.postMessage({\n                type: 'finalizeStreamingMessage',\n                messageId: messageId,\n                fullContent: message.content,\n                metadata: message.metadata,\n                agent: message.agent\n            });\n\n            // Add metadata as a separate completion message if available\n            if (metadata && (metadata.usage || metadata.cost || metadata.duration)) {\n                this._addCompletionMessage(metadata);\n            }\n        }\n    }\n\n    private _addCompletionMessage(metadata: any) {\n        let completionContent = '✅ **Task completed successfully!**\\n\\n';\n        \n        // Add execution details\n        if (metadata.duration) {\n            completionContent += `⏱️ **Execution Time:** ${metadata.duration}\\n`;\n        }\n        \n        // Add token usage\n        if (metadata.usage) {\n            const inputTokens = metadata.usage.inputTokens || 0;\n            const outputTokens = metadata.usage.outputTokens || 0;\n            const totalTokens = inputTokens + outputTokens;\n            completionContent += `📊 **Tokens Used:** ${totalTokens} (Input: ${inputTokens}, Output: ${outputTokens})\\n`;\n        }\n        \n        // Add cost if available\n        if (metadata.cost) {\n            completionContent += `💰 **Cost:** $${metadata.cost.toFixed(4)}\\n`;\n        }\n        \n        // Add cache info if available\n        if (metadata.usage?.cacheCreationInputTokens || metadata.usage?.cacheReadInputTokens) {\n            const cacheCreation = metadata.usage.cacheCreationInputTokens || 0;\n            const cacheRead = metadata.usage.cacheReadInputTokens || 0;\n            completionContent += `💾 **Cache:** ${cacheCreation} created, ${cacheRead} read\\n`;\n        }\n        \n        const completionMessage: ChatMessage = {\n            role: 'system',\n            content: completionContent,\n            timestamp: new Date().toISOString(),\n            metadata: { \n                isCompletionMessage: true,\n                ...metadata\n            }\n        };\n        this._messages.push(completionMessage);\n        \n        this._panel.webview.postMessage({\n            type: 'addMessage',\n            message: completionMessage\n        });\n    }\n\n    private _buildMetadataInfo(metadata?: any): string {\n        let metadataInfo = '';\n        \n        // Token usage\n        if (metadata?.usage) {\n            const inputTokens = metadata.usage.inputTokens || 0;\n            const outputTokens = metadata.usage.outputTokens || 0;\n            const cacheCreation = metadata.usage.cacheCreationInputTokens || 0;\n            const cacheRead = metadata.usage.cacheReadInputTokens || 0;\n            const totalTokens = inputTokens + outputTokens;\n            \n            metadataInfo += `\\n\\n---\\n📊 **Tokens**: ${totalTokens} total (Input: ${inputTokens}, Output: ${outputTokens})`;\n            \n            if (cacheCreation > 0 || cacheRead > 0) {\n                metadataInfo += `\\n💾 **Cache**: ${cacheCreation} created, ${cacheRead} read`;\n            }\n        }\n        \n        // Cost and performance\n        if (metadata?.totalCostUsd !== undefined) {\n            metadataInfo += `\\n💰 **Cost**: $${metadata.totalCostUsd.toFixed(6)}`;\n        }\n        if (metadata?.durationMs !== undefined) {\n            metadataInfo += `\\n⏱️ **Duration**: ${metadata.durationMs}ms`;\n            if (metadata?.durationApiMs !== undefined) {\n                metadataInfo += ` (API: ${metadata.durationApiMs}ms)`;\n            }\n        }\n        \n        // Session and model info\n        if (metadata?.model) {\n            metadataInfo += `\\n🤖 **Model**: ${metadata.model}`;\n        }\n        if (metadata?.sessionId) {\n            metadataInfo += `\\n🔗 **Session**: ${metadata.sessionId.substring(0, 8)}...`;\n        }\n        \n        // Stop reason\n        if (metadata?.stopReason) {\n            metadataInfo += `\\n⚡ **Stop reason**: ${metadata.stopReason}`;\n        }\n        \n        return metadataInfo;\n    }\n\n    private async _getWorkspaceContext() {\n        return {\n            activeEditor: vscode.window.activeTextEditor,\n            workspaceRoots: vscode.workspace.workspaceFolders,\n            openDocuments: vscode.workspace.textDocuments,\n            selectedText: vscode.window.activeTextEditor?.document.getText(vscode.window.activeTextEditor.selection),\n            currentFile: vscode.window.activeTextEditor?.document.fileName\n        };\n    }\n\n    private async _processWorkflow(prompt: string) {\n        // Simulate a multi-agent workflow\n        const workflow = [\n            { agent: 'orchestrator', action: 'Analyzing request...' },\n            { agent: 'architect', action: 'Designing solution architecture...' },\n            { agent: 'codesmith', action: 'Implementing code...' },\n            { agent: 'reviewer', action: 'Reviewing implementation...' }\n        ];\n\n        for (const step of workflow) {\n            // Show agent-to-agent communication\n            const agentMessage: ChatMessage = {\n                role: 'agent-to-agent',\n                content: step.action,\n                agent: step.agent,\n                timestamp: new Date().toISOString(),\n                isCollapsible: true\n            };\n            this._messages.push(agentMessage);\n            \n            this._panel.webview.postMessage({\n                type: 'addMessage',\n                message: agentMessage\n            });\n\n            await new Promise(resolve => setTimeout(resolve, 500));\n        }\n\n        // Final response\n        this._addAgentResponse('Workflow completed successfully!', 'orchestrator');\n    }\n\n    private _addAgentResponse(content: string, agent: string, metadata?: any) {\n        console.log(`📝 [ADD RESPONSE] Adding agent response`);\n        console.log(`📝 [ADD RESPONSE] Content length: ${content?.length || 0}`);\n        console.log(`📝 [ADD RESPONSE] Agent: ${agent}`);\n        console.log(`📝 [ADD RESPONSE] Metadata:`, metadata);\n        \n        // Build comprehensive metadata info\n        let metadataInfo = '';\n        \n        // Token usage\n        if (metadata?.usage) {\n            const inputTokens = metadata.usage.inputTokens || 0;\n            const outputTokens = metadata.usage.outputTokens || 0;\n            const cacheCreation = metadata.usage.cacheCreationInputTokens || 0;\n            const cacheRead = metadata.usage.cacheReadInputTokens || 0;\n            const totalTokens = inputTokens + outputTokens;\n            \n            metadataInfo += `\\n\\n---\\n📊 **Tokens**: ${totalTokens} total (Input: ${inputTokens}, Output: ${outputTokens})`;\n            \n            if (cacheCreation > 0 || cacheRead > 0) {\n                metadataInfo += `\\n💾 **Cache**: ${cacheCreation} created, ${cacheRead} read`;\n            }\n        }\n        \n        // Cost and performance\n        if (metadata?.totalCostUsd !== undefined) {\n            metadataInfo += `\\n💰 **Cost**: $${metadata.totalCostUsd.toFixed(6)}`;\n        }\n        if (metadata?.durationMs !== undefined) {\n            metadataInfo += `\\n⏱️ **Duration**: ${metadata.durationMs}ms`;\n            if (metadata?.durationApiMs !== undefined) {\n                metadataInfo += ` (API: ${metadata.durationApiMs}ms)`;\n            }\n        }\n        \n        // Session and model info\n        if (metadata?.model) {\n            metadataInfo += `\\n🤖 **Model**: ${metadata.model}`;\n        }\n        if (metadata?.sessionId) {\n            metadataInfo += `\\n🔗 **Session**: ${metadata.sessionId.substring(0, 8)}...`;\n        }\n        \n        // Stop reason\n        if (metadata?.stopReason) {\n            metadataInfo += `\\n⚡ **Stop reason**: ${metadata.stopReason}`;\n        }\n\n        const assistantMessage: ChatMessage = {\n            role: 'assistant',\n            content: content + metadataInfo,\n            agent: agent,\n            timestamp: new Date().toISOString(),\n            isCollapsible: content.length > 500,\n            metadata: metadata\n        };\n        this._messages.push(assistantMessage);\n        \n        console.log(`📝 [ADD RESPONSE] Final message to send:`, assistantMessage);\n        console.log(`📝 [ADD RESPONSE] Total messages in history: ${this._messages.length}`);\n        \n        const postResult = this._panel.webview.postMessage({\n            type: 'addMessage',\n            message: assistantMessage\n        });\n        \n        console.log(`📝 [ADD RESPONSE] postMessage result:`, postResult);\n    }\n\n    private _addSystemMessage(content: string) {\n        const systemMessage: ChatMessage = {\n            role: 'system',\n            content: content,\n            timestamp: new Date().toISOString()\n        };\n        this._messages.push(systemMessage);\n\n        this._panel.webview.postMessage({\n            type: 'addMessage',\n            message: systemMessage\n        });\n    }\n\n    private _addToolNotification(content: string, agentName: string, relatedMessageId?: string): string {\n        const toolMsgId = `tool_${Date.now()}_${Math.random()}`;\n\n        // Get agent-specific color based on normalized agent name\n        const normalizedAgent = agentName.toLowerCase().replace('agent', '').replace('gpt', '').replace('claude', '');\n        const agentColor = this._getAgentColor(normalizedAgent);\n        const agentEmoji = this._getAgentEmoji(normalizedAgent);\n\n        const toolMessage: ChatMessage = {\n            role: 'system',\n            content: content,\n            agent: agentName,\n            timestamp: new Date().toISOString(),\n            metadata: {\n                isToolNotification: true,\n                relatedMessageId,\n                toolMsgId,\n                agentColor,\n                agentEmoji,\n                agentName\n            }\n        };\n\n        this._messages.push(toolMessage);\n\n        // Send to WebView with tool notification flag\n        this._panel.webview.postMessage({\n            type: 'addMessage',\n            message: toolMessage\n        });\n\n        return toolMsgId;\n    }\n\n    private _getAgentColor(agent: string): string {\n        const colors: { [key: string]: string } = {\n            'orchestrator': '#8B5CF6',     // Purple\n            'architect': '#10B981',        // Emerald Green (changed from blue)\n            'codesmith': '#F97316',        // Orange\n            'research': '#EAB308',         // Gold\n            'tradestrat': '#14B8A6',       // Turquoise\n            'opusarbitrator': '#DC2626',   // Crimson\n            'docubot': '#6366F1',          // Indigo\n            'reviewer': '#EC4899',         // Pink\n            'fixer': '#8B5CF6'             // Purple\n        };\n        return colors[agent.toLowerCase()] || '#3B82F6'; // Default to blue for system\n    }\n\n    private _getAgentEmoji(agent: string): string {\n        const emojis: { [key: string]: string } = {\n            'orchestrator': '🎯',\n            'architect': '🏗️',\n            'codesmith': '🛠️',\n            'research': '🔍',\n            'tradestrat': '📈',\n            'opusarbitrator': '⚖️',\n            'docubot': '📚',\n            'reviewer': '🔎',\n            'fixer': '🔧'\n        };\n        return emojis[agent.toLowerCase()] || '🤖';\n    }\n\n    private _addErrorMessage(content: string) {\n        const errorMessage: ChatMessage = {\n            role: 'system',\n            content: content,\n            timestamp: new Date().toISOString()\n        };\n        this._messages.push(errorMessage);\n\n        this._panel.webview.postMessage({\n            type: 'addMessage',\n            message: errorMessage\n        });\n    }\n\n    private _restoreMessages() {\n        // Send all stored messages back to the webview\n        if (this._messages.length > 0) {\n            this._panel.webview.postMessage({\n                type: 'restoreMessages',\n                messages: this._messages\n            });\n        }\n    }\n\n    private async _handleQuickAction(action: string) {\n        switch (action) {\n            case 'help':\n                this._addAgentResponse(\n                    `## KI AutoAgent Help\\n\\n` +\n                    `**Modes:**\\n` +\n                    `- **Auto**: Automatically routes to the best agent\\n` +\n                    `- **Single**: Direct chat with selected agent\\n` +\n                    `- **Workflow**: Multi-agent collaboration\\n\\n` +\n                    `**Commands:**\\n` +\n                    `- Type your question and press Enter\\n` +\n                    `- Use Shift+Enter for multiline input\\n` +\n                    `- Select agents from dropdown\\n`,\n                    'system'\n                );\n                break;\n            case 'examples':\n                this._addAgentResponse(\n                    `## Example Prompts\\n\\n` +\n                    `**Architecture:**\\n` +\n                    `\"Design a microservices architecture for an e-commerce platform\"\\n\\n` +\n                    `**Coding:**\\n` +\n                    `\"Implement a REST API with FastAPI and PostgreSQL\"\\n\\n` +\n                    `**Trading:**\\n` +\n                    `\"Create a momentum trading strategy with risk management\"\\n\\n` +\n                    `**Research:**\\n` +\n                    `\"Find the latest best practices for React performance optimization\"\\n`,\n                    'system'\n                );\n                break;\n            case 'agents':\n                this._addAgentResponse(\n                    `## Available Agents\\n\\n` +\n                    `🤖 **Orchestrator**: Automatic task routing\\n` +\n                    `🏗️ **ArchitectGPT**: System design and architecture\\n` +\n                    `💻 **CodeSmithClaude**: Code implementation\\n` +\n                    `📈 **TradeStrat**: Trading strategies\\n` +\n                    `🔍 **ResearchBot**: Web research\\n` +\n                    `⚖️ **OpusRichter**: Quality judgment\\n` +\n                    `📝 **DocuBot**: Documentation\\n` +\n                    `👁️ **ReviewerGPT**: Code review\\n` +\n                    `🔧 **FixerBot**: Bug fixing\\n`,\n                    'system'\n                );\n                break;\n        }\n    }\n\n    private async _handlePlanFirst(text: string, agent: string, mode: string) {\n        // Add user message with plan request\n        const planPrompt = `PLAN FIRST: ${text}\\n\\nPlease provide a detailed plan before implementing. Break down the task into clear steps.`;\n        \n        const userMessage: ChatMessage = {\n            role: 'user',\n            content: planPrompt,\n            timestamp: new Date().toISOString()\n        };\n        this._messages.push(userMessage);\n        \n        this._panel.webview.postMessage({\n            type: 'addMessage',\n            message: userMessage\n        });\n        \n        // Save to conversation history\n        this._contextManager.addEntry({\n            timestamp: new Date().toISOString(),\n            agent: 'user',\n            step: 'plan_request',\n            input: planPrompt,\n            output: '',\n            metadata: { mode, selectedAgent: agent, isPlanFirst: true }\n        });\n        \n        // Process with agent\n        this._panel.webview.postMessage({\n            type: 'showTyping',\n            agent: agent\n        });\n        \n        try {\n            // Force single agent mode for planning\n            const streamingMessageId = `streaming-${Date.now()}`;\n            this._addStreamingMessage(streamingMessageId, agent);\n            \n            const response = await this._callAgentWithStreaming(agent === 'auto' ? 'codesmith' : agent, planPrompt, streamingMessageId);\n            \n            this._finalizeStreamingMessage(streamingMessageId, response.content, response.metadata);\n        } catch (error) {\n            console.error('[PLAN FIRST] Error:', error);\n            this._addErrorMessage(`Error: ${(error as any).message}`);\n        } finally {\n            this._panel.webview.postMessage({\n                type: 'hideTyping'\n            });\n        }\n    }\n\n    public addMessage(message: ChatMessage) {\n        this._messages.push(message);\n        this._panel.webview.postMessage({\n            type: 'addMessage',\n            message: message\n        });\n    }\n\n    public dispose() {\n        MultiAgentChatPanel.currentPanel = undefined;\n        this._panel.dispose();\n        while (this._disposables.length) {\n            const x = this._disposables.pop();\n            if (x) {\n                x.dispose();\n            }\n        }\n    }\n}\n\nfunction getNonce() {\n    let text = '';\n    const possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n    for (let i = 0; i < 32; i++) {\n        text += possible.charAt(Math.floor(Math.random() * possible.length));\n    }\n    return text;\n}","/**\n * Base Chat Agent class for VS Code Chat Extensions\n * All specialized agents inherit from this base class\n */\nimport * as vscode from 'vscode';\nimport { AgentConfig, TaskRequest, TaskResult, WorkflowStep, AIModel } from '../../types';\nimport { VSCodeMasterDispatcher } from '../../core/VSCodeMasterDispatcher';\nimport { UnifiedChatMixin, ResponseType } from '../../mixins/UnifiedChatMixin';\nimport { AgentRegistry } from '../../core/AgentRegistry';\n\nexport abstract class ChatAgent extends UnifiedChatMixin {\n    protected context: vscode.ExtensionContext;\n    protected dispatcher: VSCodeMasterDispatcher;\n    protected stats = {\n        totalExecutions: 0,\n        successCount: 0,\n        totalResponseTime: 0,\n        lastExecution: undefined as Date | undefined\n    };\n    \n    // Properties for UnifiedChatMixin compatibility\n    public name: string;\n    public role: string;\n    public model: string;\n\n    constructor(\n        protected config: AgentConfig,\n        context: vscode.ExtensionContext,\n        dispatcher: VSCodeMasterDispatcher\n    ) {\n        super(); // Initialize UnifiedChatMixin\n        \n        this.context = context;\n        this.dispatcher = dispatcher;\n        \n        // Set properties for UnifiedChatMixin\n        this.name = config.fullName || config.name;\n        this.role = config.description;\n        this.model = config.model;\n    }\n\n    /**\n     * Create VS Code chat request handler\n     */\n    createHandler(): vscode.ChatRequestHandler {\n        return async (\n            request: vscode.ChatRequest,\n            context: vscode.ChatContext,\n            stream: vscode.ChatResponseStream,\n            token: vscode.CancellationToken\n        ) => {\n            const startTime = Date.now();\n            this.stats.totalExecutions++;\n            this.stats.lastExecution = new Date();\n\n            try {\n                // Show agent info\n                stream.progress(`🤖 ${this.config.fullName} is working...`);\n                \n                // Handle the request\n                await this.handleRequest(request, context, stream, token);\n                \n                // Update success stats\n                this.stats.successCount++;\n                this.stats.totalResponseTime += Date.now() - startTime;\n\n            } catch (error) {\n                await this.handleError(error as Error, stream);\n                this.stats.totalResponseTime += Date.now() - startTime;\n            }\n        };\n    }\n\n    /**\n     * Main request handler - to be implemented by each agent\n     */\n    protected abstract handleRequest(\n        request: vscode.ChatRequest,\n        context: vscode.ChatContext,\n        stream: vscode.ChatResponseStream,\n        token: vscode.CancellationToken\n    ): Promise<void>;\n\n    /**\n     * Execute a workflow step (called by dispatcher)\n     */\n    async executeStep(\n        step: WorkflowStep,\n        request: TaskRequest,\n        previousResults: TaskResult[]\n    ): Promise<TaskResult> {\n        try {\n            return await this.processWorkflowStep(step, request, previousResults);\n        } catch (error) {\n            return {\n                status: 'error',\n                content: `Error executing ${step.description}: ${(error as any).message}`,\n                metadata: { error: (error as any).message, step: step.id }\n            };\n        }\n    }\n\n    /**\n     * Process a workflow step - to be implemented by each agent\n     */\n    protected abstract processWorkflowStep(\n        step: WorkflowStep,\n        request: TaskRequest,\n        previousResults: TaskResult[]\n    ): Promise<TaskResult>;\n\n    /**\n     * Handle command-specific logic\n     */\n    protected async handleCommand(\n        command: string,\n        prompt: string,\n        stream: vscode.ChatResponseStream,\n        token: vscode.CancellationToken\n    ): Promise<void> {\n        const commandHandler = this.config.commands.find(cmd => cmd.name === command);\n        \n        if (commandHandler) {\n            const methodName = commandHandler.handler;\n            if (typeof (this as any)[methodName] === 'function') {\n                await (this as any)[methodName](prompt, stream, token);\n            } else {\n                stream.markdown(`❌ Command handler '${methodName}' not implemented for ${command}`);\n            }\n        } else {\n            stream.markdown(`❌ Unknown command: /${command}`);\n            await this.showAvailableCommands(stream);\n        }\n    }\n\n    /**\n     * Show available commands for this agent\n     */\n    protected async showAvailableCommands(stream: vscode.ChatResponseStream): Promise<void> {\n        stream.markdown(`## Available Commands for ${this.config.fullName}\\n\\n`);\n        \n        for (const cmd of this.config.commands) {\n            stream.markdown(`- **/${cmd.name}** - ${cmd.description}\\n`);\n        }\n        \n        stream.markdown(`\\n💡 Use \\`@${this.config.name} /<command> <your request>\\``);\n    }\n\n    /**\n     * Get workspace context for AI models\n     */\n    protected async getWorkspaceContext(): Promise<string> {\n        const workspaceContext = await this.dispatcher.getWorkspaceContext();\n\n        let contextString = '';\n\n        if (workspaceContext.currentFile) {\n            contextString += `Current file: ${workspaceContext.currentFile}\\n`;\n        }\n\n        if (workspaceContext.selectedText) {\n            contextString += `Selected text:\\n\\`\\`\\`\\n${workspaceContext.selectedText}\\n\\`\\`\\`\\n`;\n        }\n\n        if (workspaceContext.workspaceRoots && workspaceContext.workspaceRoots.length > 0) {\n            contextString += `Workspace: ${workspaceContext.workspaceRoots[0].name}\\n`;\n        }\n\n        // Add task delegation context\n        contextString += `\\n\\n${this.getTaskDelegationContext()}`;\n\n        return contextString;\n    }\n\n    /**\n     * Get task delegation context for this agent\n     */\n    protected getTaskDelegationContext(): string {\n        const registry = AgentRegistry.getInstance();\n        const agentId = this.config.name.toLowerCase().replace('agent', '');\n        return registry.getTaskDelegationInfo(agentId);\n    }\n\n    /**\n     * Check if a task should be delegated to another agent\n     */\n    protected async checkForTaskDelegation(prompt: string): Promise<string | null> {\n        const registry = AgentRegistry.getInstance();\n        const currentAgentId = this.config.name.toLowerCase().replace('agent', '');\n        const suggestedAgent = registry.suggestAgentForTask(prompt);\n\n        if (suggestedAgent && suggestedAgent !== currentAgentId) {\n            const agentInfo = registry.getAgentInfo(suggestedAgent);\n            if (agentInfo) {\n                return `💡 This task might be better suited for **@${suggestedAgent}** who specializes in ${agentInfo.specialization}.\\n\\nWould you like me to:\\n1. Continue with my analysis\\n2. Suggest forwarding to @${suggestedAgent}\\n\\nOr you can directly ask @${suggestedAgent} for help.`;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Get system context prompt with agent awareness\n     */\n    protected getSystemContextPrompt(): string {\n        const registry = AgentRegistry.getInstance();\n        return `\n## Available Agents in KI_AutoAgent System:\n${registry.getAgentListDescription()}\n\nYou are ${this.config.fullName} with role: ${this.config.description}\n${this.getTaskDelegationContext()}\n`;\n    }\n\n    /**\n     * Render code in the chat with syntax highlighting\n     */\n    protected renderCode(\n        code: string,\n        language: string,\n        stream: vscode.ChatResponseStream,\n        title?: string\n    ): void {\n        if (title) {\n            stream.markdown(`### ${title}\\n\\n`);\n        }\n        stream.markdown(`\\`\\`\\`${language}\\n${code}\\n\\`\\`\\`\\n\\n`);\n    }\n\n    /**\n     * Create action buttons for the user\n     */\n    protected createActionButton(\n        title: string,\n        command: string,\n        args: any[],\n        stream: vscode.ChatResponseStream\n    ): void {\n        stream.button({\n            command,\n            title,\n            arguments: args\n        });\n    }\n\n    /**\n     * Add file reference to chat\n     */\n    protected addFileReference(\n        filePath: string,\n        stream: vscode.ChatResponseStream\n    ): void {\n        try {\n            const uri = vscode.Uri.file(filePath);\n            stream.reference(uri);\n        } catch (error) {\n            console.log(this.showError('Error adding file reference', error));\n        }\n    }\n\n    /**\n     * Error handler\n     */\n    protected async handleError(error: Error, stream: vscode.ChatResponseStream): Promise<void> {\n        console.log(this.showError(`Error in ${this.config.fullName}`, error));\n        \n        stream.markdown(`❌ **Error**: ${(error as any).message}\\n\\n`);\n        stream.markdown(`💡 **Suggestions:**\\n`);\n        stream.markdown(`- Check your API keys in settings\\n`);\n        stream.markdown(`- Verify your internet connection\\n`);\n        stream.markdown(`- Try rephrasing your request\\n`);\n        \n        // Offer to show help\n        this.createActionButton(\n            'Show Help',\n            'ki-autoagent.showHelp',\n            [this.config.participantId],\n            stream\n        );\n    }\n\n    /**\n     * Get agent statistics\n     */\n    getStats() {\n        return {\n            ...this.stats,\n            successRate: this.stats.totalExecutions > 0 \n                ? this.stats.successCount / this.stats.totalExecutions \n                : 0,\n            averageResponseTime: this.stats.totalExecutions > 0\n                ? this.stats.totalResponseTime / this.stats.totalExecutions\n                : 0\n        };\n    }\n\n    /**\n     * Get AI model configuration\n     */\n    protected getModelConfig(): { model: AIModel; apiKey?: string } {\n        const config = vscode.workspace.getConfiguration('kiAutoAgent');\n        \n        let model: AIModel = this.config.model as AIModel;\n        let apiKey: string | undefined;\n        \n        switch (model) {\n            case 'gpt-4o':\n            case 'gpt-4o-mini':\n                apiKey = config.get<string>('openai.apiKey');\n                break;\n            case 'claude-3.5-sonnet':\n                apiKey = config.get<string>('anthropic.apiKey');\n                break;\n            case 'perplexity-pro':\n                apiKey = config.get<string>('perplexity.apiKey');\n                break;\n        }\n        \n        return { model, apiKey };\n    }\n\n    /**\n     * Validate API configuration\n     */\n    protected validateApiConfig(): boolean {\n        const { apiKey } = this.getModelConfig();\n        return !!apiKey;\n    }\n\n    /**\n     * Get max tokens from configuration\n     */\n    protected getMaxTokens(): number {\n        const config = vscode.workspace.getConfiguration('kiAutoAgent');\n        return config.get<number>('maxTokens', 4000);\n    }\n\n    /**\n     * Check if logging is enabled\n     */\n    protected isLoggingEnabled(): boolean {\n        const config = vscode.workspace.getConfiguration('kiAutoAgent');\n        return config.get<boolean>('enableLogging', true);\n    }\n\n    /**\n     * Log message if logging is enabled\n     */\n    protected log(message: string, level: 'info' | 'warn' | 'error' = 'info'): void {\n        if (this.isLoggingEnabled()) {\n            const timestamp = new Date().toISOString();\n            console[level](`[${timestamp}] ${this.config.fullName}: ${message}`);\n        }\n    }\n}","/**\n * Manages conversation context and history across multiple agent interactions\n * Ensures that agents can access and build upon previous outputs\n */\n\nexport interface ConversationEntry {\n    timestamp: string;\n    agent: string;\n    step: string;\n    input: string;\n    output: string;\n    metadata?: any;\n}\n\nexport class ConversationContextManager {\n    private static instance: ConversationContextManager;\n    private conversationHistory: ConversationEntry[] = [];\n    private maxHistorySize: number = 50; // Keep last 50 interactions\n    \n    private constructor() {}\n    \n    public static getInstance(): ConversationContextManager {\n        if (!ConversationContextManager.instance) {\n            ConversationContextManager.instance = new ConversationContextManager();\n        }\n        return ConversationContextManager.instance;\n    }\n    \n    /**\n     * Add a new entry to the conversation history\n     */\n    public addEntry(entry: ConversationEntry): void {\n        this.conversationHistory.push(entry);\n        \n        // Trim history if it exceeds max size\n        if (this.conversationHistory.length > this.maxHistorySize) {\n            this.conversationHistory = this.conversationHistory.slice(-this.maxHistorySize);\n        }\n        \n        console.log(`[CONTEXT-MANAGER] Added entry from ${entry.agent} (${entry.step})`);\n        console.log(`[CONTEXT-MANAGER] Total history size: ${this.conversationHistory.length} entries`);\n    }\n    \n    /**\n     * Get recent conversation history\n     */\n    public getRecentHistory(limit: number = 5): ConversationEntry[] {\n        return this.conversationHistory.slice(-limit);\n    }\n    \n    /**\n     * Get conversation history for a specific agent\n     */\n    public getAgentHistory(agentName: string, limit: number = 5): ConversationEntry[] {\n        return this.conversationHistory\n            .filter(entry => entry.agent === agentName)\n            .slice(-limit);\n    }\n    \n    /**\n     * Get formatted conversation context for inclusion in prompts\n     */\n    public getFormattedContext(limit: number = 5): string {\n        const recent = this.getRecentHistory(limit);\n        if (recent.length === 0) {\n            return '';\n        }\n        \n        let context = '\\n## Conversation History:\\n';\n        recent.forEach(entry => {\n            context += `\\n### ${entry.agent} (${entry.step}) - ${entry.timestamp}:\\n`;\n            context += `**Input:** ${entry.input.substring(0, 200)}...\\n`;\n            context += `**Output:** ${entry.output.substring(0, 500)}...\\n`;\n        });\n        \n        return context;\n    }\n    \n    /**\n     * Get the last output from any agent\n     */\n    public getLastOutput(): string | null {\n        if (this.conversationHistory.length === 0) {\n            return null;\n        }\n        return this.conversationHistory[this.conversationHistory.length - 1].output;\n    }\n    \n    /**\n     * Clear conversation history\n     */\n    public clearHistory(): void {\n        this.conversationHistory = [];\n        console.log(`[CONTEXT-MANAGER] Conversation history cleared`);\n    }\n    \n    /**\n     * Export conversation history as JSON\n     */\n    public exportHistory(): string {\n        return JSON.stringify(this.conversationHistory, null, 2);\n    }\n    \n    /**\n     * Import conversation history from JSON\n     */\n    public importHistory(jsonData: string): void {\n        try {\n            const imported = JSON.parse(jsonData);\n            if (Array.isArray(imported)) {\n                this.conversationHistory = imported;\n                console.log(`[CONTEXT-MANAGER] Imported ${imported.length} conversation entries`);\n            }\n        } catch (error) {\n            console.error(`[CONTEXT-MANAGER] Failed to import history: ${error}`);\n        }\n    }\n}","module.exports = require(\"path\");","/**\n * TradeStrat - Trading Strategy Expert\n * Powered by Claude 3.5 Sonnet for trading strategy development and analysis\n */\nimport * as vscode from 'vscode';\nimport { ChatAgent } from './base/ChatAgent';\nimport { AgentConfig, TaskRequest, TaskResult, WorkflowStep } from '../types';\nimport { VSCodeMasterDispatcher } from '../core/VSCodeMasterDispatcher';\nimport { AnthropicService } from '../utils/AnthropicService';\nimport { getClaudeCodeService, ClaudeCodeService } from '../services/ClaudeCodeService';\n\nexport class TradeStratAgent extends ChatAgent {\n    private anthropicService: AnthropicService;\n    private claudeCodeService: ClaudeCodeService;\n\n    constructor(context: vscode.ExtensionContext, dispatcher: VSCodeMasterDispatcher) {\n        const config: AgentConfig = {\n            participantId: 'ki-autoagent.tradestrat',\n            name: 'tradestrat',\n            fullName: 'TradeStrat',\n            description: 'Trading Strategy Expert powered by Claude 4.1 Sonnet',\n            model: 'claude-4.1-sonnet-20250920',\n            iconPath: vscode.Uri.joinPath(context.extensionUri, 'media', 'trading-icon.svg'),\n            capabilities: [\n                'Trading Strategy Development',\n                'RON Strategy Implementation',\n                'Backtesting Frameworks',\n                'Risk Management',\n                'Portfolio Optimization',\n                'Market Analysis'\n            ],\n            commands: [\n                { name: 'strategy', description: 'Develop and implement trading strategies', handler: 'handleStrategyCommand' },\n                { name: 'backtest', description: 'Create backtesting and validation systems', handler: 'handleBacktestCommand' },\n                { name: 'risk', description: 'Implement risk management and portfolio optimization', handler: 'handleRiskCommand' }\n            ]\n        };\n\n        super(config, context, dispatcher);\n        this.anthropicService = new AnthropicService();\n        this.claudeCodeService = getClaudeCodeService();\n    }\n\n    protected async handleRequest(\n        request: vscode.ChatRequest,\n        context: vscode.ChatContext,\n        stream: vscode.ChatResponseStream,\n        token: vscode.CancellationToken\n    ): Promise<void> {\n        \n        const validationResult = await this.validateServiceConfig(stream);\n        if (!validationResult) {\n            return;\n        }\n\n        const command = request.command;\n        const prompt = request.prompt;\n\n        this.log(`Processing ${command ? `/${command}` : 'general'} trading request: ${prompt.substring(0, 100)}...`);\n\n        if (command) {\n            await this.handleCommand(command, prompt, stream, token);\n        } else {\n            await this.handleGeneralTradingRequest(prompt, stream, token);\n        }\n    }\n\n    protected async processWorkflowStep(\n        step: WorkflowStep,\n        request: TaskRequest,\n        previousResults: TaskResult[]\n    ): Promise<TaskResult> {\n        \n        const context = await this.getWorkspaceContext();\n        \n        let systemPrompt = '';\n        let userPrompt = '';\n\n        switch (step.id) {\n            case 'strategy_design':\n                systemPrompt = this.getStrategyDesignSystemPrompt();\n                userPrompt = `Design a trading strategy for: ${request.prompt}\\n\\nWorkspace Context:\\n${context}`;\n                break;\n                \n            case 'backtest':\n                systemPrompt = this.getBacktestSystemPrompt();\n                userPrompt = `Create backtesting framework for: ${request.prompt}\\n\\nStrategy Design:\\n${this.extractPreviousContent(previousResults)}`;\n                break;\n                \n            case 'risk_analysis':\n                systemPrompt = this.getRiskAnalysisSystemPrompt();\n                userPrompt = `Analyze risk management for: ${request.prompt}\\n\\nContext:\\n${context}`;\n                break;\n                \n            case 'strategy_validation':\n                systemPrompt = this.getValidationSystemPrompt();\n                userPrompt = `Validate trading strategy: ${request.prompt}\\n\\nImplementation:\\n${this.extractPreviousContent(previousResults)}`;\n                break;\n                \n            default:\n                systemPrompt = this.getGeneralSystemPrompt();\n                userPrompt = `${request.prompt}\\n\\nContext:\\n${context}`;\n        }\n\n        try {\n            const claudeService = await this.getClaudeService();\n            const response = await claudeService.chat([\n                { role: 'system', content: systemPrompt },\n                { role: 'user', content: userPrompt }\n            ]);\n\n            return {\n                status: 'success',\n                content: response,\n                metadata: { \n                    step: step.id,\n                    agent: 'tradestrat',\n                    model: 'claude-3.5-sonnet'\n                }\n            };\n\n        } catch (error) {\n            throw new Error(`Failed to process ${step.id}: ${(error as any).message}`);\n        }\n    }\n\n    // Command Handlers\n\n    private async handleStrategyCommand(\n        prompt: string,\n        stream: vscode.ChatResponseStream,\n        token: vscode.CancellationToken\n    ): Promise<void> {\n        \n        stream.progress('📈 Developing trading strategy...');\n        \n        const context = await this.getWorkspaceContext();\n        const systemPrompt = this.getStrategyDesignSystemPrompt();\n        const userPrompt = `Develop a comprehensive trading strategy for: ${prompt}\\n\\nWorkspace Context:\\n${context}`;\n\n        try {\n            const claudeService = await this.getClaudeService();\n            const response = await claudeService.chat([\n                { role: 'system', content: systemPrompt },\n                { role: 'user', content: userPrompt }\n            ]);\n\n            stream.markdown(response);\n\n            // Extract strategy components for implementation\n            const pythonCode = this.extractPythonCode(response);\n            if (pythonCode) {\n                this.createActionButton(\n                    '⚡ Implement Strategy',\n                    'ki-autoagent.createFile',\n                    ['strategy.py', pythonCode],\n                    stream\n                );\n            }\n\n            // Offer backtesting\n            this.createActionButton(\n                '🧪 Create Backtest',\n                'ki-autoagent.createBacktest',\n                [prompt, response],\n                stream\n            );\n\n            // Offer risk analysis\n            this.createActionButton(\n                '⚠️ Analyze Risks',\n                'ki-autoagent.analyzeRisks',\n                [prompt, response],\n                stream\n            );\n\n        } catch (error) {\n            stream.markdown(`❌ Error developing strategy: ${(error as any).message}`);\n        }\n    }\n\n    private async handleBacktestCommand(\n        prompt: string,\n        stream: vscode.ChatResponseStream,\n        token: vscode.CancellationToken\n    ): Promise<void> {\n        \n        stream.progress('🧪 Creating backtesting framework...');\n        \n        const context = await this.getWorkspaceContext();\n        const systemPrompt = this.getBacktestSystemPrompt();\n        const userPrompt = `Create a comprehensive backtesting framework for: ${prompt}\\n\\nWorkspace Context:\\n${context}`;\n\n        try {\n            const claudeService = await this.getClaudeService();\n            const response = await claudeService.chat([\n                { role: 'system', content: systemPrompt },\n                { role: 'user', content: userPrompt }\n            ]);\n\n            stream.markdown(response);\n\n            // Extract backtesting code\n            const backtestCode = this.extractPythonCode(response);\n            if (backtestCode) {\n                this.createActionButton(\n                    '📊 Create Backtest Framework',\n                    'ki-autoagent.createFile',\n                    ['backtest_engine.py', backtestCode],\n                    stream\n                );\n            }\n\n            // Offer to create test data\n            this.createActionButton(\n                '📈 Generate Test Data',\n                'ki-autoagent.generateTestData',\n                [prompt],\n                stream\n            );\n\n        } catch (error) {\n            stream.markdown(`❌ Error creating backtesting framework: ${(error as any).message}`);\n        }\n    }\n\n    private async handleRiskCommand(\n        prompt: string,\n        stream: vscode.ChatResponseStream,\n        token: vscode.CancellationToken\n    ): Promise<void> {\n        \n        stream.progress('⚠️ Implementing risk management...');\n        \n        const context = await this.getWorkspaceContext();\n        const systemPrompt = this.getRiskManagementSystemPrompt();\n        const userPrompt = `Implement comprehensive risk management for: ${prompt}\\n\\nWorkspace Context:\\n${context}`;\n\n        try {\n            const claudeService = await this.getClaudeService();\n            const response = await claudeService.chat([\n                { role: 'system', content: systemPrompt },\n                { role: 'user', content: userPrompt }\n            ]);\n\n            stream.markdown(response);\n\n            // Extract risk management code\n            const riskCode = this.extractPythonCode(response);\n            if (riskCode) {\n                this.createActionButton(\n                    '🛡️ Implement Risk Management',\n                    'ki-autoagent.createFile',\n                    ['risk_manager.py', riskCode],\n                    stream\n                );\n            }\n\n            // Offer portfolio optimization\n            this.createActionButton(\n                '📊 Optimize Portfolio',\n                'ki-autoagent.optimizePortfolio',\n                [prompt, response],\n                stream\n            );\n\n        } catch (error) {\n            stream.markdown(`❌ Error implementing risk management: ${(error as any).message}`);\n        }\n    }\n\n    private async handleGeneralTradingRequest(\n        prompt: string,\n        stream: vscode.ChatResponseStream,\n        token: vscode.CancellationToken\n    ): Promise<void> {\n        \n        stream.progress('💹 Processing trading request...');\n        \n        const context = await this.getWorkspaceContext();\n        const systemPrompt = this.getGeneralSystemPrompt();\n        const userPrompt = `${prompt}\\n\\nWorkspace Context:\\n${context}`;\n\n        try {\n            const claudeService = await this.getClaudeService();\n            const response = await claudeService.chat([\n                { role: 'system', content: systemPrompt },\n                { role: 'user', content: userPrompt }\n            ]);\n\n            stream.markdown(response);\n\n            // Detect if this is RON strategy related\n            if (prompt.toLowerCase().includes('ron') || response.toLowerCase().includes('ron strategy')) {\n                this.createActionButton(\n                    '🎯 Implement RON Strategy',\n                    'ki-autoagent.implementRON',\n                    [response],\n                    stream\n                );\n            }\n\n            // Auto-detect code for implementation\n            const tradingCode = this.extractPythonCode(response);\n            if (tradingCode) {\n                this.createActionButton(\n                    '⚡ Implement Code',\n                    'ki-autoagent.createFile',\n                    ['trading_implementation.py', tradingCode],\n                    stream\n                );\n            }\n\n        } catch (error) {\n            stream.markdown(`❌ Error processing trading request: ${(error as any).message}`);\n        }\n    }\n\n    // System Prompts\n\n    private getGeneralSystemPrompt(): string {\n        return `You are TradeStrat, an expert trading strategy developer and quantitative analyst. You specialize in:\n\n- Trading strategy design and implementation\n- Algorithmic trading systems\n- Risk management and portfolio optimization\n- Backtesting and performance analysis\n- Market microstructure and execution\n- RON (Reversal of Numbers) strategy implementation\n- Python-based trading systems (pandas, numpy, streamlit, yfinance)\n\nKey principles:\n1. Always prioritize risk management\n2. Implement robust backtesting before live trading\n3. Focus on statistical significance and edge detection\n4. Consider market conditions and regime changes\n5. Provide clear performance metrics and validation\n\nFormat your responses with detailed explanations, working code, and practical implementation guidance.\n\n${this.getSystemContextPrompt()}`;\n    }\n\n    private getStrategyDesignSystemPrompt(): string {\n        return `You are TradeStrat designing a comprehensive trading strategy. Structure your response as:\n\n## Trading Strategy Design\n\n### 1. Strategy Overview\n- Strategy name and concept\n- Market conditions and timeframes\n- Expected holding periods\n- Target assets/markets\n\n### 2. Entry Rules\n- Precise entry conditions\n- Technical indicators required\n- Fundamental filters (if any)\n- Signal confirmation methods\n\n### 3. Exit Rules\n- Profit-taking strategies\n- Stop-loss implementation\n- Time-based exits\n- Market condition exits\n\n### 4. Risk Management\n- Position sizing methodology\n- Maximum drawdown limits\n- Correlation and diversification\n- Portfolio-level risk controls\n\n### 5. Implementation Details\n- Required data sources\n- Calculation methodology\n- Code structure and modules\n- Performance monitoring\n\n### 6. Backtesting Framework\n- Historical data requirements\n- Performance metrics to track\n- Stress testing scenarios\n- Out-of-sample validation\n\nProvide complete Python implementation with pandas/numpy for data handling.\n\n${this.getSystemContextPrompt()}`;\n    }\n\n    private getBacktestSystemPrompt(): string {\n        return `You are TradeStrat creating a robust backtesting framework. Include:\n\n## Backtesting Framework Design\n\n### 1. Data Management\n- Historical data ingestion\n- Data cleaning and validation\n- Corporate actions handling\n- Survivorship bias considerations\n\n### 2. Signal Generation\n- Strategy logic implementation\n- Signal timing and execution\n- Lookahead bias prevention\n- Realistic latency modeling\n\n### 3. Execution Simulation\n- Order execution modeling\n- Slippage and transaction costs\n- Market impact considerations\n- Partial fill handling\n\n### 4. Performance Metrics\n- Return calculations\n- Risk-adjusted metrics (Sharpe, Sortino)\n- Drawdown analysis\n- Trade-level statistics\n\n### 5. Visualization and Reporting\n- Equity curve plotting\n- Trade analysis charts\n- Performance attribution\n- Stress test results\n\n### 6. Validation Techniques\n- Out-of-sample testing\n- Walk-forward analysis\n- Monte Carlo simulation\n- Bootstrap analysis\n\nProvide production-ready Python code with proper error handling and logging.\n\n${this.getSystemContextPrompt()}`;\n    }\n\n    private getRiskManagementSystemPrompt(): string {\n        return `You are TradeStrat implementing comprehensive risk management. Cover:\n\n## Risk Management Framework\n\n### 1. Position Sizing\n- Kelly criterion implementation\n- Volatility-based sizing\n- Maximum position limits\n- Correlation adjustments\n\n### 2. Portfolio Risk Controls\n- Value-at-Risk (VaR) calculation\n- Expected Shortfall (ES)\n- Maximum drawdown limits\n- Sector/asset concentration limits\n\n### 3. Dynamic Risk Adjustment\n- Volatility regime detection\n- Risk scaling mechanisms\n- Market stress indicators\n- Emergency stop procedures\n\n### 4. Monitoring and Alerts\n- Real-time risk metrics\n- Breach notifications\n- Performance tracking\n- Risk attribution analysis\n\n### 5. Stress Testing\n- Historical scenario analysis\n- Monte Carlo stress tests\n- Tail risk evaluation\n- Correlation breakdown scenarios\n\n### 6. Implementation Tools\n- Risk calculation engines\n- Alert systems\n- Reporting dashboards\n- Integration with trading systems\n\nFocus on practical, implementable solutions with clear mathematical foundations.\n\n${this.getSystemContextPrompt()}`;\n    }\n\n    private getValidationSystemPrompt(): string {\n        return `You are TradeStrat validating trading strategies for production readiness. Analyze:\n\n## Strategy Validation Checklist\n\n### 1. Statistical Validation\n- Statistical significance of returns\n- Consistency across time periods\n- Performance in different market regimes\n- Correlation with market factors\n\n### 2. Implementation Validation\n- Code correctness and efficiency\n- Data quality and completeness\n- Signal generation accuracy\n- Execution logic verification\n\n### 3. Risk Validation\n- Maximum drawdown analysis\n- Tail risk assessment\n- Stress test results\n- Portfolio-level impact\n\n### 4. Operational Validation\n- System reliability and uptime\n- Error handling and recovery\n- Monitoring and alerting\n- Compliance requirements\n\n### 5. Performance Validation\n- Live vs backtest performance\n- Transaction cost impact\n- Capacity constraints\n- Scalability considerations\n\nProvide detailed assessment with specific recommendations for improvement.\n\n${this.getSystemContextPrompt()}`;\n    }\n\n    private getRiskAnalysisSystemPrompt(): string {\n        return this.getRiskManagementSystemPrompt();\n    }\n\n    // Service Configuration Methods\n\n    private async validateServiceConfig(stream?: vscode.ChatResponseStream): Promise<boolean> {\n        const config = vscode.workspace.getConfiguration('kiAutoAgent');\n        const serviceMode = config.get<string>('claude.serviceMode', 'claude-code');\n\n        if (serviceMode === 'api') {\n            if (!config.get<string>('anthropic.apiKey')) {\n                if (stream) {\n                    stream.markdown('❌ **Anthropic API key not configured**\\n\\nPlease set your API key in VS Code settings:\\n- Go to Settings\\n- Search for \"KI AutoAgent\"\\n- Set your Anthropic API key');\n                }\n                return false;\n            }\n        } else if (serviceMode === 'claude-code') {\n            const isClaudeCodeAvailable = await this.claudeCodeService.isAvailable();\n            if (!isClaudeCodeAvailable) {\n                if (stream) {\n                    stream.markdown(`❌ **Claude Code CLI not available**\\n\\n**To install:**\\n\\`\\`\\`bash\\nnpm install -g @anthropic-ai/claude-code\\n\\`\\`\\`\\n\\nOr configure your Anthropic API key in VS Code settings.`);\n                }\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    private async getClaudeService(): Promise<{ chat: (messages: any[]) => Promise<string> }> {\n        const config = vscode.workspace.getConfiguration('kiAutoAgent');\n        const serviceMode = config.get<string>('claude.serviceMode', 'claude-code');\n\n        console.log(`[TradeStratAgent] Using service mode: ${serviceMode}`);\n\n        if (serviceMode === 'claude-code') {\n            const isAvailable = await this.claudeCodeService.isAvailable();\n            if (isAvailable) {\n                console.log('[TradeStratAgent] Using Claude Code CLI');\n                return {\n                    chat: async (messages: any[]) => {\n                        // Extract the main user message content\n                        const userMessage = messages.find(m => m.role === 'user')?.content || '';\n                        const systemMessage = messages.find(m => m.role === 'system')?.content || '';\n                        const fullPrompt = systemMessage ? `${systemMessage}\\n\\n${userMessage}` : userMessage;\n                        \n                        const response = await this.claudeCodeService.sendMessage(fullPrompt, {\n                            model: 'sonnet',\n                            temperature: 0.7\n                        });\n                        return response.content;\n                    }\n                };\n            } else {\n                console.log('[TradeStratAgent] Claude Code CLI not available, falling back to Anthropic API');\n            }\n        }\n        \n        // Fall back to Anthropic API\n        console.log('[TradeStratAgent] Using Anthropic API');\n        return {\n            chat: async (messages: any[]) => {\n                return await this.anthropicService.chat(messages);\n            }\n        };\n    }\n\n    // Helper Methods\n\n    private extractPythonCode(content: string): string {\n        const pythonBlockRegex = /```python\\n([\\s\\S]*?)```/g;\n        const match = pythonBlockRegex.exec(content);\n        return match ? match[1] : '';\n    }\n\n    private extractPreviousContent(previousResults: TaskResult[]): string {\n        return previousResults\n            .map(result => result.content)\n            .join('\\n\\n---\\n\\n')\n            .substring(0, 2000); // Limit context size\n    }\n}","module.exports = require(\"fs/promises\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(265);\n"],"names":["ArchitectAgent","ChatAgent","constructor","context","dispatcher","super","participantId","name","fullName","description","model","iconPath","vscode","Uri","joinPath","extensionUri","capabilities","commands","handler","this","openAIService","OpenAIService","handleRequest","request","stream","token","validateApiConfig","markdown","command","prompt","log","substring","handleCommand","handleGeneralArchitectureRequest","processWorkflowStep","step","previousResults","getWorkspaceContext","systemPrompt","userPrompt","id","getAnalyzeSystemPrompt","getDesignSystemPrompt","extractPreviousContent","getGeneralSystemPrompt","status","content","chat","role","metadata","agent","error","Error","message","handleDesignCommand","progress","response","createActionButton","handleAnalyzeCommand","workspaceFiles","getProjectStructure","handlePlanCommand","getPlanSystemPrompt","getSystemContextPrompt","workspace","findFiles","map","file","fsPath","split","slice","join","result","options","memories","Map","embeddings","patterns","clusters","codePatterns","architecturePatterns","learningEntries","memoryIndex","agentMemories","maxMemories","similarityThreshold","clusteringEnabled","patternExtractionEnabled","autoForget","forgetThreshold","eventBus","EventEmitter","initializeIndexes","Object","values","MemoryType","forEach","type","set","Set","store","agentId","generateMemoryId","embedding","generateEmbedding","memory","timestamp","Date","now","accessCount","lastAccessed","importance","calculateImportance","get","add","has","size","forgetOldMemories","extractPatterns","updateClusters","emit","search","query","k","minSimilarity","queryEmbedding","candidateMemories","Array","from","typeMemories","filter","m","agentMems","results","similarity","cosineSimilarity","relevance","calculateRelevance","entry","sort","a","b","update","delete","storeCodePattern","pattern","getRelevantCodePatterns","language","relevant","p","scoreA","successRate","lastUsed","storeArchitecturePattern","getRelevantArchitecturePatterns","useCase","useCases","some","uc","toLowerCase","includes","storeLearning","learning","push","getRelevantLearnings","limit","keywords","keyword","impact","groupSimilarMemories","group","length","patternEntry","frequency","examples","extractedAt","groups","processed","similar","findSimilarMemories","extractPatternSignature","s","threshold","other","Math","min","floor","centroids","initializeCentroids","iterations","changed","newClusters","centroid","members","coherence","nearestIdx","maxSim","idx","sim","cluster","newCentroid","calculateCentroid","vectorsEqual","calculateClusterCoherence","memoriesToForget","age","maxToForget","text","JSON","stringify","fill","i","charCodeAt","magnitude","sqrt","reduce","sum","val","dotProduct","magnitudeA","magnitudeB","PROCEDURAL","SEMANTIC","EPISODIC","dim","member","totalSimilarity","comparisons","j","every","abs","random","toString","substr","getStats","stats","totalMemories","byType","byAgent","averageAccessCount","mostAccessedMemories","memoryGrowthRate","patternCount","clusterCount","ids","totalAccess","memoriesByAccess","exportData","entries","import","data","importData","parse","clear","rebuildIndexes","count","CodeSmithAgent","anthropicService","AnthropicService","claudeCodeService","getClaudeCodeService","validateServiceConfig","handleGeneralImplementationRequest","executeStep","showDebug","hasStreamingCallback","onPartialResponse","conversationHistory","globalContext","index","agentName","stepId","getImplementationSystemPrompt","getTestingSystemPrompt","getOptimizationSystemPrompt","claudeService","getClaudeService","responseContent","responseMetadata","contentLength","handleImplementCommand","codeBlocks","extractCodeBlocks","block","filename","code","handleOptimizeCommand","codeToOptimize","window","activeTextEditor","document","fileName","languageId","getText","optimizedCode","extractMainCodeBlock","handleTestCommand","testFiles","extractTestFiles","testFile","handleFixCommand","handleDebugCommand","handleRefactorCommand","handleModernizeCommand","config","getConfiguration","serviceMode","isAvailable","showInfo","async","messages","userMessage","find","systemMessage","fullPrompt","sendStreamingMessage","temperature","sendMessage","showFallbackMode","codeBlockRegex","blocks","match","exec","inferFilename","classMatch","AgentRegistry","getInstance","instance","getRegisteredAgents","AGENT_CAPABILITIES","capability","getAgentDisplayName","specialization","canHandle","instructionSet","getAgentInfo","suggestAgentForTask","taskDescription","lowerTask","bestMatch","score","getAgentListDescription","getTaskDelegationInfo","currentAgentId","currentAgent","otherAgents","delegationInfo","apiKey","baseURL","maxTokens","conversationMessages","requestBody","max_tokens","system","msg","fetch","method","headers","body","ok","errorData","json","catch","statusText","streamChat","onChunk","reader","getReader","decoder","TextDecoder","done","value","read","lines","decode","line","trim","startsWith","parsed","delta","validateApiKey","testConnection","DocuBotAgent","handleGeneralDocumentationRequest","documentationContent","generateCodeDocumentation","generateReadme","generateApiDocs","generateGeneralDocs","handleReadmeCommand","workspaceFolder","workspaceFolders","projectInfo","analyzeProjectStructure","uri","readmeContent","createReadme","handleApiCommand","apiInfo","analyzeApiEndpoints","apiDocs","createApiDocumentation","handleGuideCommand","guide","createUserGuide","handleCommentsCommand","editor","documentedCode","addDocumentationComments","handleChangelogCommand","gitLog","getGitLog","changelog","createChangelog","documentation","createGeneralDocumentation","handleUpdateInstructionsCommand","agentMatch","currentInstructions","readInstructionFile","improvedInstructions","improveInstructions","handleViewInstructionsCommand","instructions","workspacePath","path","basename","hasPackageJson","dependencies","scripts","mainFiles","packageJsonPath","packageJson","fs","readFile","keys","endpoints","baseUrl","authentication","additionalContext","cp","Promise","resolve","reject","stdout","stderr","buildContextFromResults","r","instructionPath","extensionPath","writeInstructionFile","writeFile","userContext","agents","projectTypes","intentPatterns","contextManager","ConversationContextManager","initializeProjectTypes","initializeIntentPatterns","processRequest","console","workspaceContext","workflow","executeWorkflow","projectType","intent","detectIntent","detectProjectType","createWorkflow","lowerPrompt","isQuestion","test","isImplementation","matchesPatterns","confidence","workspaceRoots","workspaceRoot","packageJsonUri","packageJsonContent","requirementsUri","requirements","filenames","f","projectDef","w","finalResult","suggestions","references","stepIndex","indexOf","possibleNames","possibleName","errorMsg","warn","recentHistory","getFormattedContext","enrichedRequest","stepResult","addEntry","toISOString","input","output","preview","errorMessage","activeEditor","openDocuments","textDocuments","selectedText","currentFile","selection","isEmpty","registerAgent","testRetrieve","getAgentStats","qualityGates","primaryAgent","AVAILABLE_MODELS","provider","tier","strengths","costPerMillion","DEFAULT_AGENT_MODELS","OpusArbitratorAgent","handleGeneralArbitrationRequest","getConflictResolutionPrompt","getDeepEvaluationPrompt","getFinalVerdictPrompt","getSupremeJudgmentPrompt","handleJudgeCommand","handleResolveCommand","handleEvaluateCommand","handleVerdictCommand","getSlashCommands","outputChannel","createOutputChannel","show","appendLine","toLocaleString","version","configManager","AgentConfigurationManager","initialize","VSCodeMasterDispatcher","ChatWidget","commandsToRegister","MultiAgentChatPanel","createOrShow","showInformationMessage","cmd","disposable","registerCommand","subscriptions","agentCreationErrors","OrchestratorAgent","TradeStratAgent","ResearchAgent","ReviewerGPTAgent","registrationErrors","participant","createChatParticipant","createHandler","dispatcherAgentId","registeredAgents","createFileCommand","showErrorMessage","fileUri","Buffer","openTextDocument","showTextDocument","insertAtCursorCommand","position","active","edit","editBuilder","insert","applySuggestionCommand","suggestionData","executeCommand","testClaudeCommand","testResult","success","showAgentStatsCommand","statsContent","agentStats","totalExecutions","averageResponseTime","lastExecution","toFixed","formatAgentStats","showHelpCommand","helpContent","generateHelpContent","planImplementationCommand","task","architecture","executeWorkflowCommand","configureAgentModelsCommand","availableModels","getAvailableModels","agentIds","currentModel","getAgentModel","modelOptions","modelId","label","detail","selected","showQuickPick","title","placeHolder","ignoreFocusOut","setAgentModel","showAgentPerformanceCommand","performanceReport","metrics","getAgentMetrics","charAt","toUpperCase","successfulExecutions","currentStreak","bestStreak","openConfigDirectoryCommand","configPath","forceNewWindow","showWarningMessage","registerCommands","showWelcomeMessage","extension","packageJSON","stack","activeWorkflows","workflowEngine","WorkflowEngine","memoryManager","MemoryManager","sharedContext","getSharedContext","communicationBus","getCommunicationBus","registerCommunicationHandlers","buildContextWithMemory","chatHistory","history","complexity","analyzeTaskComplexity","handleSimpleTask","handleModerateTask","handleComplexTask","similarTasks","complexities","t","Boolean","counts","acc","c","complexityIndicators","complex","moderate","simple","level","node","addNode","executeWorkflowWithProgress","displayResults","storeTaskMemory","handleDirectResponse","decomposition","decomposeTask","subtasks","subtask","dep","addEdge","to","plan","createExecutionPlan","displayExecutionPlan","requiredAgents","parallelizable","estimatedDuration","session","startCollaboration","groupParallelTasks","parallelNode","children","taskNode","condition","createCondition","undefined","displayAdvancedExecutionPlan","executeComplexWorkflow","completeCollaboration","displayComplexResults","storeComplexTaskMemory","extractAndStorePatterns","createSimpleDecomposition","mainGoal","priority","expectedOutput","sorted","parallelGroup","workflowId","on","event","getContext","execute","sessionId","stage","stageId","updateCollaborationContext","requestAgentHelp","updateContext","createCheckpoint","checkpoints","lastCheckpoint","restoreFromCheckpoint","nodeId","helpResponse","requestHelp","solution","adjustWorkflow","modifications","suggestion","stages","parallelism","parallel","nodes","criticalPath","prevNode","currNode","successes","failures","insights","generateInsights","insight","collaborationStats","totalMessages","activeSessions","total","mostUsedAgent","longRunning","duration","taskMemory","taskId","outcome","determineOverallStatus","quality","calculateQuality","improvements","suggestImprovements","calculateTotalDuration","agentsInvolved","extractAgents","lessonsLearned","extractLessons","st","assignedAgent","successfulSubtasks","successfulApproach","collaborations","fromAgent","toAgent","fromEntries","rate","totalQuality","lessons","conditionStr","register","messageTypes","MessageType","CONFLICT","STATUS_UPDATE","ERROR","handleAgentMessage","resolveConflict","updateWorkflowStatus","acknowledged","handleAgentError","conflict","send","requiresResponse","routing","recovery","attemptRecovery","action","escalate","similarErrors","alternativeAgent","activeAgents","getActiveAgents","module","exports","require","ResponseType","responseHistory","maxHistorySize","chatConfig","getDefaultChatConfig","showEmojis","showTimestamps","showDetailedResponses","logLevel","responseFormat","fallbackMode","unifiedResponse","responseType","details","logToHistory","responseParts","emoji","getEmojiForType","toLocaleTimeString","hour12","hour","minute","second","getAgentName","formatDetails","formattedResponse","logResponse","INITIALIZATION","EXECUTING","SUCCESS","WARNING","FALLBACK","INFO","TOOL_USE","DEBUG","key","replace","shouldLog","levels","configuredLevel","showInitialization","additionalInfo","selectedModel","getCapabilities","assign","showExecutionStart","contextKeys","conversationHistorySize","showSuccess","showWarning","showError","String","reason","fallbackAction","mode","showToolUse","toolName","parameters","tool","getResponseHistory","getFormattedHistory","clearHistory","exportHistory","updateChatConfig","getChatConfig","AgentCommunicationBus","handlers","messageQueue","processingQueue","collaborationSessions","messageHistory","responseCallbacks","setMaxListeners","initializeStats","startQueueProcessor","unregister","fullMessage","generateMessageId","updateStats","processQueue","timeout","messageId","timer","setTimeout","clearTimeout","broadcast","BROADCAST","participants","leader","generateSessionId","startTime","all","COLLABORATION_REQUEST","conversationId","collaborationMessage","NOTIFICATION","recipients","endTime","problem","preferredAgents","HELP_REQUEST","responses","requestTime","RESPONSE","replyTo","shareKnowledge","knowledge","relevantAgents","KNOWLEDGE_SHARE","requestValidation","validator","VALIDATION_REQUEST","reportConflict","reportingAgent","conflictingAgents","issue","reportedBy","shift","deliverMessage","failedMessages","retryCount","determineRecipients","recipientId","callback","isArray","setInterval","messagesByType","messagesByAgent","typeCount","agentCount","totalResponseTime","responseCount","originalMsg","getMessageHistory","getActiveSessions","configuration","models","getDefaultLearningConfig","determineConfigPath","ensureConfigStructure","loadConfiguration","loadInstructionSets","createDefaultModelConfig","lastUpdated","saveModelConfiguration","getAgentInstructions","loadInstructionFile","updateAgentInstructions","newContent","trigger","adaptation","oldContent","lastModified","modifiedBy","adaptationHistory","saveInstructionFile","recordAgentPerformance","responseTime","createDefaultMetrics","max","failedExecutions","totalTime","enabled","checkForLearningOpportunity","saveMetrics","getLearningConfig","updateLearningConfig","saveLearningConfig","homeDir","process","env","HOME","USERPROFILE","directories","dir","mkdir","recursive","loadModelConfiguration","loadLearningConfiguration","loadMetrics","configFile","configs","defaultModel","copyDefaultInstructionFile","instructionFile","sourcePath","targetPath","displayName","performanceScore","successPatterns","failurePatterns","adaptationThreshold","maxAdaptationsPerDay","confidenceLevel","learningModes","successBasedLearning","failureBasedLearning","patternRecognition","contextualAdaptation","metricsFile","metricsArray","today","toDateString","choices","ClaudeCodeService","currentProcess","seenToolsInSession","pendingTools","toolResults","toolGroupBuffer","lastToolName","hasStartedTextOutput","sendStreamJsonMessage","sendSimpleMessage","args","claudeProcess","spawn","shell","platform","stdio","errorOutput","stdin","write","end","hasReceivedText","toolUseDetected","buffer","pop","jsonData","processJsonStreamData","meta","eventType","onMetadata","signal","FORCE_COLOR","NO_COLOR","rawOutput","chunk","kill","cleanToolMarkers","subtype","tools","session_id","flushToolGroup","tool_use_id","pendingTool","toolInBuffer","partial_json","content_block","usage","inputTokens","input_tokens","outputTokens","output_tokens","cacheCreationInputTokens","cache_creation_input_tokens","cacheReadInputTokens","cache_read_input_tokens","stop_reason","stopReason","resultMetadata","resultType","total_cost_usd","totalCostUsd","duration_ms","durationMs","duration_api_ms","durationApiMs","num_turns","numTurns","is_error","isError","error2","stdout2","stderr2","verError","verStdout","cancel","groupedMessage","formatToolMessage","formatToolDetails","todos","readPath","file_path","readDetails","offset","writePath","editPath","editDetails","edits","url","subagent_type","dispose","webSearchService","WebSearchService","isWebAccessAvailable","getSearchEngineStatus","engine","configured","handleGeneralResearchRequest","searchQuery","analysisPrompt","searchResults","analyzeSearchResults","resultsCount","handleSearchCommand","totalResults","snippet","analysis","handleDocumentationCommand","techQuery","docResults","handleMarketCommand","marketQuery","handleCompareCommand","compareQuery","resultsContent","unreadCount","lastMessage","statusBarItem","createStatusBarItem","StatusBarAlignment","Right","updateStatusBar","toggleCommand","toggleChat","quickChatCommand","showQuickChat","clearUnreadCommand","clearUnreadCount","backgroundColor","ThemeColor","pulseInterval","startPulseAnimation","stopPulseAnimation","tooltip","MarkdownString","truncateMessage","isPulsing","clearInterval","panel","showInputBox","addMessage","updateUnreadCount","incrementUnread","setLastMessage","maxLength","showNotification","currentPanel","then","SharedContextManager","contextHistory","subscribers","locks","initializeContext","lockHolder","notifySubscribers","contextObj","getContextWithHistory","subscribe","subscriber","unsubscribe","promises","subscriberList","err","acquireLock","releaseLock","mergeContext","updates","resolver","grouped","keyUpdates","resolvedValue","resolved","createSnapshot","restoreSnapshot","snapshot","clearContext","recentTime","getCollaborationMetrics","totalUpdates","lockedKeys","agentUpdates","agentActivity","searchEngine","maxResults","searchWithPerplexity","searchWithTavily","searchWithSERP","searchWithCustom","return_citations","citations","citation","api_key","search_depth","include_answer","include_images","include_raw_content","max_results","raw_content","URL","searchParams","append","organic_results","link","endpoint","total_results","handleGeneralReviewRequest","reviewResult","foundBugs","performCodeReview","performSecurityCheck","performPerformanceReview","performGeneralReview","requiresCodeSmithFix","issues","handleReviewCommand","review","reviewCode","handleBugsCommand","bugReport","findCommonBugs","debugCommand","terminal","createTerminal","sendText","handleTestUICommand","uiTests","handleSecurityCommand","getWorkspaceCode","securityReport","performSecurityScan","handlePerformanceCommand","analyzePerformance","handleStandardsCommand","standardsReport","checkCodingStandards","testReport","reviewTestCoverage","codeMatch","handleArchitectureReviewCommand","conversationContext","architectureReview","validateArchitectureUnderstanding","workflows","executors","templates","initializeTemplates","template","generateWorkflowId","edges","startNode","endNodes","state","currentNodes","completedNodes","failedNodes","applyTemplate","edge","fromNode","toNode","sortedNodes","topologicalSort","groupIntoStages","findCriticalPath","estimateDuration","calculateParallelism","executor","WorkflowExecutor","pause","resume","checkpoint","generateCheckpointId","checkpointId","isNodeBeforeCheckpoint","adjustment","removeNode","modifyNode","rerouteEdges","rerouting","visited","visiting","visit","childId","unshift","_","nodeStage","depId","depStage","distances","previous","nodeDistance","childDistance","maxDistance","endNode","distance","current","n","parallelCounts","checkpointNodeId","findIndex","child","route","edgeIdx","e","newTo","nodeConfig","paused","cancelled","executeStage","executeNode","retries","maxRetries","retryPolicy","maxAttempts","executeTask","executeDecision","executeParallel","executeSequential","executeLoop","backoff","pow","backoffMultiplier","maxBackoffMs","attempt","decision","childNode","sequential","iteration","loop","column","ViewColumn","Two","_panel","reveal","_dispatcher","createWebviewPanel","enableScripts","retainContextWhenHidden","localResourceRoots","_disposables","_messages","_currentAgent","_currentMode","_extensionUri","_contextManager","_update","onDidDispose","webview","onDidReceiveMessage","_handleWebviewMessage","onDidChangeViewState","visible","_restoreMessages","html","_getHtmlForWebview","styleResetUri","asWebviewUri","styleVSCodeUri","cacheBuster","styleChatUri","scriptUri","nonce","possible","getNonce","cspSource","_processUserMessage","_handleQuickAction","_handlePlanFirst","selectedAgent","postMessage","streamingMessageId","_addStreamingMessage","_updateStreamingMessage","_callAgentWithStreaming","_finalizeStreamingMessage","_processWorkflow","_addErrorMessage","_callAgent","taskRequest","_getWorkspaceContext","fullContent","partialContent","stepMatch","_addSystemMessage","cleanedContent","toolMatches","matchAll","toolContent","_addToolNotification","parts","finalContent","streamingMessage","isCollapsible","isStreaming","isToolNotification","contentToAdd","hasToolNotifications","needsNewBubble","thinkingMatch","thinkingContent","_addSystemNotification","toolMatch","resultMatch","toolId","_updateToolResult","newMessage","_isSpecialMessage","parentMessageId","isSystemNotification","cost","_addCompletionMessage","completionContent","completionMessage","isCompletionMessage","_buildMetadataInfo","metadataInfo","cacheCreation","cacheRead","agentMessage","_addAgentResponse","assistantMessage","postResult","relatedMessageId","toolMsgId","normalizedAgent","agentColor","_getAgentColor","agentEmoji","_getAgentEmoji","toolMessage","planPrompt","isPlanFirst","x","UnifiedChatMixin","successCount","handleError","commandHandler","methodName","showAvailableCommands","contextString","getTaskDelegationContext","registry","checkForTaskDelegation","suggestedAgent","agentInfo","renderCode","button","arguments","addFileReference","filePath","reference","getModelConfig","getMaxTokens","isLoggingEnabled","getRecentHistory","getAgentHistory","recent","getLastOutput","importHistory","imported","handleGeneralTradingRequest","getStrategyDesignSystemPrompt","getBacktestSystemPrompt","getRiskAnalysisSystemPrompt","getValidationSystemPrompt","handleStrategyCommand","pythonCode","extractPythonCode","handleBacktestCommand","backtestCode","handleRiskCommand","getRiskManagementSystemPrompt","riskCode","tradingCode","__webpack_module_cache__","__webpack_exports__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","call"],"sourceRoot":""}