"""
Git-based checkpoint manager for task completion and rollback
ASIMOV RULE 2: Complete implementation - no partial commits
"""

import subprocess
import logging
from typing import Dict, Any, Optional, Tuple
from datetime import datetime
import os

logger = logging.getLogger(__name__)


class GitCheckpointManager:
    """
    Manages git checkpoints after task completion
    Used for rollback when user stops during pause
    """

    def __init__(self, project_path: str = None):
        self.project_path = project_path or os.getcwd()
        self.last_checkpoint_hash = None
        self.current_task_id = None

    def is_git_repo(self) -> bool:
        """Check if current directory is a git repository"""
        try:
            result = subprocess.run(
                ['git', 'rev-parse', '--is-inside-work-tree'],
                cwd=self.project_path,
                capture_output=True,
                text=True
            )
            return result.returncode == 0
        except Exception as e:
            logger.error(f"Error checking git repo: {e}")
            return False

    def has_uncommitted_changes(self) -> bool:
        """Check if there are uncommitted changes"""
        try:
            result = subprocess.run(
                ['git', 'status', '--porcelain'],
                cwd=self.project_path,
                capture_output=True,
                text=True
            )
            return bool(result.stdout.strip())
        except Exception as e:
            logger.error(f"Error checking git status: {e}")
            return False

    async def create_checkpoint(self, task_description: str, task_id: str) -> Dict[str, Any]:
        """
        Create a git checkpoint after task completion
        ASIMOV RULE 2: Only commit COMPLETE tasks
        """
        if not self.is_git_repo():
            logger.warning("Not a git repository - checkpoint disabled")
            return {'status': 'no_git', 'message': 'Not a git repository'}

        if not self.has_uncommitted_changes():
            logger.info("No changes to commit")
            return {'status': 'no_changes', 'message': 'No changes to commit'}

        try:
            # Add all changes
            subprocess.run(
                ['git', 'add', '-A'],
                cwd=self.project_path,
                check=True
            )

            # Create commit message
            commit_message = self._create_commit_message(task_description, task_id)

            # Commit with message
            result = subprocess.run(
                ['git', 'commit', '-m', commit_message],
                cwd=self.project_path,
                capture_output=True,
                text=True,
                check=True
            )

            # Get commit hash
            hash_result = subprocess.run(
                ['git', 'rev-parse', 'HEAD'],
                cwd=self.project_path,
                capture_output=True,
                text=True,
                check=True
            )

            commit_hash = hash_result.stdout.strip()
            self.last_checkpoint_hash = commit_hash

            logger.info(f"âœ… Checkpoint created: {commit_hash[:8]}")

            return {
                'status': 'success',
                'commit_hash': commit_hash,
                'message': commit_message,
                'timestamp': datetime.now().isoformat()
            }

        except subprocess.CalledProcessError as e:
            logger.error(f"Git commit failed: {e}")
            return {
                'status': 'error',
                'error': str(e),
                'stderr': e.stderr if hasattr(e, 'stderr') else None
            }

    def _create_commit_message(self, task_description: str, task_id: str) -> str:
        """Create standardized commit message"""
        # Truncate long descriptions
        short_desc = task_description[:72] if len(task_description) > 72 else task_description

        return f"""ðŸ¤– KI AutoAgent Task Completed: {short_desc}

Task ID: {task_id}
Timestamp: {datetime.now().isoformat()}
Status: COMPLETE

This is an automated checkpoint for potential rollback.
All changes in this commit are part of a completed task.

Generated by KI AutoAgent v4.0.22"""

    async def rollback_to_checkpoint(self, checkpoint_hash: str = None) -> Dict[str, Any]:
        """
        Rollback to a specific checkpoint or last checkpoint
        ASIMOV RULE 1: No silent fallback - fail if rollback fails
        """
        if not self.is_git_repo():
            raise Exception("Cannot rollback - not a git repository")

        target_hash = checkpoint_hash or self.last_checkpoint_hash

        if not target_hash:
            raise Exception("No checkpoint available for rollback")

        try:
            # First, stash any current changes (in case of partial work)
            subprocess.run(
                ['git', 'stash', 'push', '-m', 'KI_Agent_rollback_stash'],
                cwd=self.project_path,
                capture_output=True,
                text=True
            )

            # Hard reset to checkpoint
            result = subprocess.run(
                ['git', 'reset', '--hard', target_hash],
                cwd=self.project_path,
                capture_output=True,
                text=True,
                check=True
            )

            logger.info(f"âœ… Rolled back to checkpoint: {target_hash[:8]}")

            return {
                'status': 'success',
                'rolled_back_to': target_hash,
                'message': f'Successfully rolled back to {target_hash[:8]}'
            }

        except subprocess.CalledProcessError as e:
            logger.error(f"Rollback failed: {e}")
            raise Exception(f"Git rollback failed: {e}")

    def get_recent_checkpoints(self, limit: int = 5) -> list[Dict[str, str]]:
        """Get recent checkpoints for user selection"""
        if not self.is_git_repo():
            return []

        try:
            result = subprocess.run(
                ['git', 'log', '--oneline', '-n', str(limit), '--grep=KI AutoAgent Task'],
                cwd=self.project_path,
                capture_output=True,
                text=True
            )

            checkpoints = []
            for line in result.stdout.strip().split('\n'):
                if line:
                    parts = line.split(' ', 1)
                    if len(parts) == 2:
                        checkpoints.append({
                            'hash': parts[0],
                            'message': parts[1]
                        })

            return checkpoints

        except Exception as e:
            logger.error(f"Error getting checkpoints: {e}")
            return []

    async def create_safety_checkpoint(self) -> str:
        """
        Create a safety checkpoint before starting a new task
        This allows rollback even if task is interrupted
        """
        if not self.is_git_repo():
            return None

        if not self.has_uncommitted_changes():
            # No changes, use current HEAD as checkpoint
            result = subprocess.run(
                ['git', 'rev-parse', 'HEAD'],
                cwd=self.project_path,
                capture_output=True,
                text=True
            )
            return result.stdout.strip() if result.returncode == 0 else None

        # Create WIP commit for safety
        try:
            subprocess.run(['git', 'add', '-A'], cwd=self.project_path, check=True)

            subprocess.run(
                ['git', 'commit', '-m', 'ðŸ”„ WIP: Safety checkpoint before new task'],
                cwd=self.project_path,
                check=True
            )

            result = subprocess.run(
                ['git', 'rev-parse', 'HEAD'],
                cwd=self.project_path,
                capture_output=True,
                text=True
            )

            return result.stdout.strip()

        except Exception as e:
            logger.warning(f"Could not create safety checkpoint: {e}")
            return None