"""
v5.8.3 Phase 3: Agentic RAG for Code Analysis

LangGraph Best Practice: Agent-Controlled Retrieval
- Agent DECIDES when and how to search code
- Agent CHOOSES search strategies dynamically
- Agent REFINES queries based on results

Traditional RAG: User query → Retrieve → Generate
Agentic RAG: Agent analyzes → Agent searches → Agent synthesizes → Repeat if needed
"""

import logging
from typing import Dict, Any, List, Optional
from dataclasses import dataclass
from datetime import datetime

logger = logging.getLogger(__name__)


@dataclass
class SearchResult:
    """Result from code search"""
    file_path: str
    content: str
    relevance_score: float
    metadata: Dict[str, Any]


@dataclass
class AgenticSearchPlan:
    """Search plan generated by agent"""
    strategy: str  # "semantic", "keyword", "pattern", "multi-stage"
    queries: List[str]
    filters: Dict[str, Any]
    reasoning: str  # Why this search strategy?


class AgenticCodeRAG:
    """
    Agentic RAG Implementation

    The agent controls the retrieval process:
    1. Analyzes the task/question
    2. Plans search strategy
    3. Executes searches
    4. Evaluates results
    5. Decides to refine or continue
    """

    def __init__(self, code_indexer=None, vector_store=None):
        """
        Initialize Agentic RAG

        Args:
            code_indexer: Code indexing service
            vector_store: Vector store for semantic search
        """
        self.code_indexer = code_indexer
        self.vector_store = vector_store
        self.search_history: List[Dict[str, Any]] = []

    async def analyze_and_plan(self, task: str, context: Dict[str, Any]) -> AgenticSearchPlan:
        """
        Agent analyzes task and plans search strategy

        This is the "Agentic" part - the agent THINKS about HOW to search
        """
        task_lower = task.lower()

        # Agent reasoning: What kind of search is needed?
        if any(word in task_lower for word in ["find all", "list", "enumerate", "what are"]):
            # Broad search
            strategy = "semantic"
            queries = [task]
            reasoning = "Broad semantic search for comprehensive results"

        elif any(word in task_lower for word in ["how", "where", "which"]):
            # Specific lookup
            strategy = "keyword"
            # Extract key terms
            key_terms = self._extract_key_terms(task)
            queries = key_terms
            reasoning = f"Keyword search for specific terms: {', '.join(key_terms)}"

        elif any(word in task_lower for word in ["pattern", "similar", "like"]):
            # Pattern matching
            strategy = "pattern"
            queries = [task]
            reasoning = "Pattern-based search for code similarities"

        elif any(word in task_lower for word in ["complex", "understand", "explain"]):
            # Multi-stage deep search
            strategy = "multi-stage"
            queries = [
                task,  # Initial broad search
                f"implementation details: {task}",  # Dive deeper
                f"dependencies and usage: {task}"  # Find connections
            ]
            reasoning = "Multi-stage search: broad → specific → connections"

        else:
            # Default: semantic search
            strategy = "semantic"
            queries = [task]
            reasoning = "Default semantic search"

        # Add filters based on context
        filters = {}
        if "language" in context:
            filters["language"] = context["language"]
        if "module" in context:
            filters["module"] = context["module"]

        logger.info(f"🧠 Agent search plan: {strategy} - {reasoning}")

        return AgenticSearchPlan(
            strategy=strategy,
            queries=queries,
            filters=filters,
            reasoning=reasoning
        )

    async def execute_search(self, plan: AgenticSearchPlan) -> List[SearchResult]:
        """
        Execute search plan

        Agent applies different search methods based on strategy
        """
        all_results = []

        for query in plan.queries:
            if plan.strategy == "semantic":
                results = await self._semantic_search(query, plan.filters)
            elif plan.strategy == "keyword":
                results = await self._keyword_search(query, plan.filters)
            elif plan.strategy == "pattern":
                results = await self._pattern_search(query, plan.filters)
            elif plan.strategy == "multi-stage":
                # Multi-stage: combine different methods
                semantic_results = await self._semantic_search(query, plan.filters)
                keyword_results = await self._keyword_search(query, plan.filters)
                results = self._merge_and_rank(semantic_results, keyword_results)
            else:
                results = []

            all_results.extend(results)

        # Agent evaluates: Are results good enough?
        quality_score = self._evaluate_results(all_results)

        # Record search
        self.search_history.append({
            "plan": plan,
            "num_results": len(all_results),
            "quality_score": quality_score,
            "timestamp": datetime.now().isoformat()
        })

        logger.info(f"📊 Search executed: {len(all_results)} results, quality: {quality_score:.2f}")

        return all_results

    async def should_refine(self, results: List[SearchResult], task: str) -> bool:
        """
        Agent decides: Should I refine the search?

        This is Agentic intelligence - knowing when to stop or continue
        """
        if not results:
            logger.info("🔄 No results - will refine search")
            return True

        quality_score = self._evaluate_results(results)

        if quality_score < 0.5:
            logger.info(f"🔄 Low quality ({quality_score:.2f}) - will refine search")
            return True

        # Check if results actually answer the task
        # (In real implementation: Use LLM to evaluate)
        if len(results) < 3:
            logger.info("🔄 Too few results - will refine search")
            return True

        logger.info(f"✅ Good results ({quality_score:.2f}) - search complete")
        return False

    async def refine_search(self, original_task: str, previous_results: List[SearchResult]) -> AgenticSearchPlan:
        """
        Agent creates refined search plan based on previous results
        """
        logger.info("🔍 Agent refining search strategy...")

        # Analyze what's missing
        if not previous_results:
            # No results: broaden search
            return AgenticSearchPlan(
                strategy="semantic",
                queries=[f"related to {original_task}", f"similar to {original_task}"],
                filters={},
                reasoning="Broadening search - previous search too narrow"
            )

        # Some results but low quality: try different approach
        return AgenticSearchPlan(
            strategy="multi-stage",
            queries=[
                f"alternative implementation: {original_task}",
                f"usage examples: {original_task}"
            ],
            filters={},
            reasoning="Trying alternative search angles for better results"
        )

    # Helper methods (simplified - real implementation would use actual search tools)

    async def _semantic_search(self, query: str, filters: Dict) -> List[SearchResult]:
        """Semantic vector search"""
        # In real implementation: Use vector_store
        logger.debug(f"Semantic search: {query}")
        return []

    async def _keyword_search(self, query: str, filters: Dict) -> List[SearchResult]:
        """Keyword/exact match search"""
        # In real implementation: Use code_indexer
        logger.debug(f"Keyword search: {query}")
        return []

    async def _pattern_search(self, query: str, filters: Dict) -> List[SearchResult]:
        """Pattern-based code search"""
        # In real implementation: Use AST/regex patterns
        logger.debug(f"Pattern search: {query}")
        return []

    def _merge_and_rank(self, *result_sets: List[SearchResult]) -> List[SearchResult]:
        """Merge and rank results from multiple searches"""
        # Combine, deduplicate, rank by relevance
        all_results = []
        for results in result_sets:
            all_results.extend(results)

        # Sort by relevance score
        all_results.sort(key=lambda r: r.relevance_score, reverse=True)

        return all_results

    def _evaluate_results(self, results: List[SearchResult]) -> float:
        """Evaluate result quality (0-1)"""
        if not results:
            return 0.0

        # Simple quality metric: average relevance score
        avg_relevance = sum(r.relevance_score for r in results) / len(results)

        # Bonus for diversity (different files)
        unique_files = len(set(r.file_path for r in results))
        diversity_bonus = min(unique_files / 10, 0.2)  # Max 0.2 bonus

        return min(avg_relevance + diversity_bonus, 1.0)

    def _extract_key_terms(self, text: str) -> List[str]:
        """Extract key terms from text"""
        # Simplified: In real implementation use NLP
        stopwords = {"the", "a", "an", "is", "are", "how", "what", "where", "which"}
        words = text.lower().split()
        key_terms = [w for w in words if w not in stopwords and len(w) > 3]
        return key_terms[:5]  # Top 5 terms


async def agentic_code_search(task: str, context: Dict[str, Any], code_indexer=None, vector_store=None) -> List[SearchResult]:
    """
    Convenience function for agentic code search

    Example usage:
        results = await agentic_code_search(
            "Find all API endpoints that handle user authentication",
            context={"language": "python"},
            code_indexer=indexer,
            vector_store=store
        )

    The agent will:
    1. Analyze the task
    2. Plan search strategy
    3. Execute searches
    4. Refine if needed
    5. Return best results
    """
    rag = AgenticCodeRAG(code_indexer, vector_store)

    # Initial search
    plan = await rag.analyze_and_plan(task, context)
    results = await rag.execute_search(plan)

    # Refine if needed (max 2 refinements)
    for _ in range(2):
        should_refine = await rag.should_refine(results, task)
        if not should_refine:
            break

        refined_plan = await rag.refine_search(task, results)
        new_results = await rag.execute_search(refined_plan)

        # Merge with previous results
        results = rag._merge_and_rank(results, new_results)

    return results
