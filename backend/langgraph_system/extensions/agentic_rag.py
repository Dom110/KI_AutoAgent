"""
v5.8.3 Phase 3: Agentic RAG for Code Analysis

LangGraph Best Practice: Agent-Controlled Retrieval
- Agent DECIDES when and how to search code
- Agent CHOOSES search strategies dynamically
- Agent REFINES queries based on results

Traditional RAG: User query â†’ Retrieve â†’ Generate
Agentic RAG: Agent analyzes â†’ Agent searches â†’ Agent synthesizes â†’ Repeat if needed
"""

import logging
from typing import Dict, Any, List, Optional
from dataclasses import dataclass
from datetime import datetime

logger = logging.getLogger(__name__)


@dataclass
class SearchResult:
    """Result from code search"""
    file_path: str
    content: str
    relevance_score: float
    metadata: Dict[str, Any]


@dataclass
class AgenticSearchPlan:
    """Search plan generated by agent"""
    strategy: str  # "semantic", "keyword", "pattern", "multi-stage"
    queries: List[str]
    filters: Dict[str, Any]
    reasoning: str  # Why this search strategy?


class AgenticCodeRAG:
    """
    Agentic RAG Implementation

    The agent controls the retrieval process:
    1. Analyzes the task/question
    2. Plans search strategy
    3. Executes searches
    4. Evaluates results
    5. Decides to refine or continue
    """

    def __init__(self, code_indexer=None, vector_store=None):
        """
        Initialize Agentic RAG

        Args:
            code_indexer: Code indexing service
            vector_store: Vector store for semantic search
        """
        self.code_indexer = code_indexer
        self.vector_store = vector_store
        self.search_history: List[Dict[str, Any]] = []

    async def analyze_and_plan(self, task: str, context: Dict[str, Any]) -> AgenticSearchPlan:
        """
        Agent analyzes task and plans search strategy

        This is the "Agentic" part - the agent THINKS about HOW to search
        """
        task_lower = task.lower()

        # Agent reasoning: What kind of search is needed?
        if any(word in task_lower for word in ["find all", "list", "enumerate", "what are"]):
            # Broad search
            strategy = "semantic"
            queries = [task]
            reasoning = "Broad semantic search for comprehensive results"

        elif any(word in task_lower for word in ["how", "where", "which"]):
            # Specific lookup
            strategy = "keyword"
            # Extract key terms
            key_terms = self._extract_key_terms(task)
            queries = key_terms
            reasoning = f"Keyword search for specific terms: {', '.join(key_terms)}"

        elif any(word in task_lower for word in ["pattern", "similar", "like"]):
            # Pattern matching
            strategy = "pattern"
            queries = [task]
            reasoning = "Pattern-based search for code similarities"

        elif any(word in task_lower for word in ["complex", "understand", "explain"]):
            # Multi-stage deep search
            strategy = "multi-stage"
            queries = [
                task,  # Initial broad search
                f"implementation details: {task}",  # Dive deeper
                f"dependencies and usage: {task}"  # Find connections
            ]
            reasoning = "Multi-stage search: broad â†’ specific â†’ connections"

        else:
            # Default: semantic search
            strategy = "semantic"
            queries = [task]
            reasoning = "Default semantic search"

        # Add filters based on context
        filters = {}
        if "language" in context:
            filters["language"] = context["language"]
        if "module" in context:
            filters["module"] = context["module"]

        logger.info(f"ðŸ§  Agent search plan: {strategy} - {reasoning}")

        return AgenticSearchPlan(
            strategy=strategy,
            queries=queries,
            filters=filters,
            reasoning=reasoning
        )

    async def execute_search(self, plan: AgenticSearchPlan) -> List[SearchResult]:
        """
        Execute search plan

        Agent applies different search methods based on strategy
        """
        all_results = []

        for query in plan.queries:
            if plan.strategy == "semantic":
                results = await self._semantic_search(query, plan.filters)
            elif plan.strategy == "keyword":
                results = await self._keyword_search(query, plan.filters)
            elif plan.strategy == "pattern":
                results = await self._pattern_search(query, plan.filters)
            elif plan.strategy == "multi-stage":
                # Multi-stage: combine different methods
                semantic_results = await self._semantic_search(query, plan.filters)
                keyword_results = await self._keyword_search(query, plan.filters)
                results = self._merge_and_rank(semantic_results, keyword_results)
            else:
                results = []

            all_results.extend(results)

        # Agent evaluates: Are results good enough?
        quality_score = self._evaluate_results(all_results)

        # Record search
        self.search_history.append({
            "plan": plan,
            "num_results": len(all_results),
            "quality_score": quality_score,
            "timestamp": datetime.now().isoformat()
        })

        logger.info(f"ðŸ“Š Search executed: {len(all_results)} results, quality: {quality_score:.2f}")

        return all_results

    async def should_refine(self, results: List[SearchResult], task: str) -> bool:
        """
        Agent decides: Should I refine the search?

        This is Agentic intelligence - knowing when to stop or continue
        """
        if not results:
            logger.info("ðŸ”„ No results - will refine search")
            return True

        quality_score = self._evaluate_results(results)

        if quality_score < 0.5:
            logger.info(f"ðŸ”„ Low quality ({quality_score:.2f}) - will refine search")
            return True

        # Check if results actually answer the task
        # (In real implementation: Use LLM to evaluate)
        if len(results) < 3:
            logger.info("ðŸ”„ Too few results - will refine search")
            return True

        logger.info(f"âœ… Good results ({quality_score:.2f}) - search complete")
        return False

    async def refine_search(self, original_task: str, previous_results: List[SearchResult]) -> AgenticSearchPlan:
        """
        Agent creates refined search plan based on previous results
        """
        logger.info("ðŸ” Agent refining search strategy...")

        # Analyze what's missing
        if not previous_results:
            # No results: broaden search
            return AgenticSearchPlan(
                strategy="semantic",
                queries=[f"related to {original_task}", f"similar to {original_task}"],
                filters={},
                reasoning="Broadening search - previous search too narrow"
            )

        # Some results but low quality: try different approach
        return AgenticSearchPlan(
            strategy="multi-stage",
            queries=[
                f"alternative implementation: {original_task}",
                f"usage examples: {original_task}"
            ],
            filters={},
            reasoning="Trying alternative search angles for better results"
        )

    # Helper methods (simplified - real implementation would use actual search tools)

    async def _semantic_search(self, query: str, filters: Dict) -> List[SearchResult]:
        """Semantic vector search"""
        # In real implementation: Use vector_store
        logger.debug(f"Semantic search: {query}")
        return []

    async def _keyword_search(self, query: str, filters: Dict) -> List[SearchResult]:
        """Keyword/exact match search"""
        # In real implementation: Use code_indexer
        logger.debug(f"Keyword search: {query}")
        return []

    async def _pattern_search(self, query: str, filters: Dict) -> List[SearchResult]:
        """Pattern-based code search"""
        # In real implementation: Use AST/regex patterns
        logger.debug(f"Pattern search: {query}")
        return []

    def _merge_and_rank(self, *result_sets: List[SearchResult]) -> List[SearchResult]:
        """Merge and rank results from multiple searches"""
        # Combine, deduplicate, rank by relevance
        all_results = []
        for results in result_sets:
            all_results.extend(results)

        # Sort by relevance score
        all_results.sort(key=lambda r: r.relevance_score, reverse=True)

        return all_results

    def _evaluate_results(self, results: List[SearchResult]) -> float:
        """Evaluate result quality (0-1)"""
        if not results:
            return 0.0

        # Simple quality metric: average relevance score
        avg_relevance = sum(r.relevance_score for r in results) / len(results)

        # Bonus for diversity (different files)
        unique_files = len(set(r.file_path for r in results))
        diversity_bonus = min(unique_files / 10, 0.2)  # Max 0.2 bonus

        return min(avg_relevance + diversity_bonus, 1.0)

    def _extract_key_terms(self, text: str) -> List[str]:
        """Extract key terms from text"""
        # Simplified: In real implementation use NLP
        stopwords = {"the", "a", "an", "is", "are", "how", "what", "where", "which"}
        words = text.lower().split()
        key_terms = [w for w in words if w not in stopwords and len(w) > 3]
        return key_terms[:5]  # Top 5 terms


async def agentic_code_search(task: str, context: Dict[str, Any], code_indexer=None, vector_store=None) -> List[SearchResult]:
    """
    Convenience function for agentic code search

    Example usage:
        results = await agentic_code_search(
            "Find all API endpoints that handle user authentication",
            context={"language": "python"},
            code_indexer=indexer,
            vector_store=store
        )

    The agent will:
    1. Analyze the task
    2. Plan search strategy
    3. Execute searches
    4. Refine if needed
    5. Return best results
    """
    rag = AgenticCodeRAG(code_indexer, vector_store)

    # Initial search
    plan = await rag.analyze_and_plan(task, context)
    results = await rag.execute_search(plan)

    # Refine if needed (max 2 refinements)
    for _ in range(2):
        should_refine = await rag.should_refine(results, task)
        if not should_refine:
            break

        refined_plan = await rag.refine_search(task, results)
        new_results = await rag.execute_search(refined_plan)

        # Merge with previous results
        results = rag._merge_and_rank(results, new_results)

    return results
