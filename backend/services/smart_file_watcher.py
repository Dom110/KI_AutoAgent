"""
Smart File Watcher with Debouncing and Bot-Change Detection
Prevents circular re-indexing when bot writes code
"""

import asyncio
import os
import logging
from pathlib import Path
from typing import Set, Optional, Callable
from datetime import datetime, timedelta
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler, FileModifiedEvent

logger = logging.getLogger(__name__)

class SmartFileWatcher(FileSystemEventHandler):
    """
    Intelligent file watcher that:
    1. Ignores bot's own changes
    2. Debounces rapid changes (30 second default)
    3. Only invalidates affected caches
    """

    def __init__(self, project_path: str, cache_service, debounce_seconds: int = 30):
        self.project_path = Path(project_path)
        self.cache_service = cache_service
        self.debounce_seconds = debounce_seconds

        # Track pending changes
        self.pending_changes: Set[Path] = set()
        self.debounce_timer: Optional[asyncio.Task] = None
        self.last_bot_write: Optional[datetime] = None

        # Bot change detection markers
        self.bot_markers = [
            '.ki_autoagent_tmp',  # Temp files created by bot
            '# Generated by KI AutoAgent',  # Comment marker
            '# Bot-generated code',
            '# KI AutoAgent',
            'Generated by CodeSmithAgent',
            'Generated by ArchitectAgent'
        ]

        # File patterns to monitor
        self.watch_extensions = {
            '.py', '.js', '.ts', '.jsx', '.tsx', '.java', '.cpp', '.c',
            '.cs', '.go', '.rs', '.swift', '.kt', '.rb', '.php', '.vue',
            '.dart', '.scala', '.clj', '.ex', '.exs', '.elm', '.ml'
        }

        # Patterns to always ignore
        self.ignore_patterns = {
            '__pycache__', '.git', 'node_modules', '.venv', 'venv',
            'build', 'dist', '.next', '.cache', '*.pyc', '*.log',
            '.ki_autoagent', '.mypy_cache', '.pytest_cache', '.ruff_cache',
            'target', '.idea', '.vscode', '*.egg-info', '.tox'
        }

        self.observer = None

    def mark_bot_change(self):
        """Mark that bot is about to make changes"""
        self.last_bot_write = datetime.now()
        logger.info("ü§ñ Bot change marker set - will ignore next file changes")

    def is_bot_change(self, file_path: Path) -> bool:
        """Detect if a change was made by the bot"""
        # Check if change happened within 2 seconds of bot write
        if self.last_bot_write:
            time_since_bot_write = (datetime.now() - self.last_bot_write).total_seconds()
            if time_since_bot_write < 2:
                logger.info(f"ü§ñ Ignoring bot's own change to {file_path}")
                return True

        # Check for bot markers in file content
        try:
            if file_path.exists() and file_path.is_file():
                # Only read first 1000 chars to check for markers
                with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                    content = f.read(1000)
                    for marker in self.bot_markers:
                        if marker in content:
                            logger.info(f"ü§ñ Detected bot marker in {file_path}")
                            return True
        except Exception as e:
            logger.debug(f"Could not check file for bot markers: {e}")

        return False

    def should_watch(self, path: Path) -> bool:
        """Check if file should be watched"""
        # Check extension
        if path.suffix not in self.watch_extensions:
            return False

        # Check ignore patterns
        path_str = str(path)
        for pattern in self.ignore_patterns:
            if pattern.replace('*', '') in path_str:
                return False

        return True

    def on_modified(self, event):
        """Handle file modification events"""
        if event.is_directory:
            return

        file_path = Path(event.src_path)

        # Ignore if not a watched file type
        if not self.should_watch(file_path):
            return

        # Ignore bot's own changes
        if self.is_bot_change(file_path):
            return

        # Add to pending changes
        self.pending_changes.add(file_path)
        logger.info(f"üìù File change detected: {file_path.relative_to(self.project_path)}")

        # Reset debounce timer
        self._reset_debounce_timer()

    def _reset_debounce_timer(self):
        """Reset the debounce timer"""
        if self.debounce_timer and not self.debounce_timer.done():
            self.debounce_timer.cancel()

        # Create new timer
        loop = asyncio.get_event_loop()
        self.debounce_timer = loop.create_task(self._process_batch())

    async def _process_batch(self):
        """Process batched changes after debounce period"""
        await asyncio.sleep(self.debounce_seconds)

        if not self.pending_changes:
            return

        logger.info(f"‚è±Ô∏è Processing {len(self.pending_changes)} file changes after {self.debounce_seconds}s debounce")

        # Group changes by type for efficient invalidation
        python_files = []
        frontend_files = []
        other_files = []

        for file_path in self.pending_changes:
            if file_path.suffix == '.py':
                python_files.append(file_path)
            elif file_path.suffix in ['.js', '.ts', '.jsx', '.tsx', '.vue']:
                frontend_files.append(file_path)
            else:
                other_files.append(file_path)

        # Selective cache invalidation
        if python_files:
            await self._invalidate_python_caches(python_files)
        if frontend_files:
            await self._invalidate_frontend_caches(frontend_files)
        if other_files:
            await self._invalidate_other_caches(other_files)

        # Clear pending changes
        self.pending_changes.clear()
        logger.info("‚úÖ Selective cache invalidation complete")

    async def _invalidate_python_caches(self, files: list):
        """Invalidate caches for Python files"""
        # Check if any agent files changed
        agent_files = [f for f in files if 'agents' in str(f)]
        if agent_files:
            # Agent code changed - invalidate agent-specific caches
            for file_path in agent_files:
                agent_name = file_path.stem
                await self.cache_service.invalidate(f'agent_{agent_name}')
                logger.info(f"‚ôªÔ∏è Invalidated cache for agent: {agent_name}")

        # For any Python file, invalidate partial code index
        for file_path in files:
            relative_path = file_path.relative_to(self.project_path)
            await self.cache_service.invalidate_partial('code_index', str(relative_path))

        # If many files changed, invalidate full code index
        if len(files) > 5:
            await self.cache_service.invalidate('code_index')
            logger.info("‚ôªÔ∏è Major changes detected - invalidated full code index")

    async def _invalidate_frontend_caches(self, files: list):
        """Invalidate caches for frontend files"""
        for file_path in files:
            relative_path = file_path.relative_to(self.project_path)
            await self.cache_service.invalidate_partial('frontend_analysis', str(relative_path))

    async def _invalidate_other_caches(self, files: list):
        """Invalidate caches for other file types"""
        # Just invalidate metrics for now
        for file_path in files:
            relative_path = file_path.relative_to(self.project_path)
            await self.cache_service.invalidate_partial('metrics', str(relative_path))

    def start(self):
        """Start watching files"""
        self.observer = Observer()
        self.observer.schedule(self, str(self.project_path), recursive=True)
        self.observer.start()
        logger.info(f"üëÅÔ∏è Smart file watcher started for {self.project_path}")
        logger.info(f"‚è±Ô∏è Debounce period: {self.debounce_seconds} seconds")
        logger.info(f"ü§ñ Bot change detection: ENABLED")

    def stop(self):
        """Stop watching files"""
        if self.observer:
            self.observer.stop()
            self.observer.join()
            logger.info("üëÅÔ∏è Smart file watcher stopped")